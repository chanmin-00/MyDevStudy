# 레지스터

---

레지스터는 **CPU 내부에 존재하는 아주 작은 임시 저장장치**이다. CPU 안에는 여러 종류의 레지스터가 있으며, 각각은 고유한 **이름과 역할**을 가지고 있다.

프로그램을 구성하는 데이터와 명령어는 실행 전후에 레지스터를 거치기 때문에, **레지스터에 저장된 값만 잘 살펴보아도 프로그램의 동작 흐름을 이해할 수 있다.**

대부분의 CPU는 공통적으로 다음과 같은 주요 레지스터들을 가지고 있다. 각 레지스터는 역할에 맞는 정보를 저장한다.

### 1. 프로그램 카운터(PC, Program Counter)

메모리에서 **다음으로 읽어들일 명령어의 주소**를 저장한다. 이를 명령어 포인터(IP, Instruction Pointer)라고 부르기도 한다.

일반적으로 프로그램 카운터는 **명령어가 한 번 실행될 때마다 1씩 증가**하며, 이로 인해 메모리에 저장된 프로그램이 **순차적으로 실행**된다.

하지만 **조건문, 분기문, 함수 리턴문** 등에서는 프로그램의 흐름이 순차적이지 않기 때문에 프로그램 카운터의 값이 **임의의 주소로 변경**되기도 한다.

<img width="543" height="199" alt="image" src="https://github.com/user-attachments/assets/67486ccb-c475-4535-bcc3-cee9d6eb4b15" />

### 2. 명령어 레지스터

메모리에서 **방금 읽어들인 명령어**를 저장하는 레지스터이다. 제어장치는 명령어 레지스터에 저장된 명령어를 해석한 뒤,  ALU(산술논리연산장치)를 통해 연산을 수행하게 하거나 다른 하드웨어 구성요소로 **제어 신호를 전달**한다.

### 3. 범용 레지스터

가장 자유롭게 사용할 수 있는 레지스터로, **데이터, 명령어, 주소 등 다양한 값을 저장**할 수 있다.

CPU 내부에는 여러 개의 범용 레지스터가 존재하며, 프로그래머가 임시로 데이터를 저장하거나 계산 결과를 보관하는 데 활용한다.

### 4. 플래그 레지스터

연산의 결과나 CPU의 상태를 나타내는 플래그(flag)를 저장하는 레지스터이다. 플래그는 CPU가 명령어를 처리할 때 **참조해야 하는 상태 정보**를 비트 단위로 표현한다.

주요 플래그의 종류는 다음과 같다.

1. **부호 플래그** : 연산 결과의 부호(양수/음수)를 표시
2. **제로 플래그** : 연산 결과가 0인지 여부
3. **캐리 플래그** : 연산에서 올림수나 빌림수가 발생했는지 여부
4. **오버플로우 플래그** : 오버플로우 발생 여부
5. **인터럽트 플래그** : 인터럽트 허용 여부
6. **슈퍼바이저 플래그** : 현재 **커널 모드**인지 **사용자 모드**인지 여부

<img width="500" height="104" alt="image" src="https://github.com/user-attachments/assets/ac68679a-ddf3-4515-8094-aaf20bb89f7d" />

### 5. 스택 포인터

프로그램이 실행될 때, 메모리의 일부 영역은 **스택(Stack)** 형태로 사용된다. 이 영역을 스택 영역(Stack Area)이라고 한다.

스택 포인터는 이 스택 영역에서 가장 최근에 저장된 데이터의 위치(스택의 꼭대기)를 가리키는 특별한 레지스터이다. 즉, 스택 포인터는 **스택의 최상단 주소**를 저장하며, 스택이 얼마나 채워져 있는지를 나타내기도 한다.

<img width="402" height="203" alt="image" src="https://github.com/user-attachments/assets/574e04b3-f29c-4ee3-86f4-f79105a69de2" />

# 인터럽트

---

인터럽트는 다양한 상황에서 발생할 수 있다. 임의로 발생시키거나, 잘못된 프로그램으로 인해 발생하기도 하며,

효율적인 입출력을 위해 사용되기도 한다. ‘인터럽트(Interrupt)’는 **방해하다**, **중단시키다**라는 뜻으로, CPU가 수행 중인 작업을 잠시 멈추게 하는 신호를 의미한다.

인터럽트는 크게 **동기 인터럽트**와 **비동기 인터럽트**로 구분된다.

### 1. 동기 인터럽트

CPU에 의해 발생하는 인터럽트로, **프로그램 실행 중 오류나 예외적인 상황**이 생길 때 발생한다. 예를 들어 잘못된 메모리 접근이나 0으로 나누는 연산 등이 있다. 이러한 이유로 동기 인터럽트는 예외(Exception)라고 부르기도 한다.

### 2. 비동기 인터럽트

**주로 입출력 장치에 의해 발생하는 인터럽트**로, 세탁기의 “세탁 완료 알림”처럼 **작업 완료를 알리는 역할**을 한다.

CPU가 프린터 같은 장치에 작업을 요청하면, 작업을 마친 장치가 CPU에게 완료 신호(인터럽트)를 보낸다. 일반적으로 비동기 인터럽트를 단순히 ‘인터럽트’라고 부르지만, 책에서는 **하드웨어 인터럽트**라는 용어를 사용한다.

## 하드웨어 인터럽트 (비동기 인터럽트)

CPU는 명령어를 효율적으로 처리하기 위해 **하드웨어 인터럽트**를 사용한다. 일반적으로 **입출력 장치의 속도는 CPU보다 매우 느리다.** 따라서 CPU는 입출력 작업의 결과를 즉시 받을 수 없다.

이 상황에서 하드웨어 인터럽트를 사용하지 않으면, 입출력 장치의 작업이 끝났는지 여부를 CPU가 계속 확인해야 한다.

- 작업 여부를 반복적으로 확인하는 것을 폴링(Polling)이라고 한다.
- 즉, 입출력 장치의 상태나 처리할 데이터가 있는지를 주기적으로 확인하는 방식이다.

하지만 하드웨어 인터럽트를 사용하면 CPU는 입출력 장치의 작업이 끝나기를 기다릴 필요 없이 **다른 작업을 처리**할 수 있다. 이로써 CPU 사이클 낭비를 최소화하고, CPU가 다른 명령을 수행할 수 있는 시간을 확보하여 **전체 처리 효율을 높인다.**

### **CPU가 하드웨어 인터럽트를 처리하는 순서**

1. 입출력 장치는 CPU에게 **인터럽트 요청 신호**를 보낸다.
2. CPU는 **명령어 인출 단계 전**, 즉 실행 사이클이 끝날 때마다 인터럽트 여부를 확인한다.
3. CPU는 요청을 확인하고, **인터럽트 플래그**를 통해 인터럽트를 받아들일 수 있는지 판단한다.
4. 인터럽트를 받아들일 수 있다면, CPU는 **현재까지의 작업을 백업**한다.
5. CPU는 **인터럽트 벡터**를 참조하여 해당 인터럽트 서비스 루틴(ISR)을 실행한다.
6. 서비스 루틴 실행이 끝나면, 백업해 둔 작업을 복구하고 원래 프로그램을 재개한다

### **인터럽트 플래그**

**인터럽트 플래그**는 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그이다.

플래그가 ‘비활성화’ 상태라면, CPU는 요청이 오더라도 이를 무시한다. 하지만 모든 하드웨어 인터럽트를 무시할 수 있는 것은 아니다. 

무시할 수 없는 인터럽트(Non-maskable interrupt, NMI)도 존재한다. 이는 가장 **우선순위가 높은 긴급한 인터럽트**로, 정전이나 하드웨어 고장 등 시스템에 치명적인 상황에서 발생한다.

즉, 하드웨어 인터럽트에는 **인터럽트 플래그로 막을 수 있는 인터럽트**, **막을 수 없는 인터럽트(NMI)** 두 종류가 존재한다.

<img width="463" height="249" alt="image" src="https://github.com/user-attachments/assets/e5846c43-af56-4782-ad34-df03a3391af2" />

### **인터럽트 서비스 루틴(ISR)**

CPU가 인터럽트 요청을 수락하면, 그 요청을 처리하기 위한 프로그램인 인터럽트 서비스 루틴(Interrupt Service Routine)을 실행한다. 이를 **인터럽트 핸들러**라고도 부른다.

인터럽트 서비스 루틴은 “어떤 인터럽트가 발생했을 때, 그에 따라 어떤 작업을 수행해야 하는가”를 정의한 프로그램이다.

즉, **인터럽트를 처리한다는 것은 ISR을 실행하고, 원래 작업으로 복귀하는 것**을 의미한다. 입출력 장치마다 처리 방식이 다르기 때문에 각 장치마다 **서로 다른 인터럽트 서비스 루틴**을 가진다.

이 여러 루틴들은 메모리에 저장되어 있으며, CPU는 **인터럽트 벡터**를 통해 각 루틴을 구분한다.

<img width="425" height="415" alt="image" src="https://github.com/user-attachments/assets/22e993da-b86c-47f1-b6cb-c8f83949905f" />

### **인터럽트 벡터**

**인터럽트 벡터**는 각 인터럽트 서비스 루틴을 식별하기 위한 정보이다. CPU는 인터럽트 요청을 보낸 장치로부터 버스를 통해 인터럽트 벡터를 전달받는다.

이 벡터에는 **인터럽트 서비스 루틴의 시작 주소**가 포함되어 있어, CPU가 즉시 해당 루틴을 실행할 수 있다.

<img width="408" height="351" alt="image" src="https://github.com/user-attachments/assets/66f029eb-0539-437b-b396-b633bfdb9f3a" />

즉, CPU가 인터럽트를 처리한다는 것은 인터럽트 서비스 루틴을 실행하고, 완료 후 백업해 둔 상태를 복구하여 원래 프로그램으로 돌아오는 과정을 의미한다.

### 처리 과정 요약

1. CPU는 ISR 실행 전, 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 정보를 **스택에 백업**한다.
2. 이후 ISR의 시작 주소(인터럽트 벡터로부터 획득)를 **프로그램 카운터에 갱신**한다.
3. ISR 실행 후, 백업된 정보를 복원하여 원래 프로그램을 이어서 실행한다.

<img width="481" height="462" alt="image" src="https://github.com/user-attachments/assets/9cd5fdf8-b410-4705-ad36-adf39f1e9417" />

## 예외(동기 인터럽트)

예외의 종류에는 **폴트**, **트랩**, **중단**, **소프트웨어 인터럽트** 등이 있다. CPU는 예외가 발생하면 현재 수행 중이던 작업을 잠시 중단하고 예외를 처리한 뒤, 다시 본래 작업으로 돌아와 실행을 재개한다.

예외 처리 후 **어느 시점에서 실행을 다시 시작하느냐**에 따라 예외는 **폴트**와 **트랩**으로 구분된다. 즉, 예외가 발생한 명령어부터 다시 실행하느냐, 아니면 그 다음 명령어부터 실행하느냐의 차이이다.

### 폴트

예외를 처리한 직후, **예외가 발생한 명령어부터 다시 실행**하는 예외이다. 대표적인 예로 페이지 폴트(Page Fault)가 있다.

명령어 실행에 필요한 데이터가 메모리가 아닌 보조기억장치에 저장되어 있을 경우, CPU는 페이지 폴트를 발생시켜 해당 데이터를 메모리로 가져온다.

필요한 데이터가 메모리에 적재되면, CPU는 폴트가 발생했던 **그 명령어부터 다시 실행**을 이어간다.

<img width="330" height="232" alt="image" src="https://github.com/user-attachments/assets/68189723-bb89-426b-8414-0746dc8f32d1" />

### 트랩

예외를 처리한 직후, **예외가 발생한 명령어의 다음 명령어부터 실행**을 재개하는 예외이다.

대표적인 사례는 디버깅의 브레이크 포인트이다. 프로그램의 특정 지점에 브레이크 포인트를 설정하면 그 코드가 실행되는 순간 프로그램이 멈추고, 디버깅이 끝난 후에는 **트랩이 발생한 다음 명령어부터** 실행이 재개된다.

### 중단

CPU가 실행 중인 프로그램에서 복구할 수 없는 심각한 오류를 발견했을 때 발생하는 예외이다. 이 경우 CPU는 프로그램을 강제로 중단시킨다.

### 소프트웨어 인터럽트

시스템 콜(System Call)이 발생할 때 발생하는 예외이다.

# CPU 성능 향상을 위한 설계

---

## CPU 클럭 속도

클럭이란 **컴퓨터의 부품들이 일정한 속도로 동작하도록 맞추는 시간 단위**이다. 클럭 주기에 맞춰 레지스터 간의 데이터 이동, ALU 연산, 메모리 접근 등이 수행된다.

클럭 속도는 **헤르츠(Hz)** 단위로 측정되며, 이는 클럭이 **1초에 몇 번 반복되는가**를 의미한다. 예를 들어, 1초에 100번 반복되는 CPU는 **100Hz**의 속도를 가진다. 최근에는 클럭 속도가 매우 빨라져 **기가헤르츠(GHz)** 단위로 측정된다.

클럭 속도가 높을수록 CPU는 명령어 사이클을 더 빠르게 반복하므로 더 많은 연산을 단위 시간 내에 처리할 수 있다. 즉, 일반적으로 **클럭 속도가 높을수록 CPU 성능이 좋다.**

하지만 필요 이상으로 클럭 속도를 높이면 **발열이 심해지고 전력 소모가 증가**하기 때문에 CPU 성능 향상에는 물리적인 한계가 있다.

## 멀티 코어와 멀티 스레드

코어(Core)란 CPU 내부에서 명령어를 **읽고, 해석하고, 실행하는 부품**을 의미한다. 과거에는 CPU 하나에 코어가 하나뿐이었지만, 기술 발전으로 인해 이제는 하나의 CPU 안에 여러 개의 코어를 포함할 수 있게 되었다.

이러한 CPU를 **멀티코어 CPU** 혹은 **멀티코어 프로세서**라고 부른다.

<img width="580" height="192" alt="image" src="https://github.com/user-attachments/assets/0676d035-c10a-44af-9f57-abd7436904d0" />

### 스레드의 개념

스레드(Thread)란 **실행 흐름의 단위**를 의미한다. CPU에서 사용하는 **하드웨어 스레드**와 운영체제나 프로그래밍 언어에서 사용하는 **소프트웨어 스레드**는 서로 구분된다.

### 하드웨어 스레드

하드웨어 스레드는 **하나의 코어가 동시에 처리하는 명령어의 단위**이다. 하나의 코어가 여러 명령어를 동시에 처리할 수 있다면, 그 CPU를 **멀티스레드 CPU** 또는 **멀티스레드 프로세서**라고 한다.

예를 들어, 명령어를 처리하는 부품(코어)이 2개이고, 각 코어가 동시에 2개의 명령어를 처리한다면 **2코어 4스레드 CPU**이다.

하드웨어 스레드는 메모리 관점에서 보면 **하나의 명령어를 동시에 처리하는 논리적 CPU**처럼 보이기 때문에, 이를 논리 프로세서라고 부르기도 한다.

<img width="516" height="140" alt="image" src="https://github.com/user-attachments/assets/66a8711b-45a2-4a3b-a40e-cfa4e5b18e77" />

### 소프트웨어 스레드

소프트웨어 스레드는 **하나의 프로그램 내에서 독립적으로 실행되는 단위**이다. 운영체제에서 흔히 말하는 스레드가 바로 이 소프트웨어 스레드이다.

한 프로그램이 여러 개의 스레드로 실행된다는 것은, **메모리에 적재된 프로그램의 여러 부분이 동시에 실행될 수 있다**는 의미이다.

하드웨어 스레드가 하나뿐인 CPU라도 운영체제는 시간 분할 방식을 통해 여러 소프트웨어 스레드를 번갈아 실행할 수 있다.

따라서 **1코어 1스레드 CPU**로도 다중 스레드 프로그램을 실행할 수 있다. 즉, **하드웨어 스레드와 소프트웨어 스레드의 개념을 구분**해 두는 것이 중요하다.

<img width="392" height="163" alt="image" src="https://github.com/user-attachments/assets/65889f1a-f8af-4a3a-b5ac-1c668f3025b6" />

### **동시성과 병렬성**

하드웨어 스레드와 소프트웨어 스레드의 차이는 동시성과 병렬성(Parallelism)의 개념으로 명확히 구분할 수 있다.

- **병렬성(Parallelism)**
    
    물리적으로 여러 작업을 실제로 동시에 처리하는 성질.이다. 예를 들어, 하드웨어 스레드 4개가 4개의 명령어를 동시에 실행하는 경우이다.
    
- **동시성(Concurrency)**
    
    여러 작업을 동시에 실행하는 것처럼 보이는 성질이다.
    
    CPU가 여러 작업을 빠르게 번갈아 처리하면 사용자 입장에서는 동시에 실행되는 것처럼 보이지만, 실제로는 한 시점에 하나의 작업만 수행한다.
    

즉, **하드웨어 스레드**는 병렬성을 구현하기 위한 **물리적인 실행 단위**, **소프트웨어 스레드**는 동시성을 구현하기 위한 **논리적인 실행 단위**이다.

<img width="548" height="208" alt="image" src="https://github.com/user-attachments/assets/1360e487-88ac-44e0-92ed-b2ab334d503a" />

# 파이프라이닝을 통한 명령어 병렬 처리

---

명령어 병렬 처리 기법(ILP, Instruction-Level Parallelism)은 여러 명령어를 동시에 처리하여 CPU가 한순간도 쉬지 않고 작동하도록 함으로써 **CPU의 성능을 극대화하는 기술**이다.

그중에서도 가장 대표적인 방식이 바로 명령어 파이프라이닝이다.

## 명령어 파이프라이닝

하나의 명령어가 처리되는 과정은 다음과 같은 단계로 나눌 수 있다.

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장

여기서 중요한 점은, **서로 같은 단계만 겹치지 않는다면** CPU는 각 단계를 **동시에 병렬로 처리할 수 있다**는 것이다.

즉, CPU는 하나의 명령어를 인출하면서 동시에 다른 명령어를 실행할 수 있고, 실행 중인 명령어의 결과를 저장하면서 또 다른 명령어를 해석할 수도 있다.

<img width="443" height="254" alt="image" src="https://github.com/user-attachments/assets/34b7c1b1-da66-4f2e-a0da-3bc42a15572b" />

### cf) 슈퍼스칼라

슈퍼스칼라 구조란 CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 의미한다. 이러한 CPU를 슈퍼스칼라 프로세서 또는 슈퍼스칼라 CPU라고 부른다.

## **CISC와 RISC**

명령어 파이프라이닝의 효율은 명령어 집합 구조에 따라 달라진다. 대표적인 두 가지 구조는 **CISC**와 **RISC**이다.

### **CISC (Complex Instruction Set Computer)**

이름 그대로 다양한 기능을 수행하는 **복잡한 명령어 집합**으로 구성된다. 적은 수의 명령어로 프로그램을 실행할 수 있지만, 명령어 크기와 실행 시간이 일정하지 않고, 하나의 명령어를 실행하는 데 여러 클럭 주기가 필요하다.

따라서 **파이프라이닝에 비효율적**일 수 있다.

- (예: **인텔(Intel)** 계열 CPU)

### **RISC (Reduced Instruction Set Computer)**

CISC보다 단순하고 **규격화된 짧은 명령어들**로 구성된다. 대부분의 명령어가 **1클럭 내외**에 실행되도록 설계되어 있으며, 일정한 명령어 길이 덕분에 **파이프라이닝에 최적화**되어 있다.

- (예: **애플(Apple)**, **ARM 기반 CPU**)

<img width="429" height="360" alt="image" src="https://github.com/user-attachments/assets/740ee78d-ee41-4990-9dbb-c19f5b25aeaf" />

## 파이프라인 위험 **(Hazard)**

파이프라이닝이 항상 성능 향상을 보장하는 것은 아니다. 여러 명령어를 겹쳐 실행할 때 **충돌이나 지연이 발생하는 상황**을 파이프라인 위험(Pipeline Hazard)이라고 한다.

파이프라인 위험은 크게 세 가지로 나뉜다.

### **1. 데이터 위험**

명령어 간의 **데이터 의존성**으로 인해 발생한다. 특정 명령어가 이전 명령어의 실행 결과를 필요로 할 경우, 앞선 명령어가 완료되기 전까지는 다음 명령어를 실행할 수 없다.

즉, **의존성이 있는 명령어를 무작정 겹쳐 실행하면** 파이프라인이 올바르게 동작하지 않게 된다.

<img width="521" height="131" alt="image" src="https://github.com/user-attachments/assets/bbffbd7e-81aa-4c23-80db-423ebe8da095" />

### **2. 제어 위험 (Control Hazard)**

프로그램 카운터(PC)의 갑작스러운 변화로 인해 발생한다. 점프(Jump)나 인터럽트(Interrupt) 등으로 실행 흐름이 바뀌면, 이미 인출되거나 해석 중인 명령어들이 **무의미한 명령어**가 되어버린다. 이로 인해 파이프라인이 일시적으로 중단될 수 있다.

### 3. 구조적 위험

파이프라이닝된 여러 명령어가 동시에 같은 CPU 자원(ALU, 레지스터 등)을 사용하려 할 때 발생한다.

서로 다른 명령어가 **동일한 하드웨어 자원에 접근을 시도**하면서 충돌이 발생하는 것이다. 이를 자원 위험(Resource Hazard)이라고도 부른다.
