# 파일 시스템

- 파일 시스템은 운영체제가 보조기억장치(HDD, SSD 등)에 저장된 정보를 파일과 디렉터리 형태로 조직하고 관리하는 내부 프로그램입니다.
- 덕분에 수많은 데이터 덩어리를 사용자 친화적인 구조로 관리 가능합니다.
- 하나의 운영체제에서도 여러 종류의 파일 시스템 사용 가능하며, 각 파일 시스템은 데이터 저장/관리 방식이 다릅니다.

# 파일과 디렉터리

## 파일

- 구성 요소: 이름, 파일을 실행하기 위한 정보, 메타데이터(형식, 위치, 크기 등).
- 파일의 형식, 위치, 크기 등은 파일 속성(메타데이터)에 포함되며, 이러한 파일 조작은 반드시 운영체제의 시스템 콜(open, write, close 등)을 통해 수행해야 합니다.
- 응용 프로그램이 여러 파일을 사용할 경우, 각각을 식별하기 위해 파일 디스크립터(file descriptor)라는 정수값을 사용합니다. 이는 리눅스에서는 정수로, 윈도우에서는 파일 핸들(handle)로 불립니다.
- 파일 디스크립터는 단순한 파일뿐 아니라 표준 입출력(0,1,2), 파이프, 소켓, 장치 등 다양한 자원 식별에도 사용되며, 새로 열린 파일은 보통 3번부터 디스크립터가 할당됩니다.

## 디렉터리

- 운영체제는 파일을 효율적으로 관리하기 위해 트리 구조의 디렉터리(폴더)를 사용합니다. 루트 디렉터리(`/`)를 시작으로, 하위 디렉터리가 계층적으로 포함되며, 파일의 위치는 경로(Path)를 통해 표현됩니다
    - `/home/user/a.cpp`
    
    ![image](https://github.com/user-attachments/assets/54410223-6658-428b-8351-29df817bdd2b)
    
- 운영체제는 디렉터리도 특수한 파일로 간주하며 그 안에는 해당 디렉터리에 속한 파일들의 정보를 담은 디렉터리 엔트리가 테이블 형태로 저장됩니다.
- 디렉터리 엔트리에는 파일 이름과 저장 위치 정보가 포함되며 일부 파일 시스템은 파일 속성 정보도 함께 저장합니다.
- 리눅스의 경우, 디렉터리 엔트리에는 파일의 아이노드 번호가 기록되어 있어 이를 통해 실제 파일 위치를 찾을 수 있습니다.

![image](https://github.com/user-attachments/assets/5b6e91d0-d370-4afc-a9bb-e8355e2cb376)


- 리눅스 운영체제의 디렉터리 엔트리 관련 소스코드를 통해 파일의 아이노드 번호가 파일이 저장된 위치를 유추할 수 있는 정보에 해당함을 알 수 있습니다.

## 파일 할당

- 운영체제가 파일과 디렉터리를 보조기억장치에 저장할 때는 블록(block)이라는 단위로 저장합니다.
- 보통 하나의 블록 크기는 4096 바이트(4KB)이며, 하나의 파일은 여러 블록을 할당받아 저장됩니다.
    
    ![image](https://github.com/user-attachments/assets/752c484b-063f-4c68-936a-5d1092e4331a)

    
- 보조기억장치에는 여러 블록이 존재하며, 각 블록은 고유한 블록 주소를 가집니다. 파일 시스템에 따라 파일을 어떤 블록에 어떻게 배치할 것인지가 달라지며, 이때 사용하는 대표적인 방식이 다음 두 가지입니다.

### 연결 할당 (Linked Allocation)

- 각 블록의 일부 공간에 다음 블록의 주소를 저장
- 마치 체인처럼 블록들이 연결됨
- 디렉터리 엔트리에는 첫 블록 주소와 전체 블록 수가 저장됨

![image](https://github.com/user-attachments/assets/8b78e75b-c69c-4c8d-a135-5f14a51f32d4)


### 색인 할당 (Indexed Allocation)

- 모든 블록의 주소를 색인 블록(index block)에 모아 저장
- 디렉터리 엔트리는 파일 이름 + 색인 블록 주소를 포함
- 색인 블록만 알면 전체 파일에 빠르게 접근 가능

![image](https://github.com/user-attachments/assets/5f8388de-b0a1-4367-b3d7-3fae30f490e3)


# 파일 시스템

- 하나의 컴퓨터, 하나의 운영체제에서 여러 파일 시스템을 동시에 사용할 수 있습니다.
- 보조기억장치를 여러 영역(파티션)으로 나누고, 각 파티션에 다른 파일 시스템을 설정하면 됩니다. 이 작업을 파티셔닝(partitioning)이라고 하며, 구획된 영역을 파티션(partition)이라고 부릅니다.
- 파일 시스템을 설정하는 작업은 포맷팅(formatting)이라고 하며, 포맷팅을 통해 파일을 어떤 구조로 저장할지를 결정하게 됩니다.
- 대표적인 파일 시스템으로는 EXT, EXT2, EXT3, EXT4, XFS, ZFS 등이 있으며, 각 파일 시스템은 저장 방식, 속성, 성능 등이 다릅니다.

## 아이노드 기반 파일 시스템

- 리눅스, 맥 OS 등에서는 아이노드(inode) 기반의 파일 시스템을 사용합니다. 아이노드는 파일의 거의 모든 정보(이름 제외)를 저장하고 있는 색인 블록입니다.
    - 각 파일은 하나의 아이노드를 가집니다.
    - 아이노드에는 파일 위치, 크기, 권한, 생성 시간, 수정 시간 등의 정보가 존재합니다.
    - `ls -i` 명령어를 통해 파일의 아이노드 번호를 확인할 수 있습니다.

![image](https://github.com/user-attachments/assets/f44d0065-3559-40ae-9f8a-bb940abe8687)


### EXT4 구조 예시

- EXT4는 여러 블록 그룹으로 구성되며, 각 그룹은 다음 요소들로 구성됩니다.
    - `슈퍼 블록`: 파일 시스템 전체 정보 (블록 수, 아이노드 수 등)
    - `그룹 식별자`: 블록 그룹 관련 메타데이터
    - `블록 비트맵`: 어떤 블록이 사용 중인지 표시
    - `아이노드 비트맵`: 어떤 아이노드가 사용 중인지 표시
    - `아이노드 테이블`: 실제 아이노드 정보 저장
    - `데이터 블록`: 실제 파일 데이터 저장
- 아이노드가 부족하면 데이터 블록 공간이 남아 있어도 새 파일 생성이 불가합니다.

![image](https://github.com/user-attachments/assets/1b38f7f1-5110-4ccb-90a4-98c3b42209aa)


> **하드링크와 심볼릭 링크**
> 
> - 아이노드 기반으로 만들 수 있다면 하드 링크 파일과 심볼릭 링크 파일도 이해 가능합니다.
> - 디렉터리 A에 속한 파일 A, 디렉터리 엔트리에 파일 이름과 아이노드 번호가 명시되어 있다면 해당 아이노드에 접근할 수 있고, 아이노드를 통해 파일 데이터에 접근 가능 합니다.
>     
>     ![image](https://github.com/user-attachments/assets/2175f60f-ed81-4ede-9d19-4e17e22f0afa)
>     
> - `하드링크`: 기존 파일과 같은 아이노드 번호를 참조 (파일을 공유)
> - `심볼릭 링크`: 기존 파일의 경로만 문자열로 저장 (윈도우의 바로가기와 유사)
> - 하드링크는 파일 삭제 후에도 아이노드가 유지되면 내용이 남아 있지만, 심볼릭 링크는 원본 삭제 시 경로가 무효가 됩니다.
>     
>     ![image](https://github.com/user-attachments/assets/33914610-67d5-4b6d-b7ce-b8db8d16b1b7)
>     

## 마운트

- USB 메모리 같은 외부 저장 장치를 컴퓨터에 연결하면, 컴퓨터의 파일 시스템 트리에 해당 장치의 파일 시스템이 편입되는 작업이 발생합니다. 이를 `마운트`라고 부릅니다.
- 예를 들어, USB 메모리를 `/mnt` 디렉터리에 마운트하면, 데스크톱 컴퓨터는 `/mnt/usb` 같은 경로로 USB 내부 파일에 접근할 수 있게 됩니다.
- 이처럼 다른 파일 시스템을 현재 시스템의 계층 구조에 연결하는 방식이 마운트이며, 여러 저장 장치를 하나의 트리처럼 사용할 수 있게 해줍니다.

![image](https://github.com/user-attachments/assets/a886694a-eae9-432e-b30a-19d4bef24cc0)
