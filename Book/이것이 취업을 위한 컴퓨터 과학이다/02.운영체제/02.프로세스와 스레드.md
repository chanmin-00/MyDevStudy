# 프로세스와 스레드

---

- 컴퓨터가 실행되면 다양한 프로세스들이 메모리에 적재되어 실행됩니다.
- 프로세스의 유형
    - `포그라운드 프로세스` : 사용자와 직접 상호작용
    - `백그라운드 프로세스` : 사용자와 직접 상호작용 없이 동작
        - 데몬(Daemon): 사용자 개입 없이 특정 작업을 수행하는 특별한 백그라운드 프로세스
        - 윈도우에서는 이를 ‘서비스’라고 부릅니다.

## 프로세스의 메모리 구조

- 프로세스의 유형을 막론하고 하나의 프로세스를 구성하는 메모리 내의 정보는 크게 다르지 않습니다.
- `커널 영역` : PCB(Process Control Block) 저장
- `사용자 영역` : 실행 중인 프로세스가 코드 영역, 데이터 영역, 힙 영역, 스택 영역으로 나뉘어 저장
    
    ![image](https://github.com/user-attachments/assets/82660129-ae46-452a-a943-ab7da4f40f68)

    

1. **코드 영역 (텍스트 영역)**
    - 실행 가능한 명령어가 저장되는 읽기 전용 공간
    - CPU가 읽고 실행할 명령어가 포함되며, 쓰기는 금지되어 있음
2. **데이터 영역**
    - 정적 변수, 전역 변수 등 실행 중 유지되어야 하는 데이터가 저장
    - `BSS 영역` : 초기값이 없는 정적/전역 변수를 저장하는 하위 영역, 데이터 영역과 유사하지만 초기화 여부의 차이가 존재

<aside>

코드 영역과 데이터 영역은 실행 도중 크기가 변하지 않기 때문에 `*정적 할당 영역*`, 힙 영역과 스택 영역은 실행 중 크기가 변할 수 있어 `*동적 할당 영역*`

</aside>

1. **힙 영역**
    - 사용자가 직접 할당 및 반환하는 동적 메모리 공간
    - 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야 함. 미반환 시 메모리 누수 발생 가능 → 언어에 따라 가비지 컬렉션으로 자동 해소되기도 함
        - `가비지 컬렉션` : 자체적으로 사용되지 않는 힙 메모리를 해제
2. **스택 영역**
    - 지역변수, 매개변수, 함수 복귀 주소 등의 일시적인 데이터 저장
    - `스택 트레이스`: 함수 호출 정보를 저장하여 디버깅에 유용
        - 스택 영역에는 스택 트레이스 형태의 함수 호출 정보가 저장 될 수 있습니다.
        - 스택 트레이스를 통해서 문제의 발생 지점을 추적할 수 있어 디버깅에 매우 유용합니다.

![image](https://github.com/user-attachments/assets/25b6daa7-9614-429f-a458-e3f9695f22fc)


## PCB와 문맥 교환

- 운영체제는 메모리에 적재된 각 프로세스를 식별하고 관리하기 위해 PCB(Process Control Block)를 사용합니다.
    - PCB는 프로세스 생성 시 커널 영역에 생성되고, 프로세스 종료 시 삭제됩니다.
    - PCB는 프로세스와 관련한 다양한 정보를 내포하는 구조체의 일종입니다.
    - 주요 정보: `PID`, `실행 과정에서 사용한 레지스터 값`, `프로세스 상태`, `언제 어떤 순서로 CPU를 할당 받은지 에 대한CPU 스케줄링 정보`, `프로세스의 메모리 상 적재 위치`, `파일 및 입출력 정보` 등
    - 리눅스에서는 task_struct 구조체가 PCB 역할을 수행합니다.
        
        ![image](https://github.com/user-attachments/assets/58197f2d-af44-441b-8df6-68f0dd3c7c25)

        

- 여러 PCB들은 보통 프로세스 테이블이라는 구조로 커널 내에 저장됩니다.
    - 프로세스 테이블은 실행 중인 PCB들의 모음이며, 새로 생성된 프로세스의 PCB는 여기에 추가되고, 프로세스가 종료되면 PCB는 제거됩니다.
    - 프로세스가 비정상 종료되고 자원은 해제됐지만 PCB가 테이블에 남아있는 경우, 이를 `좀비 프로세스(zombie process)`라고 부릅니다.
        
        ![image](https://github.com/user-attachments/assets/919991d8-aaf8-401a-9dc6-4e39bebf1e0e)

        

> 운영체제도 하나의 프로그램이며, 리눅스는 대표적인 오픈 소스 운영체제입니다.
> 
> 
> 리눅스의 소스 코드는 공개되어 있어 누구나 PCB 구조를 확인할 수 있습니다.
> 

- 운영체제는 여러 프로세스에 한정된 시간 동안 번갈아 CPU 자원을 할당합니다.
    - 프로세스가 실행된다는 것은 운영체제가 해당 프로세스에 CPU를 할당했다는 의미입니다.
    - 각 프로세스는 자신의 차례가 되면 정해진 시간만큼 CPU를 사용하며, 이 시간은 타이머 인터럽트에 의해 제한됩니다. 타이머 인터럽트가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다려야 합니다.
        - `타이머 인터럽트` : 시간이 끝났음을 알리는 인터럽트, 타임아웃 인터럽트라고도 합니다.
            
            ![image](https://github.com/user-attachments/assets/723cc616-3824-4942-8dc5-108c63869f06)

            
- 프로세스는 CPU 사용 시간 동안 다음과 같은 정보를 남겨야 합니다. 즉 중간 정보를 백업해야 합니다.
    - 프로그램 카운터, 레지스터 값, 메모리 상태, 열린 파일, 입출력 장치 등
    - 이를 문맥(context)이라 하며, PCB에 저장되어 나중에 복구할 수 있습니다.
- 문맥 교환(Context Switching)은 다음과 같은 과정입니다:
    1. 기존 프로세스의 문맥을 PCB에 백업
    2. 다음 프로세스의 문맥을 PCB에서 복원하여 실행
    - 여러 프로세스가 끊임없이 빠르게 번갈아가며 실행되는 원리

> 문맥 교환이 너무 자주 발생하면 캐시 미스가 증가하고, 메모리로부터 실행할 프로세스의 내용을 가져오는 메모리 접근 오버헤드가 커져 성능 저하가 발생할 수 있습니다.
> 

![image](https://github.com/user-attachments/assets/e083180c-0643-43db-9bd8-ac3837f588e0)


![image](https://github.com/user-attachments/assets/4cbe8f17-51a2-44b1-a90e-83fa21e790ec)


## 프로세스의 상태

- 하나의 프로세스는 여러 상태를 거치며 실행됩니다.
- 운영체제는 PCB를 통해 프로세스 상태를 인식하고 관리합니다. 운영체제마다 다소 차이는 있지만, 일반적으로 다음과 같은 상태를 가집니다:
    - `생성 상태(new)`: 프로세스가 생성되어 메모리에 적재되며, PCB가 할당된 상태
    - `준비 상태(ready)`: 실행 준비가 완료되었으며 CPU 할당을 기다리는 상태
        - 준비 상태에서 실행 상태로 전환되는 것을 디스패치(dispatch)라고 합니다.
    - `실행 상태(running)`: CPU를 할당받아 명령어를 실행 중인 상태
        - 일정 시간동안만 CPU를 사용합니다.
    - `대기 상태(blocked)`: 입출력 요청 등으로 인해 실행이 일시적으로 불가능한 상태
        - 대기 상태였던 해당 프로세스는 입출력 작업이 완료되는 등 실행 가능한 상태가 되면 다시 준비 상태가 되어 CPU 할당을 기다립니다.
    - `종료 상태(terminated)`: 프로세스 실행이 끝나 PCB와 메모리 자원이 해제된 상태

![image](https://github.com/user-attachments/assets/014f2829-45fa-42f0-8d79-8260159c1b2c)


> **블로킹 입출력과 논블로킹 입출력**
> 
> - **블로킹 I/O**: 입출력 작업이 완료될 때까지 대기 상태에 들어감
> - **논블로킹 I/O**: 입출력을 요청한 후, 다음 명령어를 즉시 실행함
> - 예를 들어, 네트워크로 메시지를 보내는 시스템 콜을 호출할 때
>     - 블로킹: 메시지가 전송 완료될 때까지 대기
>     - 논블로킹: 대기하지 않고 다음 명령 실행
> 
> ![image](https://github.com/user-attachments/assets/2446ecfa-2a8f-4bf6-86ce-6a2a81d6383d)
> 

# 멀티프로세스와 멀티스레드

---

## 같은 코드를 동시에 실행하는 두 가지 방식

1. **멀티프로세스**
    - 같은 프로그램을 여러 프로세스로 실행
    - 예: 웹 브라우저의 각 탭 → 각기 다른 프로세스로 작동
    - 각 프로세스는 독립적으로 동작하며 자원을 공유하지 않습니다.
        - 같은 작업을 수행하고 있지만 각각의 PID 값이 다르고, 프로세스별로 파일과 입출력 장치 등의 자원이 독립적으로 할당되어 다른 프로세스에 영향을 거의 끼치지 않습니다.
    - 하나의 프로세스에서 오류가 발생해도 다른 프로세스에 영향 없음
    
    ![image](https://github.com/user-attachments/assets/e66b677e-82bc-4c53-813a-36a64ad4b546)

    
    ![image](https://github.com/user-attachments/assets/61cebb6a-bfe0-469d-b7f3-b341df1da998)

    
2. **멀티스레드**
    - 하나의 프로세스 안에서 여러 스레드가 동시 실행
    - 각 스레드는 스레드를 식별할 수 있는 고유의 스레드 ID, 프로그램 카운터, 레지스터, 스택을 가짐
    - 코드, 데이터, 힙 영역은 공유
    
    ![image](https://github.com/user-attachments/assets/993a599a-f224-4474-b8b1-d2fb077a3554)

    

- 가장 큰 차이점은 **자원의 공유 여부**
- 멀티프로세스: 자원을 공유하지 않음
- 멀티스레드: 같은 프로세스를 실행하는 여러 스레드들은 자원을 공유함 → 통신과 협력이 쉬움
    - 스레드들은 동일한 주소 공간의 코드, 데이터, 힙 영역을 공유, 열린 파일과 같은 프로세의 자원을 공유하기 때문에 쉽게 협력하고 통신이 가능합니다.
    - 그러나 한 스레드의 오류가 전체 프로세스에 영향을 줄 수 있음

![image](https://github.com/user-attachments/assets/6cfbf7f5-09ab-40f1-a054-d31e55cdacf5)


> **스레드 조인(join)**
> 
> - join을 호출하면, 스레드를 생성한 주체는 해당 스레드가 종료될 때까지 대기
> - 예: 메인 스레드가 A 스레드를 생성하고 join() 을 호출했다면, 메인 스레드는 A 스레드가 끝날 때까지 기다림
> 
> ![image](https://github.com/user-attachments/assets/e7aa008a-492e-4c1b-9f0f-ecddffd5fdb8)
> 

## 프로세스 간 통신

---

기본적으로 프로세스는 자원을 공유하지 않지만, 자원을 공유하고 데이터를 주고받기 위한 방법은 존재합니다. 이를 IPC (Inter-Process Communication)라고 합니다.

## IPC 방식: 두 가지

1. `공유 메모리` **:** 데이터를 주고받는 프로세스가 공통적으로 사용할 메모리 영역을 두는 방식
2. `메시지 전달` **:** 프로세스 간에 주고받을 데이터를 메시지의 형태로 주고받는 방식

![image](https://github.com/user-attachments/assets/c2d782b7-b2bd-423c-8d83-b498e0201a93)


## 공유 메모리

- 데이터를 주고받는 프로세스가 공통으로 사용하는 메모리 영역을 두는 방식입니다.
- 일반적으로 프로세스는 다른 프로세스의 메모리 공간을 직접 접근할 수 없어서 다른 프로세스의 메모리 공간을 임의로 수정할 수 없지만, 공유 메모리를 통해 서로 읽고 쓸 수 있습니다.
    - A 프로세스가 공유 메모리에 데이터를 쓰고
    - B 프로세스가 해당 데이터를 읽는 방식
    - 결과적으로 프로세스 A가 프로세스 B에게 데이터를 공유한 것과 같은 셈
- 시스템 콜을 통해 공유 메모리 공간을 확보하거나, 공유 파일/변수를 활용할 수도 있습니다.
- 커널의 개입이 거의 없기 때문에 빠른 통신이 가능하나, 서로의 공유 메모리 영역을 동시에 읽고 쓸 경우 레이스 컨디션 등의 문제가 발생할 수 있습니다.

![image](https://github.com/user-attachments/assets/a2f3864b-9612-47dd-aeb1-b58e291f9d19)


![image](https://github.com/user-attachments/assets/7f0f96bd-4270-46cb-9798-e763092b2b50)


hi.txt라는 파일을 매개로 프로세스 간에 통신을 주고 받은 셈

## 메시지 전달

- 데이터가 커널을 거쳐 송수신되는 방식입니다.
- send(), recv() 시스템 콜을 사용합니다.
    - 메시지를 보내는 수단과 받는 수단이 명확하게 구분이 되어 있습니다.
- 공유 메모리에 비해 커널 개입이 크기 때문에 속도는 느리지만, 레이스 컨디션, 동기화 문제에 대한 부담은 적습니다.

## 대표적인 메시지 전달 IPC 방식

- **파이프**
    - 단방향 통신 방식
    - A가 파이프 한쪽에서 데이터를 쓰면, B가 파이프 반대쪽에서 읽음
    - FIFO 구조 (먼저 들어간 데이터가 먼저 읽힘), 파이프에 삽입된 데이터의 관점에서 보면 먼저 파이프에 삽입된 데이터가 먼저 읽히게 됨
    - 양방향 통신 시 읽기용/쓰기용 파이프를 2개 사용
    
    ![image](https://github.com/user-attachments/assets/1bfa9c7b-a111-43bd-beeb-90c8b35ad7f6)

    
    > **익명 파이프 vs 지명 파이프**
    > 
    > - `익명 파이프`: 부모-자식 간 단방향 통신만 가능
    > - `지명 파이프(FIFO)`: 부모-자식 간 뿐만 아니라 임의의 프로세스 간 통신 가능, 양방향 지원

- **시그널**
    - 특정 이벤트 발생을 비동기적으로 알리는 신호
    - 인터럽트와 유사하게 작동하며, 사용자가 직접 정의 가능합니다.
    - 시그널 발생 시, 인터럽트 처리 과정과 유사하게 하던 일을 중단하고, 시그널 핸들러를 실행하고 그 후에 원래 작업 재개합니다.
    - 시그널을 IPC 수단으로 활용 가능
        - 시그널 자체는 IPC만을 위해 존재하는 개념이 아니므로, ‘시그널을 적절히 활용해 IPC를 수행할 수 있다’ 정도로 이해해야 합니다.
        - 시그널이 발생했을 때의 동작을 정의하여 프로세스에게 해당 시그널을 보냄으로써 프로세스 간 통신을 수행 가능합니다.

![image](https://github.com/user-attachments/assets/15012a84-2817-4901-a02d-20a8b8d31257)


![image](https://github.com/user-attachments/assets/cb33593a-cfa0-4947-abbd-7ebd6303741c)


리눅스 운영체제의 대표적인 시그널

> 시그널의 기본 동작과 코어 덤프
> 
> - 대부분의 시그널은 종료, 무시, 또는 코어 덤프 생성
> - `코어 덤프`: 주로 비정상적으로 종료하는 경우에 생성되는 파일, 프로그램이 특정 시점에 작업하던 메모리 상태를 담은 파일로, 디버깅에 활용
> 
> ![image](https://github.com/user-attachments/assets/4db34389-a51b-4572-b2cd-3efcb79b7d88)
> 

- 이 외에도 원격 프로시저 호출(RPC)이나 네트워크 소켓을 통해 IPC를 수행 가능
    - `RPC (Remote Procedure Call)` : 원격의 프로세스에 있는 코드를 호출하여 실행하는 방식
    - 대규모 트래픽 처리나 서버 간 통신 환경에서 주로 사용됨
    - 대표 프레임워크: `gRPC`
