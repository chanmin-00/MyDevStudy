# 배열

- 배열(Array)은 일정한 메모리 공간에 여러 요소들이 순차적으로 나열된 자료구조입니다.
- 각 요소는 0부터 시작하는 인덱스로 식별
- RAM처럼 인덱스를 통한 접근 속도가 일정 → 접근/수정 시간: O(1)

## 배열의 주요 연산 복잡도

![image](https://github.com/user-attachments/assets/adb1b135-04fe-425b-943e-a32eaf231f97)


| 연산 내용 | 시간 복잡도 |
| --- | --- |
| 특정 인덱스에 접근 | O(1) |
| 특정 인덱스 값 수정 | O(1) |
| 특정 요소 탐색 (선형 검색) | O(n) |
| 요소 삽입/삭제 (중간에서) | O(n) |

> 삽입/삭제 시 요소 재정렬 필요 → 시간 소요
> 

## 배열의 구조 확장

- 일차원 배열: 요소를 한 줄로 나열
- 이차원 배열: 2개의 인덱스로 요소 식별 (예: 행, 열)
- 삼차원 배열: 3개의 인덱스로 요소 식별 (예: 층, 행, 열)

![image](https://github.com/user-attachments/assets/f0eaf7f1-795e-4a5b-aaad-3931f2dcca0a)


## cf) 정적 배열과 동적 배열

- 정적 배열
    - 프로그램 실행 전 크기 고정
    - 실행 중 배열 크기 변경 불가
- 동적 배열
    - 실행 중에도 크기 조절 가능
    - 크기를 예측하기 어려운 경우 유용
    - 일부 언어에서는 벡터(vector)로 구현됨

# 연결 리스트

연결 리스트는 노드(Node)들의 모음으로 구성된 자료구조입니다.

각 노드는 다음 노드의 위치(주소)를 함께 저장합니다.

- 노드 구조: 데이터 + 다음 노드 주소
    
    ![image](https://github.com/user-attachments/assets/b31f349c-667b-4f97-a758-69b799d5ccb2)

    
- 메모리 상에 순차적으로 저장되지 않아도 됩니다.
- 첫 번째 노드: 헤드(Head), 마지막 노드: 꼬리(Tail)
    
    ![image](https://github.com/user-attachments/assets/931b2823-d2c7-470b-ae18-d44f3bdc9605)

    

## 연결 리스트의 연산 복잡도

| 연산 내용 | 시간 복잡도 |
| --- | --- |
| 요소 탐색 (앞에서부터 순차 접근) | O(n) |
| 중간 노드 삽입/삭제 (노드 위치 이미 알고 있을 경우) | O(1) |

> 배열은 인덱스만 알면 빠르게 접근 가능하지만, 연결 리스트는 항상 앞에서부터 순차적으로 탐색해야 합니다.
> 

## 배열 vs 연결 리스트 – 삽입/삭제 비교

- 배열: 삽입/삭제 후 요소 재배열 필요 → O(n)
- 연결 리스트: 포인터만 수정 → O(1)

## 연결 리스트의 종류

### 1. 싱글(단일) 연결 리스트

- 한 방향으로만 연결
- 노드마다 다음 노드 주소만 보유
- 단점: 이전 노드 탐색이 불가능

### 2. 이중 연결 리스트 (Doubly Linked List)

- 양방향 탐색 가능
- 노드마다 이전/다음 노드 주소 모두 포함
- 단점: 저장 공간이 더 필요 (주소 2개 저장)
    
    ![image](https://github.com/user-attachments/assets/1f9c07fb-9817-4bbc-a673-98235b0afd52)

    

### 3. 환형 연결 리스트 (Circular Linked List)

- 마지막 노드가 첫 번째 노드를 가리킴
- 연속적으로 순회해야 하는 작업에 유용
- 이중 연결 리스트와 결합하여 원형 구조로 구현 가능
    
    ![image](https://github.com/user-attachments/assets/c7606f34-ce67-4f78-9414-1e6759ec0b03)
