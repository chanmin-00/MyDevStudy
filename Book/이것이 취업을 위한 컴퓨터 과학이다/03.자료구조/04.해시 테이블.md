# 해시 테이블

- 해시 테이블은 키(key)와 값(value)이 쌍을 이루는 테이블 형태의 자료구조
- 키는 해시 테이블의 입력값이며, 값은 해당 키를 통해 접근하고자 하는 데이터입니다.
- 과거에는 페이지 캐시, 아이노드 캐시 등 다양한 캐시 시스템에서 해시 테이블이 활용되었습니다.

## 해시 테이블의 구조

![image](https://github.com/user-attachments/assets/4e9ff6d6-75a8-4901-9e20-4d8f487c9f78)

- `버킷(Bucket)`: 데이터를 저장하는 공간. 해시 테이블은 여러 개의 버킷으로 구성되어 있으며, 이들은 배열 형태로 존재합니다.
- `해시 함수(Hash Function)`: 키를 입력받아 해당 데이터를 저장할 인덱스를 반환하는 함수입니다.
- 반환된 인덱스를 통해 해시 테이블의 특정 버킷에 데이터를 저장하거나 조회합니다.

> 로드 팩터 (Load Factor)
> 
> - 해시 테이블에 저장된 데이터 수 ÷ 버킷 수
> - 테이블이 얼마나 가득 차 있는지를 나타내는 지표입니다. 로드 팩터가 클수록 충돌 가능성이 높아지고, 성능이 저하될 수 있습니다.

# 해시 함수

- 해시 함수는 임의의 길이를 가진 데이터를 입력받아, 고정된 길이의 해시 값으로 변환하는 단방향 함수입니다.
- 입력된 데이터를 고정된 길이로 변환할 수는 있지만, 해시 값을 통해 원래의 입력 데이터를 역산하기는 매우 어렵습니다.

![image](https://github.com/user-attachments/assets/0ead5f68-2f1b-4673-9291-d04560ad2494)


## 해시 알고리즘

- 해시 함수의 연산 방식을 해시 알고리즘이라고 하며, 대표적으로 아래와 같은 것들이 있습니다
    - `MD5`
    - `SHA-1`
    - `SHA-256`
    - `SHA-512`
- 동일한 입력 데이터라도 해시 알고리즘이 다르면 생성되는 해시 값의 길이와 값 모두 달라집니다.
- 또한, 입력 문자열이 한 글자만 달라져도 전혀 다른 해시 값이 도출될 수 있습니다.

## 해시 함수의 활용

- 무작위 값을 만들거나, 단방향 암호를 생성하는 데 사용됩니다.
- 또한, 데이터의 무결성을 검증할 때 활용됩니다.

### 무결성 검증 방식

1. 송신 측에서 보낼 데이터에 대해 해시 값을 계산합니다.
2. 데이터와 함께 이 해시 값을 수신자에게 전달합니다.
3. 수신 측은 받은 데이터로 다시 해시 값을 계산합니다.
4. 계산된 해시 값이 전달받은 값과 같다면 데이터가 정상 전송, 다르다면 변조 또는 훼손되었음을 알 수 있습니다.

> 웹사이트에 비밀번호나 개인정보를 저장할 때는 단방향 암호화 방식을 사용하도록 규제되어 있습니다.
> 
> 
> 대표적인 알고리즘: `bcrypt`, `PBKDF2`, `scrypt` 등
> 

### 간단한 해시 함수인 모듈러 연산

- 모듈러 연산(mod): 나머지를 구하는 연산
- 키가 `k`, 해시 테이블 크기가 `m`일 때 → `h(k) = k mod m` 방식으로 해시 값을 구할 수 있습니다.

이처럼 간단하게 해시 함수를 구현하면, 해시 충돌이 발생할 가능성이 높아집니다.

## 해시 테이블의 장점과 단점

### 장점

- 검색, 삽입, 삭제 연산의 시간 복잡도는 O(1)입니다.
- 입력 값과 관계없이 항상 일정한 속도를 보장합니다.

### 단점

- 빠른 속도를 제공하는 대신, 상대적으로 많은 메모리 공간을 소모합니다.
- 데이터 양이 많아지면 공간복잡도는 시간복잡도만큼 효율적이지 않습니다.
- 해시 충돌 문제가 발생할 수 있습니다. → 반드시 적절한 충돌 해결 기법이 필요합니다.

# 해시 충돌 (Hash Collision)

- 서로 다른 키가 동일한 해시 값을 갖는 현상
- 이로 인해 하나의 버킷에 2개 이상의 데이터가 겹쳐 저장되는 문제가 발생합니다.

> 해시 충돌은 성능 저하뿐 아니라, 보안적인 측면에서도 위험합니다. (데이터가 중간에 바뀌었음에도 해시 값이 일치할 수 있음)
> 

![image](https://github.com/user-attachments/assets/5239cf05-613e-4e93-bf66-5d86c2c83654)


## 해시 충돌 해결 방법

### 체이닝 (Chaining)

- 충돌이 발생한 데이터들을 연결 리스트로 이어서 저장하는 방법입니다.
- 동일한 인덱스에 여러 데이터가 저장될 수 있으며, 각 버킷에 연결 리스트 형태로 노드가 추가됩니다.

> 체이닝은 구현이 단순하지만, 충돌이 자주 발생하면 연결 리스트의 길이가 길어져 검색 속도가 느려지고, 해시 테이블의 빠른 속도라는 장점을 살릴 수 없습니다.
> 

![image](https://github.com/user-attachments/assets/d4c69773-2e78-4cac-80dc-c84d5388b4a2)


### 개방 주소법 (Open Addressing)

- 충돌이 발생했을 때, 충돌된 인덱스 외의 다른 인덱스에 데이터를 저장하는 방식입니다.
- 이때 비어 있는 인덱스를 찾는 과정을 `조사(Probe)`라고 합니다.

**선형 조사법 (Linear Probing)**

- 충돌이 발생한 인덱스의 다음 인덱스부터 순차적으로 가용 인덱스를 탐색합니다.
- 단점: 충돌 인근에 데이터가 몰려 저장되는 `군집화(Clustering)` 문제가 발생할 수 있습니다. 군집화는 긴 탐색을 유발하여 성능이 악화됩니다.

**이차 조사법 (Quadratic Probing)**

- 선형 조사법의 문제를 보완하기 위한 방법입니다.
- 충돌이 발생한 인덱스에서 제곱 수만큼 떨어진 인덱스를 탐색합니다.
    - 예: i번째 충돌 → index + i²
- 군집화 현상을 어느 정도 줄일 수 있지만, 제곱수의 규칙성으로 인해 완전히 해결한다고 보기는 어렵습니다.

**이중 해싱 (Double Hashing)**

- 두 개의 해시 함수를 사용합니다.
- 충돌이 발생했을 때, 보조 해시 함수의 값을 이용하여 일정 간격으로 떨어진 인덱스를 순차적으로 탐색합니다.
    - f(key) + g(key)
    - f(key) + 2g(key)
    - f(key) + 3g(key) ...
- 이중 해싱은 해시 함수가 제공하는 무작위성을 활용하기 때문에, 선형 조사법의 군집화 문제를 상당 부분 피할 수 있습니다.
