## **고객과 설문 조사원 애그리게이트 식별**

두 개의 애그리게이트와 요구사항을 통해 객체지향 설계 원칙을 적용해본다.

- 나이, 연락처 종류, 성별로 배정 대상 고객을 추출한다.
- 추출한 고객을 설문 조사원에게 배정한다.
- 배정 담당자는 배정 시 다양한 배정 알고리듬을 선택할 수 있다.

요구사항을 검토해 보면, 고객은 식별자를 포함해 여섯 개의 속성을 가진다. 고객에게 설문 조사원이 배정되면 고객 클래스의 surveyorId 속성에 설문 조사원의 식별자가 할당된다.

```java
public class Customer {
    private String id;
    private String name;

    private String birthday;
    private String landlinePhone;
    private String mobilePhone;
    private String gender;

    private String surveyorId;
}
```

```java
public class Surveyor {
    private String id;
    private String name;
}
```

배정 비즈니스 로직은 다음과 같다.

개발 팀은 담당자에게 요구사항을 확인하기 위해 배정 로직을 애플리케이션 서비스인 AssignService.assign() 메서드에 빠르게 구현한다. 담당자가 다양한 배정 방법을 적용하기 위해 로직 변경을 요청하면, 개발자는 프로그램을 수정하고 단위 테스트를 실행해 기존 기능에 새로운 결함이 유입되지 않았는지 확인한다.

# 책임 주도 설계

소프트웨어 설계는 일반적으로 **책임, 역할**, **협력**을 중심으로 표현하는 **책임 주도 설계**접근 방식을 따른다. 이 설계 방법은 객체에 적절한 책임을 부여하는 것을 핵심으로 한다.

크레이그 라만은 객체의 책임을 **“아는 것(What it knows)”** 과 **“하는 것(What it does)”** 으로 구분한다.

자바와 같은 객체지향 언어에서 ‘아는 것’은 클래스의 **속성**이고, ‘하는 것’은 **메서드**에 해당한다.

### **하는 것**

- 객체 생성이나 계산과 같이 스스로 수행하는 것
- 다른 객체의 행동을 시작하게 하는 것
- 다른 객체의 행동을 제어하거나 조정하는 것

### **아는 것**

- 자신이 캡슐화하고 있는 데이터를 아는 것
- 관련된 객체에 대해 아는 것
- 자신이 유도하거나 계산할 수 있는 정보를 아는 것

책임은 **추상화 수준**에 따라 크기가 달라진다. 예를 들어, Microsoft Application Architecture Guide에서는 데이터 접근이나 비즈니스 로직처럼 수십 개의 클래스를 하나의 책임 단위로 묶어 설명한다.

반면, UML 실전에서는 이것만 쓴다에서는 **객체(클래스)** 에 개별적인 책임을 부여하는 방식을 다룬다. 이번 장에서는 이러한 관점에서 **클래스에 책임을 부여하는 객체 설계**를 중심으로 살펴본다.

# 단일 책임 원칙

클래스는 **한 가지 일만 수행해야 하며**, **한 가지 이유에 의해서만 변경되어야 한다.** 클래스를 변경해야 하는 이유가 여러 가지라면, 이는 단일 책임 원칙을 지키지 않은 것이다.

### **예시: 고객과 상담사 배정**

고객의 나이를 계산하기 위해 calculateAge() 메서드를 애플리케이션 서비스 클래스에 정의할 수도 있고, 유틸리티 성격의 별도 클래스로 분리할 수도 있다.

하지만 더 객체지향적인 방법은 생년월일 값을 소유하는 Customer 클래스에 나이 계산의 책임을 부여하는 것이다.

또는 생일을 유비쿼터스 언어로 정의하고, 별도의 Birthday 클래스로 분리해 **현재 나이를 계산하는 책임을 부여**할 수도 있다.

<img width="377" height="178" alt="image" src="https://github.com/user-attachments/assets/1c0a3a94-3ccd-46a1-b3bb-050e1aa194b5" />

```java
public class Birthday {

    private Date birthday;

    public Birthday(String birthday) {
        String year = birthday.substring(0, 4);
        String month = birthday.substring(5, 6);
        String day = birthday.substring(7, 8);

        Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.YEAR, Integer.valueOf(year));
        calendar.set(Calendar.MONTH, Integer.valueOf(month) - 1);
        calendar.set(Calendar.DAY_OF_MONTH, Integer.valueOf(day));

        this.birthday = calendar.getTime();
    }

    public int getAge() {
        Calendar birthdayCalendar = Calendar.getInstance();
        birthdayCalendar.setTime(birthday);
        Calendar todayCalendar = Calendar.getInstance();

        return todayCalendar.get(Calendar.YEAR)
             - birthdayCalendar.get(Calendar.YEAR);
    }
}
```

<img width="519" height="310" alt="image" src="https://github.com/user-attachments/assets/1cb9f480-5742-4731-a6a0-e345b9764686" />

연락처 또한 별도의 클래스로 분리할 수 있다. 즉, **“아는 것(데이터)”을 여러 객체로 잘 분리하면 “하는 것(행동)”도 자연스럽게 분리되어**, 단일 책임 원칙을 준수할 수 있다.

### 배정의 책임 분리

고객에게 설문 조사원을 배정하면, 기존에는 Customer 클래스의 surveyorId 속성에 값을 할당했다. 그러나 Customer 클래스는 고객과 직접 관련된 속성만 가져야 한다.

배정과 관련된 속성까지 포함하면 고객 객체에 불필요한 **잡음**이 생기게 된다. 배정은 **고객과 설문 조사원 간의 관계**로 볼 수 있다.

따라서 배정(Assign)을 유비쿼터스 언어로 정의하고, 새로운 Assign 클래스를 추가하면 Customer 클래스의 surveyorId 속성을 제거할 수 있다.

<img width="361" height="262" alt="image" src="https://github.com/user-attachments/assets/0f463b4b-2daf-4cf2-a059-1040ab9295af" />

```java
public class Assign {
    private Customer customer;
    private Surveyor surveyor;
}
```

이 관계로 인해 AssignService.assign() 메서드는 기존의 설문 조사원 ID를 할당한 고객 목록이 아닌, **Assign 객체의 목록**을 반환해야 한다.

```java
public class AssignService {

    public List<Assign> assign(List<Customer> customers,
                               List<Surveyor> surveyors) {
        List<Customer> filteredCustomer = new ArrayList<>();
        for (Customer customer : customers) {
            if (customer.getBirthday().getAge() > 30) {
                filteredCustomer.add(customer);
            }
        }

        filteredCustomer.sort(new Comparator<Customer>() {
            @Override
            public int compare(Customer customer1, Customer customer2) {
                return customer1.getBirthday().getAge()
                        .compareTo(customer2.getBirthday().getAge());
            }
        });

        int i = 0;
        List<Assign> assigns = new ArrayList<>();
        for (Customer customer : filteredCustomer) {
            Surveyor surveyor = surveyors.get(i % surveyors.size());
            Assign newAssign = new Assign(customer, surveyor);
            assigns.add(newAssign);
            i++;
        }

        return assigns;
    }
}
```

# 개방 폐쇄 원칙

소프트웨어 엔티티는 **확장에 대해서는 개방적** 이어야 하지만, **수정에 대해서는 폐쇄적**이어야 한다.

### 톰캣

이 원칙은 대표적인 웹 애플리케이션 서버인 **톰캣**의 동작 방식에서 확인할 수 있다. 서블릿(Servlet)과 JSP를 이용해 개발한 웹 애플리케이션은 war 파일 형태로 패키징되어 톰캣에 배포된다.

이때 war 파일은 톰캣의 고유 기능을 변경하거나 영향을 주지 않으므로 **변경에 대해 폐쇄적**이라 할 수 있다. 반면, war 파일은 새로운 기능을 추가하여 제공하므로 **확장에는 개방적**이다.

확장에 대한 개방은 **구현 클래스나 하위 클래스에서 기능을 추가할 수 있어야 함**을 의미한다.

수정에 대한 폐쇄는 **인터페이스나 상위 클래스의 변경이 구현 클래스나 하위 클래스에 영향을 주지 않아야 함**을 의미한다.

### 배정 후보 필터링

배정 후보 고객을 추출하기 위해 고객의 속성을 조건과 비교해 필터링한다. 필터링이라는 책임 자체는 동일하지만, 구체적인 비교 방식은 나이, 연락처 종류 등 속성에 따라 달라진다.

이 요구사항을 충족하기 위해 **Filter 인터페이스**를 정의하고, 비교 대상 속성에 따라 **다양한 구현 클래스를 추가**하면 된다.

<img width="553" height="245" alt="image" src="https://github.com/user-attachments/assets/687e0839-0454-43ff-88ff-38400104b2ca" />

인터페이스와 구현을 분리했기 때문에, 고객 필터링 방식에 대한 변경 요구가 발생하더라도 **새로운 구현 클래스를 추가하는 것만으로 기능을 확장**할 수 있다.

```java
public interface Filter {
    public boolean isSatisfied(Customer customer);
}

public class AgeFilter implements Filter {

    private int minAge;
    private int maxAge;

    public AgeFilter(int minAge, int maxAge) {
        this.minAge = minAge;
        this.maxAge = maxAge;
    }

    @Override
    public boolean isSatisfied(Customer customer) {
        if (this.minAge <= customer.getBirthday().getAge()
                && customer.getBirthday().getAge() <= this.maxAge) {
            return true;
        }
        return false;
    }
}
```

```java
public interface AssignRule extends Comparator<Customer> {
    public boolean isSatisfied(Customer customer);
}

public class AgeRule implements AssignRule {

    private int minAge;
    private int maxAge;

    public AgeRule(int minAge, int maxAge) {
        this.minAge = minAge;
        this.maxAge = maxAge;
    }

    @Override
    public boolean isSatisfied(Customer customer) {
        if (this.minAge <= customer.getBirthday().getAge()
                && customer.getBirthday().getAge() <= this.maxAge) {
            return true;
        }
        return false;
    }

    @Override
    public int compare(Customer before, Customer after) {
        return before.getBirthday().getAge()
                     .compareTo(after.getBirthday().getAge());
    }
}
```

# 리스코프 치환 원칙

리스코프 치환 원칙은 **클라이언트가 상속 클래스를 안정적으로 사용할 수 있는 구조를 설계하는 데 도움을 주는 원칙**이다.

S가 기반 타입 T의 서브타입이라면, **T 타입의 객체는 프로그램 실행에 문제를 일으키지 않고 S 타입의 객체로 치환될 수 있어야 한다.**

### 기반타입과 서브타입

- **기반타입(Base Type)** 은 클라이언트가 직접 사용하는 타입으로, 클라이언트는 이 타입의 메서드를 호출한다.
- **서브타입(Subtype)** 은 기반타입을 상속받은 모든 종류의 클래스를 말한다.

클라이언트가 호출하는 기반타입의 메서드는 서브타입에서 오버라이드된 메서드를 포함하므로, 클라이언트는 실제 어떤 서브타입이 사용되는지 알 필요가 없다.

즉, 클라이언트는 **기반타입의 문맥**내에서 서브타입을 호출할 수 있다.

### 계약과 가변성 규칙

리스코프 치환 원칙을 지키기 위해서는 다음과 같은 **계약**과 **가변성**규칙을 준수해야 한다.

- 서브타입은 기반타입보다 **더 강력한 사전 조건**을 정의할 수 없다.
- 서브타입은 기반타입보다 **더 완화된 사후 조건**을 정의할 수 없다.
- 기반타입의 **불변식**은 서브타입에서도 반드시 유지되어야 한다.

고객을 필터링한 뒤 설문 조사원에게 균등하게 분배하기 위해 **라운드 로빈**알고리듬을 사용할 수 있다. 하지만 담당자가 원할 경우, **성과가 좋은 설문 조사원에게 더 많은 고객을 배정하는 알고리듬**을 선택적으로 사용할 수도 있다.

<img width="451" height="227" alt="image" src="https://github.com/user-attachments/assets/20fae7ad-5280-4383-9a96-cda7c2b1bc43" />

**분배 책임을 인터페이스로 선언**하고, 알고리듬에 따라 라운드 로빈 방식 또는 실적 우선 방식으로 구현하면 필요에 따라 두 알고리듬을 자유롭게 선택해 사용할 수 있다. 이러한 설계 방식은 **전략 패턴**으로 알려져 있다.

즉, 서브타입이 기반타입의 행위를 위배하지 않으면서도 새로운 기능을 추가할 수 있도록 설계함으로써 리스코프 치환 원칙을 만족하고, 유연하고 안정적인 객체 구조를 유지할 수 있다

# 인터페이스 분리 원칙

인터페이스 분리 원칙은 **너무 많거나 관계없는 오퍼레이션을 한 인터페이스에 모두 포함하지 않도록 제약하는 원칙**이다.

즉, **사용 목적에 따라 인터페이스를 분리함으로써 불필요한 의존을 줄이고, 개발자의 고민을 덜어주는 것**이 목표다.

### **Filterable과 Sortable의 분리**

이 원칙을 적용해, isSatisfied() 오퍼레이션을 제공하는 **Filterable** 인터페이스와 compare() 오퍼레이션을 제공하는 **Sortable** 인터페이스로 분리할 수 있다.

AgeRule 클래스는 두 인터페이스를 모두 구현한다. AgeRule 클래스는 두 인터페이스를 모두 구현한다.

```java
public interface Filterable {
    public boolean isSatisfied(Customer customer);
}

//

public interface Sortable extends Comparator<Customer> {
}
```

기존에는 AssignRule 인터페이스를 통해 필터링과 정렬을 동시에 처리했기 때문에 클라이언트는 두 오퍼레이션(isSatisfied, compare)을 모두 볼 수 있었다.

하지만 Filterable과 Sortable로 분리하면, 필터링을 위한 인터페이스에서는 isSatisfied()만, 정렬을 위한 인터페이스에서는 compare()만 접근할 수 있다. 즉, 클라이언트는 자신이 필요로 하는 기능만 사용할 수 있는 구조가 된다.

실제 업무에서는 단일 조건으로 고객을 필터링하기보다는 여러 필터 조건을 **조합**하여 사용하는 경우가 많다. 이러한 **조건 조합 기능**을 또 다른 책임으로 분리할 수 있으며, 같은 이유로 필터링된 고객을 여러 기준으로 정렬하는 기능 역시 별도의 객체로 분리할 수 있다.

```java
public class Filterables {

    private Filterable filterable;

    public Filterables(Filterable filterable) {
        this.filterable = filterable;
    }

    public List<Customer> filter(List<Customer> customers) {
        List<Customer> results = new ArrayList<>();

        for (Customer customer : customers) {
            if (filterable.isSatisfied(customer)) {
                results.add(customer);
            }
        }

        return results;
    }
}

//

public class Sortables {

    private Sortable sortable;

    public Sortables(Sortable sortable) {
        this.sortable = sortable;
    }

    public List<Customer> sort(List<Customer> customers) {
        customers.sort(sortable);
        return customers;
    }
}
```

이제 AssignService는 **애플리케이션 서비스로서 배정 흐름을 조정하는 책임만** 가진다. 구체적인 비즈니스 로직은 Filterable, Sortable, Customer, Surveyor 등 **도메인 객체의 협력**으로 처리된다.

```java
public class AssignService {

    public List<Assign> assign(List<Customer> customers,
                               List<Surveyor> surveyors) {
        GenderRule rule = new GenderRule("M");
        Filterables filterables = new Filterables(rule);
        List<Customer> filteredCustomer = filterables.filter(customers);

        Sortables sortables = new Sortables(rule);
        filteredCustomer = sortables.sort(filteredCustomer);

        Distributable distributable = new RoundRobinDistributor();
        List<Assign> assigns = distributable.distribute(filteredCustomer, surveyors);

        return assigns;
    }
}
```

# 의존성 역전 원칙

의존성 역전 원칙은 **객체 설계에서 클라이언트가 구체적인 클래스를 직접 알 필요가 없도록 의존 관계를 분리하는 원칙**이다.

즉, **상위 모듈이 하위 모듈에 의존하지 않고, 추상화된 인터페이스에 의존하도록 만드는 것**이 핵심이다.

이전 구조에서는 구체적인 분배 알고리즘을 구현한 클래스를 사용하는 데 한계가 있었다. 사용하는 객체를 클라이언트(서비스)가 직접 생성해야 했기 때문이다.

```java
public class AssignService {

    public void assign(···) {
        distributable = new RoundrobinDistributabutor();
        distributable.distribute(···);
    }
}
```

이 경우, AssignService는 RoundRobinDistributor라는 **구체 클래스에 직접 의존**하므로 다른 분배 알고리즘을 적용하려면 코드를 수정해야 한다. 이는 **확장에는 닫혀 있고, 수정에 열려 있는 구조**로 바람직하지 않다.

### 순수한 제작물 패턴

크레이그 라만은 GRASP 패턴 중 하나로 **순수한 제작물**패턴을 소개했다. 이 패턴은 도메인에 존재하지 않는 가상의 객체를 추가함으로써 **응집도를 높이고 결합도를 낮추는 데 활용**할 수 있다.

이 패턴을 적용해, **AssignBundle 클래스**를 새로 추가한다. 그리고 AssignService가 가지고 있던 **고객 추출, 정렬, 상담원 배정 책임**을 이 클래스로 이동시킨다.

```java
public class AssignBundle {

    private List<Customer> customers;
    private List<Surveyor> surveyors;

    private Filterables filterables;
    private Sortables sortables;
    private Distributable distributable;

    public AssignBundle(List<Customer> customers,
                        List<Surveyor> surveyors) {
        this.customers = customers;
        this.surveyors = surveyors;
    }

    public void setFilterables(Filterables filterables) {
        this.filterables = filterables;
    }

    public void setSortables(Sortables sortables) {
        this.sortables = sortables;
    }

    public void setDistributable(Distributable distributable) {
        this.distributable = distributable;
    }

    public List<Assign> assign() {
        List<Customer> filteredCustomer = filterables.filter(customers);
        filteredCustomer = sortables.sort(filteredCustomer);

        Distributable distributable = new RoundRobinDistributor();
        List<Assign> assigns = distributable.distribute(filteredCustomer, surveyors);

        return assigns;
    }
}
```

배정 담당자는 사용자 인터페이스에서 **배정에 필요한 추출 기준, 정렬 조건, 분배 알고리즘**을 선택하고 배정을 요청한다.

즉, Filterables, Sortables, Distributable을 구현한 객체 인스턴스를 assign() 메서드를 호출하기 전에 **setter를 통해 주입**하면 된다.

AssignService는 **애플리케이션 서비스**로서, 데이터베이스에서 고객과 설문 조사원 목록을 조회하고AssignBundle을 생성하여 필요한 로직을 조합한다.

필터, 정렬, 배정 알고리즘을 할당하고 배정 로직을 실행한 뒤, 결과를 데이터베이스에 저장한다.

```java
public class AssignService {

    private CustomerDao customerDao;
    private SurveyorDao surveyorDao;
    private AssignDao assignDao;

    public void assign(Filterables filterables, Sortables sortables,
                       Distributable distributable) {

        List<Customer> customers = this.customerDao.selectAll();    // (1)
        List<Surveyor> surveyors = this.surveyorDao.selectAll();    // (2)

        AssignBundle assignBundle = new AssignBundle(customers,     // (3)
                                                     surveyors);
        assignBundle.setFilterables(filterables);                   // (4)
        assignBundle.setSortables(sortables);                       // (5)
        assignBundle.setDistributable(distributable);               // (6)
        List<Assign> assigns = assignBundle.assign();               // (7)
        assignDao.insertAll(assigns);                               // (8)
    }
}
```

# 모듈

객체지향 설계 원칙을 적용하더라도, 하나의 패키지에 너무 많은 클래스를 나열해 두면 Customer, Surveyor, AssignRule 같은 개별 클래스 수준에서는 전체 시스템이 수행하는 더 높은 수준의 책임을 파악하기 어렵다.

**모듈(Module)** 을 활용하면 단순히 클래스를 나열하는 것이 아니라, 패키지 단위에서 시스템의 개략적인 책임과 흐름을 표현할 수 있다.

즉, 개별 클래스가 아닌 패키지 수준에서 배정 비즈니스 전체의 구조를 이해할 수 있게 된다.

<img width="385" height="315" alt="image" src="https://github.com/user-attachments/assets/15f5981b-e139-4c9b-949f-4da8aae7fc8d" />

분배 알고리듬의 성능을 개선하거나 다양한 알고리듬을 적용하기 위해 **배포 단위**로 모듈을 분리하는 방법도 고려할 수 있다.

예를 들어, Distributable 인터페이스는 **assign.jar** 에 위치시키고, 자주 변경되거나 추가되는 알고리듬 클래스들은 **distributor.jar** 로 분리할 수 있다.

이렇게 하면 알고리듬의 수정이나 추가가 다른 모듈(예: 배정 로직 전반)에 영향을 주지 않으면서도 유연하게 확장할 수 있는 구조를 유지할 수 있다.

<img width="510" height="224" alt="image" src="https://github.com/user-attachments/assets/20a72e3d-8167-4a65-8f26-283a1ebe8fda" />
