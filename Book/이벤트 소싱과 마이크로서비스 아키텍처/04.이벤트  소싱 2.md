**이벤트 소싱은 애그리게이트의 상태 변화를 기록할 수 있다**는 장점이 있지만, 다음과 같은 문제점들이 존재한다

- **성능 문제**: 이벤트 개수가 많아질수록 리플레이 시간이 증가한다
- **메모리 제약**: 시스템 메모리 한계로 인해 모든 이벤트를 한 번에 조회하는 데 제약이 있다
- **동시성 문제**: 같은 애그리게이트를 동시에 변경할 때 마지막 커밋이 이전 커밋을 덮어쓰는 문제가 발생한다

이번 장에서는 이벤트 소싱을 적용한 시스템을 구축하고 운영하면서 직면할 수 있는 대표적인 문제와 그 해결 방법에 대해 학습한다.

# 도메인 객체 라이프사이클

## 애그리게이트 생성

애그리게이트를 구성하는 엔티티와 값 객체는 모두 파라미터를 가지는 메서드를 제공하고, **상태가 변할 때 이벤트를 발생**시킨다. **애그리게이트 생성 역시 커맨드를 이용하며 도메인 이벤트를 발생시킨다.**

1. 커맨드와 이벤트 정의
    
    객체 생성을 위한 커맨드인 CreateCart 클래스와 이벤트인 CartCreated 클래스를 선언한다.
    
    ```java
    public class CreateCart {
        private String cartId;
    }
    ```
    
    ```java
    public class CartCreated extends Event {
        private String cartId;
    }
    ```
    
2. 애그리게이트  생성자 구현
    
    Cart 애그리게이트는 생성자 파라미터로 CreateCart 커맨드를 전달받아 카트를 생성하고 CartCreated 도메인 이벤트를 발행한다.
    
    ```java
    public class Cart {
        public Cart(CreateCart command) {
            this.apply(new CartCreated(command.getCartId()));
        }
        
        private void on(CartCreated event) {
            this.cartId = event.getCartId();
        }
    }
    ```
    
3. 애플리케이션 서비스에서 중복 검증
    
    Cart 애그리게이트를 생성하기 전에 cartId로 Cart가 이미 생성되었는지 확인해야 한다. 이 기능은 애플리케이션 서비스인 CartService의 책임이다.
    
    ```java
    public class CartService {
        private final CartStore cartStore;
        
        public String createCart(CreateCart command) {
            if (this.cartStore.exists(command.getCartId())) {
                throw new IllegalStateException("Cart already exists");
            }
            
            Cart cart = new Cart(command);
            this.cartStore.save(cart);
            
            return cart.getCartId();
        }
    }
    ```
    

## 애그리게이트 삭제

### **1. 삭제의 문제점**

카트 자체를 삭제한다고 가정하면, 카트 테이블의 레코드와 카트 이벤트 테이블에서 카트 ID를 외래키로 가지는 레코드 전체를 삭제해야 한다.

하지만 카트를 삭제하면 애그리게이트 변경 내역인 도메인 이벤트도 모두 사라지므로 **사용자의 행위를 추적할 수 없게 된다**. 데이터 보호 및 규정 요구사항을 충족하기 위해 애그리게이트를 삭제하지 않아도 되는 상황에서 도메인 이벤트를 삭제하면, 이벤트 소싱의 장점을 포기하는 것과 같다.

### 2. 소프트 삭제(Soft Delete)

데이터 관점에서 이벤트 소싱은 카트, 카트 이벤트 테이블의 레코드를 모두 DELETE 구문으로 직접 삭제하지 않고, **삭제되었다고 표기하는 소프트 삭제 방식으로 이력을 유지한다.**

1. **기본 구현 (문제 있는 방식)**
    
    markDelete 메서드를 애그리게이트에 추가한다. 삭제되었음을 의미하는 deleted 속성을 true로 변경하고 CartDeleted 이벤트를 발행한다.
    
    ```java
    public class Cart {
        private String cartId;
        private boolean deleted;
        
        public void markDelete() {
            this.deleted = true;
        }
    }
    ```
    
    - 이 방식의 문제점은 markDelete 메서드를 직접 사용하면 CartDeleted 이벤트를 발행할 수 없다.

1. **개선된 구현 (이벤트 기반 방식)**
    
    markDelete 메서드의 접근자를 private으로 변경하고, 삭제 규칙을 검사하는 delete 메서드를 추가한다. 삭제 조건을 검사하고, **삭제가 가능할 때 CartDeleted 이벤트를 생성한 후 이벤트 핸들러에서 markDelete 메서드를 호출**한다.
    
    ```java
    public class Cart {
        private String cartId;
        private boolean deleted;
        
        public void delete() {
            // 삭제 조건 검사
            if (this.deleted) {
                throw new IllegalStateException("Cart is already deleted");
            }
            
            this.apply(new CartDeleted(this.cartId));
        }
        
        private void on(CartDeleted event) {
            this.markDelete();
        }
        
        private void markDelete() {
            this.deleted = true;
        }
    }
    ```
    

# 동시성과 이벤트 충돌

## 갱신 분실 문제

담당자 A와 B가 고객사의 연락처를 동시에 수정해 같은 속성을 변경할 때, 나중에 처리된 요청이 이전 요청을 덮어쓰는 현상이 발생한다. 데이터베이스에서는 이 현상을 **갱신 분실**이라고 한다.

커맨드 핸들러를 동시에 호출해 발생한 이벤트가 같은 속성을 덮어쓰는 결과를 만들어내기도 하지만, 서로 다른 이벤트가 같은 속성을 덮어써서 일관성을 유지하지 못하기도 한다. 이와 같은 현상을 **이벤트 충돌**이라 한다.

<img width="687" height="219" alt="image" src="https://github.com/user-attachments/assets/35453c34-6872-4162-bf2c-058e5baef236" />

## 동시성 메커니즘

이벤트 간 충돌을 해결하려면 먼저 동시성 메커니즘을 이해해야 한다. 동시성 메커니즘은 **비관적 잠금**과 **낙관적 잠금**으로 구분한다.

### 1. 비관적 잠금 (Pessimistic Locking)

**비관적 잠금에서 트랜잭션은 많은 충돌이 발생한다고 가정하고 데이터베이스가 제공하는 잠금 기능**을 사용한다.

데이터베이스 잠금은 어떤 프로세스가 **데이터 변경을 목적으로 조회를 요청하고 변경을 완료할 때까지 다른 프로세스가 해당 데이터에 접근하지 못하게 한다**. 이 잠금은 안정적이지만 낙관적 잠금에 비해 비즈니스 동시성 환경에 적합하지 않다.

<img width="529" height="176" alt="image" src="https://github.com/user-attachments/assets/7ed95e85-bbf1-4a4a-83b3-a4ad7a6c3cc1" />

### 2. 낙관적 잠금 (Optimistic Locking)

낙관적 잠금에서 **트랜잭션은 충돌이 발생하지 않는다고 가정하고 데이터를 변경하는 시점에만 잠금을 사용**한다.

낙관적 잠금은 **버전 컬럼을 비교**해 데이터 조회 후 **업데이트를 요청하는 시점에 변경이 있었는지 확인**한다. 버전 컬럼의 값이 같으면 변경하고, 그렇지 않으면 예외를 던져 데이터의 일관성을 유지한다.

비관적 잠금에 비해 높은 성능을 제공해 **대부분의 비즈니스 서비스는 낙관적 잠금을 사용한다**.

<img width="562" height="185" alt="image" src="https://github.com/user-attachments/assets/c8a1b59d-ede9-4cae-8806-ead02eb38073" />

## 낙관적 잠금 구현

### 1. 버전 관리 흐름

낙관적 잠금을 사용하려면 변경 요청 시 사용자 인터페이스가 애그리게이트의 현재 버전 값을 알고 있어야 한다.

1. 사용자가 애그리게이트를 조회하면 백엔드는 현재 버전 값을 포함한 결과를 반환한다
2. 사용자가 애그리게이트 내용을 확인하고 변경을 요청하면, 사용자 인터페이스는 애그리게이트의 버전을 커맨드에 포함해 백엔드에 전달한다
3. 애플리케이션 서비스는 커맨드에 포함된 버전 값과 애그리게이트의 현재 버전 값을 비교한다
4. **값이 다르면 요청한 애그리게이트가 이미 다른 요청으로 상태가 변경되었음을 알리기 위해 예외를 발생시킨다**
5. 버전이 같으면 애그리게이트에 커맨드를 전달하고, **처리가 완료되면 버전 값을 증가시킨 후 데이터베이스에 저장한다.**

<img width="515" height="263" alt="image" src="https://github.com/user-attachments/assets/43e22cb8-2752-4012-b4da-68d5f26d1cdb" />

### 2. 직접 구현 방식

```java
public class CartService {
    public void addItem(String cartId, long version, String productNo, int quantity) {
        Cart foundCart = this.cartStore.load(cartId);
        
        if (version != foundCart.getVersion()) {
            throw new AlreadyChangedException();
        }
        
        foundCart.addItem(productNo, quantity);
        foundCart.setVersion(version + 1);
        this.cartStore.save(foundCart);
    }
}
```

예외를 받은 클라이언트는 HTTP 응답 코드 409 Conflict를 받아서 오류의 원인을 명확하게 파악할 수 있다. 하지만 이벤트 충돌을 감지하기 위해 애플리케이션 서비스에서 버전을 비교하면 많은 코드가 중복되고 유지보수를 어렵게 만든다.

### 3. JPA 낙관적 잠금 활용

이 문제는 JPA가 제공하는 낙관적 동시성 메커니즘을 활용해 쉽게 해결할 수 있다. `@Version` 어노테이션을 사용해 직접 구현한 버전 비교 로직을 JPA에 위임한다.

사용자 인터페이스가 애그리게이트의 **현재 버전을 알아야 하므로 애그리게이트에 버전 속성을 추가한다.**

```java
@Entity
@Table(name = "TB_CART")
public class CartJpo {
    @Id
    private String cartId;
    
    @Version
    private long version;
    
    public Cart toCart() {
        return new Cart(this.cartId, this.version);
    }
}
```

- `@Version`에 `long` 타입을 사용하면 version 값을 순환해 사용한다.
- 1부터 시작해 long의 MAX 값을 초과하면 부호 비트를 바꿔 long의 MIN 값으로 변경한다. 이후 다시 데이터 변경이 발생하면 값을 +1하면서 MAX까지 증가시킨다.

JPA가 제공하는 동시성 메커니즘을 사용하면 version을 비교하기 위해 직접 구현한 로직 대신 try-catch 구문으로 이벤트 충돌을 확인할 수 있다.

```java
public class CartService {
    public void addItem(AddItem command) {
        Cart foundCart = this.cartStore.load(command.getCartId());
        foundCart.setVersion(command.getVersion());
        foundCart.addItem(command);
        
        try {
            this.cartStore.save(foundCart);
        } catch (OptimisticLockException e) {
            throw new AlreadyChangedException();
        }
    }
}
```

이 방식을 통해 코드 중복을 제거하고 JPA의 표준 메커니즘을 활용해 이벤트 충돌을 효과적으로 관리할 수 있다.

# 재수화 성능과 스냅샷

재수화는 애그리게이트에서 발생한 도메인 이벤트가 많을수록 시간이 증가하기 때문에 성능에 직접적인 영향을 준다.

또한 재수화 동안 일시적으로 도메인 이벤트 인스턴스를 메모리에 올려야 하지만, 사용할 수 있는 메모리 사이즈에 한계가 있어 Out of Memory 예외가 발생할 수 있다.

## 스냅샷

재수화 성능을 향상시키면서 메모리를 효율적으로 사용하기 위한 방법이 스냅샷이다. **스냅샷은 발생한 이벤트들 중 특정 이벤트까지 리플레이한 결과를 별도로 저장해 놓은 일종의 메모이제이션이다.**

- 메모이제이션: 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거해 프로그램 실행 속도를 빠르게 하는 기술

재수화는 스냅샷이 있으면 **스냅샷에서 애그리게이트로 직접 재구성하고, 스냅샷을 생성한 시점 이후에 발생한 도메인 이벤트만 리플레이한다.**

<img width="523" height="232" alt="image" src="https://github.com/user-attachments/assets/0dbaa483-925a-4e2b-974b-efc58efe1a35" />

## 스냅샷 생성

이벤트 소싱도 하나의 도메인이다. Cart와 연관 관계를 갖는 값 객체로 Snapshot 클래스를 모델에 추가한다.

<img width="520" height="334" alt="image" src="https://github.com/user-attachments/assets/43071d5e-365b-4eed-b480-9e076b057ce3" />

### 1. Snapshot 클래스 정의

스냅샷 클래스는 특정 시점의 Cart 객체를 JSON으로 직렬화한 문자열과 스냅샷 생성 시간을 포함한다. 

생성 시간은 스냅샷 생성 이후에 발생한 도메인 이벤트를 조회하는 데 사용한다. 이 시간은 스냅샷을 생성한 시스템의 시간이 아닌, 스냅샷 생성에 사용한 마지막 도메인 이벤트가 발생한 시간임에 주의해야 한다.

```java
public class Snapshot {
    private String payload;
    private long time;
}
```

### 2. 데이터베이스 저장

이벤트와 마찬가지로 스냅샷도 데이터베이스에 저장한다. 속성 개수가 많거나 복잡한 애그리게이트 객체를 직렬화하면 JSON 문자열이 데이터베이스 컬럼의 최대 사이즈보다 길어질 수 있으므로, 스냅샷 페이로드 컬럼의 데이터 타입을 **CLOB**으로 선언한다.

```java
@Entity
@Table(name = "TB_CART")
public class CartJpo {
    @Id
    private String cartId;
    
    @Lob
    @Column(name = "SNAPSHOT_PAYLOAD")
    private String snapshot;
    
    private long snapshotTime;
}
```

### 3. 스냅샷 생성 메서드

Cart 애그리게이트에 현재 상태를 Snapshot 객체로 반환하는 snapshot 메서드를 추가한다.

```java
public class Cart {
    
    public Snapshot snapshot() {
        long time = this.events.get(this.events.size() - 1).time();
        return new Snapshot(JsonUtil.toJson(this), time);
    }
}
```

### 4. 책임 분리

커머스 도메인에서 스냅샷 생성은 기술에 종속된 요소이다. 따라서 Cart 애그리게이트는 스냅샷만 생성하고, 스냅샷을 저장하는 책임은 다른 구성요소에 부여해야 한다. 이 책임을 부여할 최종 후보는 CartStore이다.

```java
public class CartStore {
    public void save(Cart cart) {
        CartJpo cartJpo = new CartJpo(cart);
        cartJpo.setSnapshot(cart.snapshot());
        this.cartRepository.save(cartJpo);
        // 생략
    }
}
```

## 재수화 제외 이벤트

애그리게이트에서 발생한 모든 도메인 이벤트를 리플레이할 필요는 없다.

예를 들어 사용자가 로그인하면 Authenticated 이벤트가 발생하지만, 리플레이해서 얻을 수 있는 이득은 없다. 리플레이할 이벤트와 그렇지 않은 이벤트를 구분하면 **리플레이 대상이 아닌 이벤트가 많이 발생하는 애그리게이트에서 성능 향상**을 기대할 수 있다.

### 1. rehydration 속성 추가

리플레이 대상 이벤트를 구별하는 용도로 Event 추상 클래스에 rehydration 속성을 추가한다. 애그리게이트에서 발생하는 이벤트 중 리플레이에서 제외할 이벤트가 적으면, 생성자에서 기본값을 true로 설정해 재수화 대상으로 설정하고, 구체적인 도메인 이벤트 생성자에서 선택적으로 false를 할당한다.

```java
public abstract class Event {
    private String eventId;
    private long time;
    protected boolean rehydration;
    
    public Event() {
        this.eventId = UUID.randomUUID().toString();
        this.time = System.currentTimeMillis();
        this.rehydration = true;
    }
}
```

### 2. 재수화 제외 이벤트 설정

인증 도메인 이벤트를 재수화 대상에서 제외시키기 위해 생성자에서 rehydration 속성을 false로 할당한다.

```java
public class Authenticated extends Event {
    private String userId;
    private long time;
    
    public Authenticated(String userId) {
        super();
        this.userId = userId;
        this.rehydration = false;
    }
}
```

### 3. 리포지토리 조회 조건 추가

UserEventJpo를 조회하는 UserEventRepository에서 rehydration 컬럼의 값이 true인 레코드만 조회하게, find로 시작하는 오퍼레이션에 rehydration 파라미터를 추가하고, UserStore에서 호출할 때 파라미터로 true를 전달한다.

```java
List<UserEventJpo> findByUserIdAndRehydrationOrderByTimeAsc(String userId, boolean rehydration);
```

이를 통해 재수화 시 필요한 이벤트만 조회하여 성능을 최적화할 수 있다.

# 스냅샷 생성 정략

스냅샷을 언제 생성해야 한다는 원칙은 없지만, 주기적인 시간을 초과해 이벤트가 발생했을 때 스냅샷을 생성하는 것을 기본 전략으로 사용한다. 이벤트 발생 빈도가 높은 애그리게이트는 더 짧은 주기로 스냅샷을 생성할 수 있다.

다음 3가지 스냅샷 생성 전략 중에서 선택할 수 있다

- 주기적인 시간
- 매 N번째 이벤트
- 특정 도메인 이벤트가 발생했을 경우

## 주기적인 시간

스냅샷을 생성한 후 지정된 시간을 초과했을 때 새로운 스냅샷을 생성한다.

Cart 애그리게이트는 지정한 시간을 초과했는지 검사하기 위해 마지막 스냅샷을 생성한 시간을 알아야 한다. 저장해야 하는 도메인 이벤트 중 마지막 이벤트가 발생한 시간과 스냅샷 생성 시간을 비교해 지정한 시간을 초과했는지 검사한다.

```java
public class Cart {
    
    private Optional<Snapshot> snapshot;
    
    public void takeSnapshot() {
        long eventTime = this.events.get(this.events.size() - 1).time();
        
        // 스냅샷이 없으면 생성
        if (snapshot.isEmpty()) {
            this.snapshot = Optional.of(new Snapshot(JsonUtil.toJson(this), eventTime));
        }
        
        // 10분(600,000ms)을 초과하면 새 스냅샷 생성
        if (snapshot.isPresent() && eventTime - snapshot.get().getTime() > 600000) {
            this.snapshot = Optional.of(new Snapshot(JsonUtil.toJson(this), eventTime));
        }
    }
}
```

- 10분을 초과할 때마다 스냅샷을 생성한다.

## 매 N번째 이벤트

매 N번째 이벤트가 발생할 때 스냅샷을 생성한다. 모듈로 연산자를 사용한다.

모듈로 연산자를 사용하려면 애그리게이트에서 발생한 이벤트의 횟수를 기록해야 한다. 이전 예제에서 사용한 time 대신 일련번호를 사용하게 변경해야 한다.

Cart 애그리게이트 클래스에 sequence 속성을 추가한다. 이 속성은 load 메서드가 Cart 객체를 반환할 때 Cart에서 발생한 이벤트 횟수이다. CartStore.save() 메서드는 load() 후 커맨드를 처리해 이벤트가 발생한 횟수만큼 증가한 값을 사용한다.

### 1. 기본 구현

```java
public class Cart {
    private List<Event> events;
    private long sequence;
    
    private Optional<Snapshot> snapshot;
    
    public void takeSnapshot() {
        long eventTime = this.events.get(this.events.size() - 1).time();
        
        // 매 10번째 이벤트마다 스냅샷 생성
        if (sequence % 10 == 0) {
            this.snapshot = Optional.of(new Snapshot(JsonUtil.toJson(this), eventTime, this.sequence));
        }
    }
}
```

- 매 10번째 이벤트가 발생했을 때 스냅샷을 생성한다.

### 2. 문제점과 개선

커맨드와 이벤트가 반드시 일대일 관계가 아닐 수 있다. 한 커맨드가 2개 이상의 이벤트를 발생시키면 `%` 연산 결과가 0이 아닌 값이 계속될 수도 있고, 최악의 경우 이 전략은 영원히 스냅샷을 생성하지 못할 수도 있다.

어떤 상황에서도 스냅샷을 생성하려면 `%` 연산 결과가 0을 통과한 값인지 함께 검사해야 한다.

```java
public class Snapshot {
    
    private String payload;
    private long sequence;
    private long time;
    
    private long quotient;
    private long remainder;
    
    public Snapshot(String payload, long time, long sequence) {
        this.payload = payload;
        this.time = time;
        this.sequence = sequence;
        this.quotient = sequence / 10;
    }
    
    public boolean isExpired(long sequence) {
        return sequence % 10 == 0 && this.quotient != sequence / 10;
    }
}
```

Cart 애그리게이트는 Snapshot 객체가 제공하는 isExpired 메서드로 새로운 스냅샷을 생성할지 결정한다.

## 도메인 이벤트

설계 시 스냅샷을 생성할 이벤트를 결정한다. 앞서 살펴본 전략과 비교했을 때 비즈니스 케이스를 가장 잘 반영한다.

예를 들어 Order 애그리게이트는 주문부터 배송 중까지 스냅샷을 생성하지 않고, 배송 완료 이벤트가 발생했을 때 스냅샷을 생성한다. 대부분의 주문은 배송을 완료하면 더 이상 이벤트가 발생하지 않고, 반품/교환처럼 일부 주문에서만 이후 프로세스와 연관된 이벤트가 발생하기 때문이다.

<img width="562" height="284" alt="image" src="https://github.com/user-attachments/assets/3086923f-1b43-4ed7-9d39-d5eef8cd755e" />

이 전략도 마찬가지로 동일하게 하나의 커맨드에서 다수의 이벤트가 발생할 수 있어, events 목록 변수에 스냅샷을 생성해야 하는 도메인 이벤트를 포함하는지 검사해서 스냅샷 객체를 생성한다.

```java
public class Order {
    
    private List<Event> events;
    private Optional<Snapshot> snapshot;
    private long sequence;
    
    public void takeSnapshot() {
        long eventTime = this.events.get(this.events.size() - 1).time();
        
        if (hasSnapshotEvent()) {
            this.snapshot = Optional.of(new Snapshot(JsonUtil.toJson(this), eventTime, this.sequence));
        }
    }
    
    private boolean hasSnapshotEvent() {
        boolean result = false;
        
        for (Event event : events) {
            if (OrderDelivered.class.isAssignableFrom(event.getClass())) {
                result = true;
                break;
            }
        }
        
        return result;
    }
}
```

# 이벤트 소싱과 상수

시스템은 시간이 지나면서 변경이 필요한데, 상수 값이 변하기도 한다. 특히 이벤트 소싱을 적용한 애그리게이트에서 상수 값을 사용하면 각별한 주의가 필요하다.

## 문제 상황

커머스 도메인에서 구매 금액의 특정 비율을 포인트로 적립하는 규칙이 존재한다고 가정한다.

```java
public class Point {
    private String userId;
    
    private static final float ACCUMULATION_RATE = 0.01;
    private long value;
    
    public void increase(IncreaseByOrder increaseByOrder) {
        this.apply(new IncreasedByOrder(increaseByOrder.orderNo, increaseByOrder.total));
    }
    
    private void on(IncreasedByOrder increasedByOrder) {
        this.value += increasedByOrder.total * ACCUMULATION_RATE;
    }
}
```

적립 비율이 `1% → 5% → 7% → 1%`로 변경되었다고 가정해 보자. 해당 비율에 모두 구매 이력이 있는 고객의 포인트를 리플레이하면 예상한 포인트가 아닌 이해할 수 없는 결과를 반환한다.

이벤트 핸들러인 `on` 메서드에서 상수를 사용해 12월과 1월을 구분해 사용해야 하는데, 리플레이하는 시점의 상수 0.01을 사용하기 때문이다. 과거 이벤트가 발생했을 당시의 적립률이 아닌, 현재 코드에 정의된 적립률로 계산되어 신뢰할 수 없는 결과를 반환한다.

### 해결 방법 1: 조건문 사용 (권장하지 않음)

이 문제는 기간별로 적립 비율을 계산하도록 Point 클래스를 변경해서 해결할 수 있다. 조건문을 사용해서 적립률 상수를 다르게 적용한다.

하지만 기간이 길어질수록 훨씬 많은 조건문이 필요한데, 이 조건문의 복잡도를 계산하면 현실적으로 유지보수가 불가능하다.

### 해결 방법 2: 상수를 이벤트에 포함 (권장)

시간에 따라 변할 수 있는 상수가 있는 경우, 코드의 복잡성을 줄이기 위해 **도메인 이벤트에 해당 상수를 포함시키는 것을 고려**할 수 있다.

상수를 도메인 이벤트에 추가하면 이벤트 핸들러에서 **이벤트가 발생했을 당시의 적립률 상수**로 해당 주문의 적립금을 계산할 수 있다.

```java
public class Point {
    private static final float ACCUMULATION_RATE = 0.01;
    private long value;
    
    public void increase(IncreaseByOrder increaseByOrder) {
        // 이벤트 발생 시점의 적립률을 이벤트에 포함
        this.apply(new IncreasedByOrder(
            increaseByOrder.orderNo, 
            increaseByOrder.total,
            ACCUMULATION_RATE  // 현재 시점의 적립률
        ));
    }
    
    private void on(IncreasedByOrder increasedByOrder) {
        // 이벤트에 저장된 당시의 적립률 사용
        this.value += increasedByOrder.total * increasedByOrder.rate;
    }
}
```

- 리플레이 시 각 이벤트가 발생했을 당시의 적립률로 정확하게 계산된다
- 복잡한 조건문이 필요 없다
- 과거 시점의 비즈니스 규칙이 이벤트에 명시적으로 기록된다
- 적립률이 변경되어도 과거 데이터의 무결성이 보장된다

# 도메인 이벤트와 버전

사용 중인 도메인 이벤트에 속성을 추가하거나 삭제해야 하기도 한다. 새로운 도메인 이벤트 추가는 비교적 단순하지만, 속성을 추가하거나 삭제해야 하면 생각보다 많은 것을 고려해야 한다.

## 업캐스팅

일부 요구사항은 이벤트 소싱을 적용한 서비스에서 다양한 문제를 발생시킨다.

새로운 요구사항이 추가되었다고 가정해 보자

- 새로운 속성을 추가한다
- 더 이상 사용하지 않는 속성은 제거한다

이벤트 스토어에 기록한 **도메인 이벤트는 과거에 발생한 사건으로 불변이므로 원칙적으로 이벤트 내용을 수정할 수 없다.**

하지만 요구사항 변경은 피할 수 없고, 변경 요청은 이미 선언해 사용 중인 이벤트 클래스에 영향을 줄 수밖에 없다.

### 문제 상황

커머스 도메인에서 주문 취소 시 OrderCanceled 이벤트는 주문번호와 시간으로 구현되어 있는데, 마케팅 부서에서 분석 목적으로 사용할 취소 사유 추가를 요청한다.

OrderCanceledV2로 네이밍한 새 버전의 도메인 이벤트를 추가하면, 리플레이를 위해 주문 애그리게이트에 과거 버전의 이벤트를 처리하는 on(OrderCanceled) 외에 현재 버전의 이벤트를 처리하는 이벤트 핸들러 on(OrderCanceledV2) 메서드를 추가해야 한다.

하지만 계속된 변경 요청은 V2, V3, V4로 네이밍한 도메인 이벤트 타입을 추가하고, 버전 수만큼 on 메서드를 추가해야 한다. **이 설계는 오래된 더 이상 사용하지 않는 이벤트 핸들러를 삭제하지 못하고 계속 유지해야 한다. 계속 방치하는 것은 코드 가독성과 유지보수성에 도움이 되지 않는다.** 더 이상 사용하지 않는 이벤트 핸들러를 제거할 수 있는 방법이 필요하다.

## 업캐스터

이벤트 스토어에 기록한 변경 불가능한 과거 버전의 도메인 이벤트를 현재 버전으로 변환하는 것을 **업캐스팅**이라 하고, 과거 버전의 이벤트를 현재 버전의 이벤트로 변환하는 책임을 가진 클래스를 **업캐스터**라 한다.

업캐스터는 과거 이벤트를 변경하지 않고 현재 이벤트로 변환하는 단 한 가지 책임만 가진다.

이것은 비즈니스 규칙이라 자동화할 수 없고, 과거 버전과 현재 버전의 차이를 고려해 변환 코드를 직접 구현해야 한다.

<img width="614" height="182" alt="image" src="https://github.com/user-attachments/assets/d3fa8958-5712-4a80-8d9f-891895e13773" />

### 동작 원리

업캐스터는 이전 버전의 도메인 이벤트를 현재 버전으로 변환하므로, 주문 애그리게이트는 오래된 버전의 도메인 이벤트를 처리하면서 더 이상 사용하지 않는 이벤트 핸들러를 삭제할 수 있다. **일종의 mapper** 역할을 한다.

업캐스터는 관심사 분리 원칙에 따라 **도메인 이벤트의 변화를 수용하는 완충 공간**이다.

<img width="480" height="369" alt="image" src="https://github.com/user-attachments/assets/2b17e3f7-eca2-4802-b9fa-58c69c1a9c24" />

```java
public class OrderEventUpcaster {
    public static OrderCanceledV2 upcast(OrderCanceled event) {
        return new OrderCanceledV2(
            event.getOrderNo(), 
            event.getTime(),
            "upcasted."  // 기본 취소 사유
        );
    }
}
```

이것의 반대 케이스는 테이블의 컬럼을 삭제하는 것과 같다. 더 이상 사용하지 않는 속성을 삭제하는 경우에도 같은 방식으로 업캐스팅 코드를 변경할 수 있다.

업캐스터는 도메인 객체가 아닌 데이터와 관련된 기술적인 요소이다. **기술 요소가 도메인 이벤트를 자세히 알고 있어야 하는 의존성은 문제가 되지 않는다.**

### OrderStore에서의 활용

이벤트 스토어에서 애그리게이트의 `apply` 메서드를 호출하기 전에 이벤트 버전을 변환한다.

```java
@Repository
@Transactional
public class OrderStore {
    
    private final OrderRepository orderRepository;
    private final OrderEventRepository orderEventRepository;
    
    public Order load(String orderNo) {
        OrderJpo orderJpo = this.orderRepository.findById(orderNo);
        List<OrderEventJpo> eventJpos = this.orderEventRepository
            .findByOrderNoOrderByTimeAsc(orderNo);
        
        Order foundOrder = orderJpo.toOrder();
        List<Event> events = eventJpos.stream()
            .map(eventJpo -> eventJpo.toEvent())
            .collect(Collectors.toList());
            
        events.forEach(event -> {
            Event upcastedEvent = OrderEventUpcaster.upcast(event);
            foundOrder.apply(upcastedEvent);
        });
        
        return foundOrder;
    }
}
```

OrderStore가 애그리게이트를 조회하면 현재 사용하는 도메인 이벤트 버전인 경우에도 upcast 메서드를 호출하므로, OrderCanceledV3를 파라미터로 갖는 upcast 메서드를 추가로 오버로드해야 한다.

업캐스팅은 이전 또는 오래된 버전의 도메인 이벤트에서 새 버전의 도메인 이벤트로 변환하는 규칙이 존재할 때만 적용할 수 있다. 변환 규칙을 적용할 수 없으면 도메인 이벤트는 버전 변경이 아닌 **새로운 이벤트로 선언**해야 한다.

## 중간 이벤트

이전 업캐스터는 오래된 버전 이벤트인 `OrderCanceled`, `V2` 클래스를 직접 사용할 수 있는 장점이 있는 반면, 코드베이스에서 완전히 제거할 수 없다.

오래된 버전의 이벤트 클래스를 제거하기 위해 중립적인 포맷을 사용할 수 있다. 이벤트 스토어에 이벤트의 버전을 저장하고 업캐스팅할 수 있는지 확인하는 데 사용한다.

### IntermediateEvent 클래스

오래된 도메인 이벤트를 처리하기 위해 `IntermediateEvent` 클래스로 중립적인 포맷을 선언한다. 이 클래스는 도메인 이벤트의 타입명과 업캐스팅할 내용을 JSON 객체로 보관한다

```java
public class IntermediateEvent {
    
    private String id;
    private String typeName;
    private ObjectNode payload;
    private String revision;
    
    public Event toEvent() {
        Event result = null;
        
        try {
            Class clazz = Class.forName(this.typeName);
            result = (Event) JsonUtil.fromJson(JsonUtil.toJson(payload), clazz);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        
        return result;
    }
}
```

### 버전 관리

도메인 이벤트의 버전 속성을 Event 클래스에 추가한다. 모든 이벤트는 기본 버전으로 1을 가진다.

특정 버전에서 새로운 버전으로 한 번에 하나씩 업캐스팅하는 책임을 가진 인터페이스를 선언한다. 업캐스팅이 필요한지 확인하는 `canUpcast`, 실제 업캐스팅 로직을 구현하는 `cast` 오퍼레이션을 포함한다.

### Upcaster 클래스

Caster 인터페이스를 구현한 객체를 사용해 일련의 업캐스팅을 처리하는 Upcaster를 리팩토링한다.

initialize 메서드는 Caster 인터페이스를 구현한 객체의 목록을 초기화해 업캐스팅 환경을 구성한다.

```java
public abstract class Upcaster {
    
    private List<Caster> casters;
    
    public Upcaster() {
        this.casters = new ArrayList<>();
        this.initialize();
    }
    
    public abstract void initialize();
    public abstract boolean canUpcast(IntermediateEvent event);
    
    protected void addCaster(Caster caster) {
        this.casters.add(caster);
    }
    
    public IntermediateEvent upcast(IntermediateEvent intermediateEvent) {
        IntermediateEvent intermediate = intermediateEvent;
        
        for (Caster caster : casters) {
            intermediate = caster.cast(intermediate);
        }
        
        return intermediate;
    }
}
```

렇게 하면 오래된 버전의 도메인 이벤트 클래스를 코드베이스에서 제거할 수 있다. 업캐스팅은 수행하는 작업의 개수와 타입 그리고 복잡도에 따라 **성능에 부정적인 영향**이 있으므로 주의해야 한다

## 이벤트 마이그레이션

도메인 이벤트는 과거에 발생한 사건이고 불변이다. 업캐스팅 로직이 지나치게 복잡해서 성능에 큰 영향을 준다면, **전체 이벤트를 현재 버전으로 마이그레이션하는 전통적인 접근법**을 선택할 수 있다.

마이그레이션은 다음 방식으로 수행할 수 있다

- 데이터베이스에 직접 접근해 프로그래밍 방식으로 수정
- ETL 전용 도구 사용

### 마이그레이션 전략

이 전략은 두 가지 방식 중에서 선택할 수 있다

1. **보존 방식**: 구 버전 이벤트를 유지하면서 새로운 버전의 이벤트를 추가
2. **대체 방식**: 구 버전을 유지하지 않고 덮어쓰기

## 이벤트 버전과 스냅샷

도메인 이벤트의 버전이 변경되면 **스냅샷도 영향**을 받는다. 이미 생성한 스냅샷을 업캐스팅하는 것은 비즈니스 규칙에 따라 고려사항이 많아 복잡도가 급격하게 증가한다. 결과적으로 **스냅샷 자체를 업캐스팅하는 것은 불가능**하다.

따라서 **과거 발생한 전체 도메인 이벤트를 다시 리플레이해 새로운 스냅샷을 만드는 것이 현실적인 접근 방법**이다.

# 마이크로서비스 모듈

오래된 이벤트를 현재 버전으로 변환하는 Upcaster 객체는 store/upcast 패키지에 배치한다.

- 초기 단계: OrderEventUpcaster가 모든 이벤트의 버전을 캐스팅한다
- 분리 시점: 특정 이벤트의 버전이 너무 많아지면 OrderCanceledUpcaster처럼 특정 이벤트의 버전만 변환하는 전용 Caster로 분리할 수 있다

# 다건 처리(반복문)와 성능

반복문을 사용해 다수의 애그리게이트를 처리하는 로직은 애그리게이트 조회와 처리 시 성능 이슈가 발생한다.

## 병렬 처리

단일 스레드와 멀티 스레드를 사용했을 때 성능 차이를 활용할 수 있다.

<img width="595" height="273" alt="image" src="https://github.com/user-attachments/assets/808a2027-1798-4793-b44d-2c9a973feecf" />

설계 시 애그리게이트와 도메인 서비스의 특성을 잘 반영하면 병렬 처리를 사용해 성능을 개선할 수 있다.

성능 개선은 다음 영역으로 한정된다.

- 애그리게이트 생성, 변경, 삭제를 위한 유효성 검사
- 비즈니스 로직 처리

제외되는 영역은 다음과 같다.

- 애그리게이트를 이벤트 저장소에서 조회하는 시간
- 이벤트 저장소에 저장하는 시간

이 제약의 이유는 **대부분의 시스템에서 저장소와 관련된 행위를 단일 트랜잭션으로 처리**하기 때문이다.

```java
public class SalesStopPolicy {
    public boolean canStop(Product product) {
        boolean result = false;
        // 판매 중단 검사 로직
        return result;
    }
}

public class ProductService {
    private final ProductStore productStore;
    private final SalesPolicyStore salesPolicyStore;

    public void stopSales(List<String> productNos) {
        SalesStopPolicy policy = this.salesPolicyStore.retrieveStopPolicy();
        List<Product> products = this.productStore.load(productNos);
        
        // (1) 병렬 처리로 각 상품의 판매 중단 정책 검증
        List<CompletableFuture<Product>> stoppableProducts = products
            .stream()
            .map((product) -> {
                return CompletableFuture.supplyAsync(() -> {
                    product.stopSales(policy);
                    return product;
                });
            })
            .collect(Collectors.toList());

        // (2) 모든 비동기 작업 완료 대기
        CompletableFuture.allOf(stoppableProducts
            .toArray(new CompletableFuture[stoppableProducts.size()]))
            .join();
            
        // (3) 실제로 판매 중단된 상품만 필터링
        List<Product> stoppedProducts = stoppableProducts
            .stream()
            .map((future) -> future.join())
            .filter((product) -> product.getSalesState() == SalesState.Paused)
            .collect(Collectors.toList());

        // (4) 단일 트랜잭션으로 저장
        this.productStore.save(stoppedProducts);
    }
}
```

이 방식을 통해 비즈니스 로직 처리 부분은 병렬로 수행하되, 저장소 작업은 단일 트랜잭션으로 처리한다.

## 캐싱

시스템은 데이터를 조회하거나 요청을 처리하는 데 시간이 걸린다. 단순히 데이터 조회뿐만 아니라 원격 서비스를 호출하거나 복잡한 계산을 수행하기도 한다. 

호출 결과가 전혀 변경되지 않거나 주기적으로 정해진 시간에 변경된다면, **매번 데이터베이스에 질의하거나 원격 서비스를 호출하는 것은 낭비**이다. 동일 요청을 반복하는 대신 결과를 더 빨리 사용할 수 있게 메모리에 유지할 수 있다.

### 이벤트 소싱에서의 캐싱

이벤트 소싱에서 캐싱은 **리플레이 횟수를 감소**시킨다. 하지만 메모리 한계로 모든 애그리게이트를 메모리로 관리할 수 없으므로 효율적으로 사용해야 한다.

### LRU 알고리즘

다양한 캐싱 알고리즘이 있지만 **LRU를 주로 사용**한다. 캐시에 할당한 메모리 용량 내에서 새로운 데이터를 추가해야 하면 **가장 오랫동안 사용되지 않은 데이터를 삭제**한다. 캐시에 저장된 데이터는 마지막으로 접근한 시간을 포함해야 한다.

### Spring Cache 구현

캐시 알고리즘을 직접 구현할 수 있지만, 이미 검증된 라이브러리를 사용하는 것이 효율적이다.

```java
public class CartStore {
    
    @Cacheable(value = "carts")
    public Cart load(String identifier) {
        // 캐시에 없을 때만 실행
        // 애그리게이트 로드 로직
    }
    
    @CachePut(value = "carts")
    public void save(Cart cart) {
        // 저장 후 캐시 갱신
        // 애그리게이트 저장 로직
    }
}
```

이 외에 Redis를 활용할 수도 있다. Redis는 캐싱의 유효 시간을 지정할 수 있어 활용도가 훨씬 높다.

# 데이터 마이그레이션

새로운 시스템에 이벤트 소싱을 적용하는 경우 데이터 마이그레이션 이슈가 없지만, 기존 시스템을 이벤트 소싱으로 재구축하는 경우 데이터 마이그레이션을 반드시 고려해야 한다.

## 마이그레이션 전략

마지막 상태만 기록하는 기존 시스템의 데이터를 마이그레이션할 때는 LegacyMigrated와 같은 1회성 이벤트를 사용한다.

- **1:1 매핑 (단순한 경우)**
    - 하나의 테이블을 애그리게이트로 정확하게 매핑할 수 있다면 적은 노력으로 마이그레이션용 도메인 이벤트로 변환할 수 있다.
- **1:N 매핑 (테이블 분리)**
    - 하나의 테이블을 다수의 마이그레이션 이벤트로 분리하기도 한다.
    - 고객 테이블에 고객 정보와 개인 환경 설정이 함께 존재하고, 새로운 서비스에서 고객과 고객설정을 애그리게이트로 분리했다면 하나의 테이블에서 두 개의 마이그레이션 이벤트를 생성해야 한다.
- **N:1 매핑 (테이블 통합)**
    - 여러 테이블의 값들을 조합해 하나의 마이그레이션 이벤트로 통합하기도 한다.
    - 이는 기존 시스템이 성능 개선을 위해 데이터 중복을 허용하면서 테이블을 분리한 경우에 자주 볼 수 있다.

# 백업과 아카이빙

이벤트 소싱을 사용하면 많은 이벤트가 생성된다. 주기적인 아카이빙을 통해 스토리지를 효율적으로 활용할 수 있다.

백업과 아카이빙 모두 보관이라는 의미로 사용되지만, 필요할 때 바로 사용할 수 있어야 한다면 아카이빙을 선택해야 한다.

이벤트 스토어를 아카이빙하기 위해 실시간 복제를 지원하는 데이터베이스 사용을 고려할 수 있다.

# 이벤트 소싱과 추상화된 핵심

모든 애그리게이트에 이벤트 소싱을 적용하면서 코드를 중복시키면, 기능 추가나 개선이 필요할 때 모든 애그리게이트 클래스를 찾아 변경해야 한다. 따라서 기능 또는 구조를 일반화할 필요가 있다.

이벤트 소싱도 하나의 도메인이며, 라이브러리가 제공하는 클래스는 추상화된 핵심이라 할 수 있다.

이 라이브러리는 다음을 추상화한다.

- 이벤트 소싱을 적용하는 애그리게이트
- 커맨드
- 이벤트
- 이벤트 스토어 (데이터베이스 유형에 따라 확장 가능)

데이터베이스 유형에 따른 확장은 리스코프 치환 원칙(LSP)을 준수한다. 이벤트 발행과 수신, 수신한 이벤트에 반응하는 메커니즘 또한 추상화 대상이다.

## EventSourcedAggregate

이벤트 소싱을 적용하는 애그리게이트가 상속하는 추상 클래스이다. 이 클래스는 이벤트 소싱의 공통 기능을 제공한다

- 이벤트의 임시 저장
- 리플레이
- 스냅샷 생성

```java
public abstract class EventSourcedAggregate {
    private Optional<Snapshot> snapshot;
    private boolean deleted;
    
    public abstract String identifier();
    
    public void apply(Event event) {}
    public void apply(Event event, boolean isNew) {}
    public void takeSnapshot() {}
    public void markDelete() {}
}
```

## Command

비즈니스 애플리케이션에서는 갱신 분실(Lost Update)을 방지하기 위해 낙관적 잠금을 사용한다.

낙관적 잠금을 사용하려면 변경을 요청하는 애그리게이트의 현재 버전 값을 가지는 version 속성을 추가해야 한다.

```java
public abstract class Command {
    protected long version;
}
```

## AggregateStore

불변식을 유지하는 애그리게이트 단위의 읽기/쓰기를 제공하는 AggregateStore를 추가한다. 리포지터리는 사용하는 데이터베이스의 특성에 최적화할 수 있게 인터페이스로 선언한다.

**중요한거는 AggregateStore는 애그리게이트 단위의 트랜잭션을 보장해야 한다.**
