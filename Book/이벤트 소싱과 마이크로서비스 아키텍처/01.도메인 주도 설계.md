문제 영역을 관심사별로 분리하면 모델은 전체가 아닌 특정 영역이나 속성에 집중할 수 있어 불필요한 잡음을 훨씬 쉽게 제거할 수 있다. 또한 관심사로 범위를 한정하면 언어 선택이 단순해지고, 표현 방식에서도 더 많은 자유를 누릴 수 있다.

# 도메인 로직 패턴

---

## 1. 트랜잭션 스크립트 패턴

트랜잭션 스크립트는 클라이언트가 요청한 비즈니스 로직을 하나의 프로시저에서 처리하는 방식이다. 비즈니스 애플리케이션의 기능이 대부분 반복적인 CRUD 작업으로 구성된 경우에 적합하다.

대표적인 예는 서블릿(Servlet)과 JSP(Java Server Pages)이다.

- 서블릿은 자바를 이용해 웹 서비스를 구현하는 기술로, 클라이언트 요청을 처리하고 그 결과를 HTML로 반환한다. 다만, 웹 페이지를 구성하기 위해 많은 양의 코드를 작성해야 하는 단점이 있다.
- JSP 역시 하나의 프로시저에 비즈니스 로직을 담고, 직접 데이터베이스를 호출하거나 간단한 래퍼(wrapper)를 통해 데이터베이스를 다룬다.
    
    중복 기능을 줄이기 위해 하위 프로시저로 분리하기도 하지만 각 하위 프로시저 역시 독립적인 트랜잭션 스크립트를 가지는 구조다.
    

<img width="406" height="254" alt="image" src="https://github.com/user-attachments/assets/c99e1ddf-864c-4632-9210-f00414ce55a2" />

## 2. 테이블 모듈 패턴

테이블 모듈 패턴은 데이터베이스의 테이블(또는 뷰)을 단위로 비즈니스 로직을 처리하는 클래스를 분리하는 방식이다.

즉, 데이터베이스의 특정 테이블을 직접 다루는 모듈을 하나의 클래스에 대응시켜, 해당 테이블과 관련된 조회, 변경 작업을 책임지도록 한다.

이 패턴에서는 주로 JDBC의 ResultSet을 활용하며 경우에 따라 RecordSet이나 DataSet과 같은 구조체를 선언해 사용하기도 한다.

```java
public class Cart {

    public ResultSet retrieve(String cartId) {
        Class.forName("org.mariadb.jdbc.Driver");
        Connection connection = DriverManager.getConnection(url, id, password);

        try {
            Statement statement = connection.createStatement();
            ResultSet resultSet = statement
                .executeQuery("SELECT * FROM TB_CART WHERE CART_ID = ..");
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            connection.close();
        }
        return resultSet;
    }

}
```

위 예시처럼 Cart 클래스는 TB_CART 테이블에 대응하며 해당 테이블의 데이터를 조회하는 메서드를 포함한다.

이 방식으로 구현하면 각 테이블마다 전담 클래스를 두어 관련 로직을 명확하게 모듈화할 수 있다.

## 3. 서비스 레이어 패턴

애플리케이션은 종종 다른 시스템과의 통합을 필요로 한다. 이때 서비스 레이어(Service Layer)라 불리는 독립된 클래스에 시스템 간 통합과 전체 흐름을 조정하는 책임을 부여한다.

서비스 레이어는 단순히 비즈니스 로직만 담는 것이 아니라 로깅, 권한 체크와 같은 공통 기능을 구현하기에도 가장 적합한 계층이다. 이를 통해 개별 도메인 로직에 불필요한 책임이 들어가는 것을 막을 수 있다.

다만, 서비스 레이어는 여러 리소스를 아우르는 통합 작업과 그 결과에 따른 흐름 제어까지 맡게 되므로 책임이 쉽게 커지고 복잡도가 급격히 증가할 수 있다. 따라서 서비스 레이어는 명확한 역할 정의와 계층 분리가 필요하다.

<img width="344" height="330" alt="image" src="https://github.com/user-attachments/assets/b4afa400-8be0-48f3-b020-4026903b3441" />

## 4. 도메인 모델 패턴

단일 프로시저에 모든 비즈니스 로직을 구현하면 시간이 지남에 따라 코드가 지나치게 복잡해지고 유지보수가 어려워진다. 이를 피하기 위해 기능별로 프로시저를 분리하거나 서비스 레이어에 모든 로직을 몰아넣을 수 있지만, 이 역시 가독성 저하와 유지보수 난이도 상승을 초래한다.

도메인 모델 패턴은 이 문제를 해결하기 위해 데이터와 행위를 하나의 객체로 묶어 설계한다. 복잡한 규칙과 다양한 로직을 여러 객체에 분산시키고 객체 간 협력으로 비즈니스를 구현한다.

<img width="432" height="293" alt="image" src="https://github.com/user-attachments/assets/28d45743-9573-4b0f-878b-68bc0dfb12ef" />

- CartService는 도메인 객체에 명령을 전달하는 준비 흐름(조정자 역할)만 담당한다.
- 핵심 도메인 로직은 Cart, Item과 같은 도메인 객체 내부에 구현된다.
- 이렇게 하면 객체 지향 설계 원칙을 충실히 따르면서, 변화하는 요구사항에도 유연하게 대응할 수 있다.

```java
public class CartService {

    public void addItem(String cartId,
                        String productNo, String productName,
                        int quantity) {
        Cart foundCart = cartDao.select(cartId);
        foundCart.addItem(productNo, productName, quantity);
        cartDao.update(foundCart);
    }

}

//

public class Cart {

    private List<Item> items;

    public void addItem(String productNo, String productName,
                        int quantity) {
        if (this.items.size() >= 10) {
            throw new ItemLimitExceedException();
        }
        this.items.add(new Item(this.cartId,
                                productNo, productName,
                                quantity));
    }

}
```

테이블 모듈 패턴은 데이터베이스의 테이블 단위로 하나의 객체를 두고, 해당 객체가 테이블 관련 기능(조회, 변경)을 직접 처리한다.

반면 도메인 모델 패턴은 각 개별 엔티티(예: 카트)마다 인스턴스를 생성하고 객체가 스스로 규칙과 행위를 관리한다.

# 헥사고날 아키텍처

---

내/외부 환경 변화에 빠르게 대응하려면, 기업 경쟁력의 핵심인 비즈니스 로직이 특정 기술에 종속되지 않도록 주의해야 한다.

헥사고날 아키텍처는 이를 위해 **기술과 무관한 비즈니스 로직**과 **기술에 의존하는 구성 요소(어댑터)**를 명확히 분리하는 것을 강조한다.

어댑터는 다음과 같이 구분된다.

- **인바운드 어댑터** : 외부 요청을 받아들여 비즈니스 로직을 시작한다. (예: REST 컨트롤러, 메시지 큐 리스너)
- **아웃바운드 어댑터(Outbound Adapter)** : 실행된 비즈니스 로직이 데이터를 영구 저장소에 기록하거나, 다른 외부 시스템과 협력할 때 사용된다. (예: JPA Repository, 외부 API 클라이언트)

<img width="385" height="254" alt="image" src="https://github.com/user-attachments/assets/c8e97188-3168-46c9-99d5-023c77f066d5" />

헥사고날 아키텍처는 비즈니스 로직(도메인)을 외부 기술로부터 보호하고 기술 변화에 적응할 수 있도록 한다. 이는 도메인 주도 설계(DDD)가 강조하는 “기술에 의존하지 않는 도메인 객체”와 같은 맥락의 목표라 할 수 있다.

# 도메인 주도 설계

---

도메인 주도 설계(DDD)에서는 **관심사를 바운디드 컨텍스트(Bounded Context)**로 한정하고, 컨텍스트 간 관계를 명확히 정의하며, 각 컨텍스트 내부에서 효과적인 모델링을 실천하는 접근을 강조한다. 

## 유비쿼터스 언어

유비쿼터스 언어는 **도메인 전문가와 개발자가 공유하는 공통 언어**다. 비즈니스 전문가와의 대화에서 이 언어를 적극적으로 사용함으로써, 문제를 더 명확히 이해하고 모델을 코드에 반영할 수 있다.

전통적인 소프트웨어 개발은 **분석 → 설계 → 구현** 단계를 나누어 접근한다. 그러나 이 방식은 다음과 같은 문제를 낳는다

- 분석 언어와 구현 언어가 달라 개연성이 부족해진다.
- 시간이 지날수록 추적성이 떨어지고 일관성을 유지하기 어렵다.

이를 해결하기 위해 DDD는 분석 단계에서 정의된 언어를 코드베이스까지 관통하도록 사용할 것을 요구한다. 즉, 목표 시스템을 깊이 이해하면서 언어를 정교하게 다듬고 코드와 끊임없이 일치시켜야 한다.

<img width="521" height="153" alt="image" src="https://github.com/user-attachments/assets/90b15318-dc19-4ac0-bbb4-190fb42d78b3" />

유비쿼터스 언어는 사용하는 바운디드 컨텍스트에 따라 의미가 달라질 수 있다. 예를 들어, Order라는 용어는 주문 관리 컨텍스트에서는 상품을 담고 결제를 진행하는 객체일 수 있지만, 배송 컨텍스트에서는 배송 대상이 되는 단위로 해석될 수 있다.

## 빌딩 블록

헥사고날 아키텍처와 도메인 주도 설계에서 제안하는 빌딩 블록(Building Blocks) 간의 전형적인 호출 흐름은 다음과 같다.

<img width="525" height="261" alt="image" src="https://github.com/user-attachments/assets/26e4b4c3-c62e-41ee-b7aa-75948e065db7" />

1. 인바운드 어댑터가 외부 요청을 수신하고, 이를 애플리케이션 서비스로 전달한다.
2. 애플리케이션 서비스는 리포지터리(Repository)를 통해 데이터를 조회하고, 그 결과를 도메인 객체로 변환해 반환한다.
3. 애플리케이션 서비스는 변환된 도메인 객체에 요청을 위임하여 비즈니스 로직을 수행한다.
4. 도메인 객체가 로직을 처리하면, 애플리케이션 서비스는 다시 리포지터리를 사용해 결과를 데이터베이스에 저장한다.
5. 애플리케이션 서비스는 비즈니스 로직 수행 과정에서 필요할 경우 아웃바운드 어댑터를 호출해 부가 정보를 조회하거나, 처리 완료 사실을 외부 시스템에 전달한다.

## 엔티티

데이터 모델에서 엔티티(Entity)는 객체지향 언어의 클래스와 매핑될 수 있다. 그러나 클래스는 단순한 정보 보관소(Information Holder)를 넘어서는 더 큰 의미와 가치를 가진다.

객체지향 언어를 사용하면서 도메인 객체를 단순한 데이터 구조체처럼 설계한다면, 비즈니스 로직(행위)은 모두 서비스 레이어에서 처리하게 된다. 이렇게 되면 서비스 레이어에 비즈니스 로직이 집중되어 결합도는 높아지고 응집도는 낮아지는 문제가 발생한다.

엔티티의 핵심 특징은 다음과 같다.

- **식별성(Identity)** : 엔티티에서 가장 중요한 것은 식별성이다. 특정 클래스의 인스턴스를 시스템 내의 다른 인스턴스와 구분해야 한다면, 그 클래스는 엔티티로 설계해야 한다.
- **상태 변화(State Change)** : 객체지향 언어에서는 속성에 새로운 값을 할당할 때 상태가 변한다. 엔티티는 비즈니스적으로 고유한 존재이므로 상태는 계속 변할 수 있지만, **식별자(Identifier)는 변하지 않는다.**

## 값 객체

값 객체(Value Object)는 엔티티와 달리 식별자가 필요 없는 객체를 의미한다. 이들은 일반적으로 다른 객체를 수식하기 위해 존재하며, 엔티티뿐 아니라 또 다른 값 객체를 수식할 수도 있다.

<img width="258" height="207" alt="image" src="https://github.com/user-attachments/assets/d0196c02-9cc9-49bc-8224-4a57de3e7bac" />

```java
public class Product {
    private String id;
    private String no;
    private String name;

    private Volume volume;
}

//

public class Volume {
    private int width;   // 가로
    private int depth;   // 세로
    private int height;  // 높이

    public Volume(int width, int depth, int height) {
        this.width = width;
        this.depth = depth;
        this.height = height;
    }

    // getter only
}
```

예를 들어, Product 엔티티의 속성 중 부피(Volume)를 단순한 숫자 나열로 두는 대신, 별도의 값 객체로 모델링하면 도메인을 더 명확하게 표현할 수 있다.

위와 같이 부피(Volume)를 값 객체로 정의하면 Product는 단순한 데이터 나열이 아니라, 도메인의 개념을 더 풍부하게 표현할 수 있다.

특징은 다음과 같다.

- 값 객체는 특정 개체를 구분할 필요가 없으며, 단순히 속성을 통해 의미를 전달한다.
- 속성이 하나뿐인 경우에도, 도메인을 더 잘 설명할 수 있다면 값 객체로 선언하는 것이 바람직하다.
- **값 객체는 반드시 불변이어야 하며, 속성 값을 변경하려면 새로운 인스턴스를 생성해야 한다.**
- 값 객체는 불변이기 때문에 부피 변경은 새로운 Volume 인스턴스를 생성해 Product의 속성에 할당하는 것이 유일한 방법

값 객체는 불변이므로 속성을 직접 수정할 수 없다. 예를 들어, 부피를 변경하려면 새로운 Volume 인스턴스를 생성해 Product에 재할당해야 한다.

```java
public class VolumeTest {

    @Test
    public void testValidRatio() {
        Volume volume = new Volume(100, 150, 100);
    }

    @Test
    public void testInvalidRatio() {
        Assertions.assertThrows(InvalidVolumeRatioException.class,
            () -> { new Volume(100, 100, 100); });
    }

}
```

이처럼 값 객체는 자체적으로 비즈니스 규칙을 포함할 수 있어 중복 제거, 응집도 향상, 유지보수성 개선에 도움을 준다. 또한 다른 클래스에 의존하지 않고 단독으로 테스트할 수 있어 실용적인 개발에 유리하다.

원칙적으로 값 객체는 불변이지만, 다음과 같은 경우에는 Setter를 통한 변경을 허용하기도 한다.

- 값이 자주 변경되어 메모리 효율성이 떨어질 때
- 객체 생성/삭제 비용이 과도할 때
- 교체로 인해 클러스터링에 제약이 생기는 경우
- 공유 가능성이 낮거나 성능 최적화를 위한 기술적 이유가 있을 때

> 클러스터링 제약이란, 여러 서버가 연결된 분산 환경에서 값 객체를 불변으로 유지하면 작은 값 변경에도 새로운 객체를 만들어 전체 서버에 다시 전파해야 해서 통신, 동기화 비용이 늘어나는 문제이다. 그래서 값이 자주 바뀌는 경우에는 불변성을 깨고 Setter로 수정 가능하게 하여 성능 부담을 줄이기도 한다.
> 

## 서비스

서비스(Service)는 문맥에 따라 다양한 의미로 해석될 수 있다. 여기서는 도메인 주도 설계(DDD)에서 정의하는 서비스를 중심으로 설명한다.

에릭 에반스는 도메인 주도 설계에서 서비스를 다음 세 가지로 분류했다.

- 인프라스트럭처 서비스
- 애플리케이션 서비스
- 도메인 서비스

### 1. 인프라스트럭처 서비스

인프라스트럭처 서비스는 헥사고날 아키텍처에서 말하는 어댑터(Adapter)에 해당한다.

데이터베이스 접근, 네트워크 통신, 외부 시스템 API 호출, 메일 전송, 이벤트 발행 등과 같이 기술적인 문제를 다루는 역할을 맡는다. 이러한 서비스를 다른 서비스와 분리하지 못하면 기술 의존성이 도메인 모델까지 전파되어 온전한 도메인 모델을 유지하기 어렵다.

### 2. 애플리케이션 서비스

애플리케이션 서비스는 트랜잭션 관리와 비즈니스 유스케이스 흐름 조정이라는 두 가지 책임을 가진다. 이 두 책임을 올바르게 처리해야 레이어드 아키텍처에서 흔히 발생하는 도메인 로직이 잘못된 레이어에 구현되는 문제를 막을 수 있다.

1. **트랜잭션 관리**
    
    클라이언트 요청부터 응답까지를 하나의 트랜잭션으로 처리한다. 도메인 객체가 작업을 완료하지 못하면 예외를 던지거나 오류를 반환한다.
    
    로깅, 매트릭, 모니터링 관련 기능도 애플리케이션 서비스의 책임이다.
    
2. **유스케이스 조정**
    
    데이터를 조회해 도메인 객체를 재구성한다. 도메인 객체 간 협력을 통해 비즈니스 로직을 처리한다. 다른 서비스가 필요할 경우 인프라스트럭처 서비스를 통해 데이터를 획득해 도메인 객체에 전달한다.
    
    도메인 로직이 완료되면 최종 상태를 데이터베이스에 저장하고, 필요하다면 이벤트를 발행한다.
    

<img width="571" height="288" alt="image" src="https://github.com/user-attachments/assets/eb1c6063-3102-427b-9864-eacfa15a664e" />

### 3. 도메인 서비스

도메인 서비스는 엔티티나 값 객체에 담기 적합하지 않은 책임을 맡는다. 기술 의존성이 없는 순수한 POJO로 구현하는 것이 원칙이다.

반 버논은 도메인 서비스를 사용해야 할 세 가지 경우를 제시했다

1. **중요한 비즈니스 프로세스를 수행할 때**
    - 예: 계좌이체
    - 입금, 출금은 개별 계좌의 책임이지만, 두 계좌 간의 이체 자체는 별도의 도메인 서비스(TransferMoneyService)가 담당한다.
    - 이체가 성공하면 TransferMoney 엔티티를 반환한다.
    
    ```java
    public class ProductService {
    
        private final ProductAdapter productAdapter;
        private final EventPublishAdapter eventPublishAdapter;
    
        @Transactional
        public void createProduct(String name) {
            Product product = new Product(name);
            ProductCreationPolicy policy = new ProductCreationPolicy();
            if (!policy.isValid(product)) {
                throw new InvalidProductPolicyException();
            }
            this.productAdapter.insert(product);
            this.eventPublishAdapter.publish(new ProductCreated(product));
        }
    
    }
    
    //
    
    public class ProductCreationPolicy {
    
        public boolean isValid(Product product) {
            // 비즈니스 규칙
            return true;
        }
    }
    ```
    
2. **어떤 컴포지션에서 다른 컴포지션으로 도메인 객체를 변환할 때**
    
    특정 도메인 객체를 DTO로 변환하거나, DTO를 도메인 객체로 변환할 때 사용한다.
    
3. **하나 이상의 도메인 객체에서 요구하는 입력 값을 계산할 때**
    
    전화 상담원의 일일 총 통화시간을 계산할 때 처럼 도메인과 밀접하게 관련된 기능이면서 엔티티나 값 객체에 어울리지 않는 책임을 도메인 서비스에 부여한다.
    

위 세 가지 사례를 통해 도메인 서비스는 전달받은 파라미터만 사용해 비즈니스 로직을 수행하고, 그 결과를 반환하는 무상태라는 공통됭 특징을 가진다.

## 모듈

모듈은 설계자가 의도한 기준에 따라 도메인 객체를 분류한 것으로, 자바 언어에서는 패키지를 통해 구현한다.

모듈의 기준은 모델링 초기 단계에서 설계자의 통찰에 의해 결정되며, 시간이 지나 도메인을 더 깊이 이해하게 되면 그 기준을 더 명확하게 다듬거나 조정할 수 있다. 앞서 살펴본 빌딩 블록들은 entity와 service 패키지로 구분할 수 있다.

# 라이프사이클

---

## 애그리게이트

애그리게이트는 도메인 객체들의 연관 관계에서 불변식을 보장하는 단위이다. 즉, 관련된 엔티티와 값 객체들을 하나의 단위로 묶어 관리하며, 그 중심에는 항상 애그리게이트 루트(Aggregate Root) 라는 대표 엔티티가 존재한다.

애그리게이트 안에는 여러 개의 엔티티와 값 객체가 포함될 수 있다. 루트를 제외한 엔티티들은 애그리게이트 내부에서만 유효한 식별자를 가진다.

예를 들어 Cart 애그리게이트에 포함된 Item은 각 장바구니 내부에서는 고유해야 하지만, 다른 장바구니에 포함된 Item과 식별자가 중복될 수도 있다. 이는 불변식이 애그리게이트 단위로만 보장되기 때문이다.

<img width="778" height="223" alt="image" src="https://github.com/user-attachments/assets/bcba5a39-ca83-4a63-a073-69b13d46edd9" />

애그리게이트의 특징은 다음과 같다.

- 애그리게이트 외부에서는 루트를 통해서만 상태를 변경할 수 있다. 이는 내부 객체들의 무분별한 접근을 막고 불변식을 보장한다.
- 기능 실행은 루트의 메소드에서 시작해야 하며, 실행이 끝난 시점에 구성 객체들 간의 불변식이 반드시 유지되어야 한다.
- 경계 설정은 작게 잡는 것이 중요하다. 비즈니스 케이스를 잘못 해석하거나 바운디드 컨텍스트를 넓게 정의하면 불필요하게 거대한 애그리게이트가 만들어질 수 있다.

```java
public class Cart {

    private String cartId;
    private List<Item> items;

    public Cart(String cartId) {
        this.cartId = cartId;
        this.items = new ArrayList<>();
    }

    public void addItem(Product product, int quantity) {
        Item newItem = new Item(product, quantity);
        this.items.add(newItem);
    }

    public void removeItem(String productNo) {
        Item foundItem = this.findItem(productNo);
        this.items.remove(foundItem);
    }

    public void changeQuantity(String productNo, int quantity) {
        Optional<Item> foundItem = this.findItem(productNo);
        if (foundItem.isEmpty()) {
            return;
        }
        foundItem.get().changeQuantity(quantity);
    }

    private Optional<Item> findItem(String productNo) {
        return this.items.stream()
                .filter((item) -> {
                    return productNo.equals(item.getItemId());
                })
                .findFirst();
    }

    public boolean isEmpty() {
        return this.items.isEmpty();
    }
}
```

- 위 예시에서 Cart는 애그리게이트 루트이며, Item은 내부 값 객체이다. 상품 추가, 삭제, 수량 변경 같은 기능은 반드시 Cart를 통해서만 수행된다.

```java
public class CartService {
    private ProductDao productDao;
    private CartDao cartDao;

    public void addItem(String cartId, String productNo, int quantity) {
        Cart foundCart = this.cartDao.retrieve(cartId);
        Product product = this.productDao.retrieve(productNo);

        foundCart.addItem(product, quantity);
        this.cartDao.update(foundCart);
    }

    public void removeItem(String cartId, String productNo) {
        Cart foundCart = this.cartDao.retrieve(cartId);
        foundCart.removeItem(productNo);
        this.cartDao.update(foundCart);
    }

    public void changeQuantity(String cartId, String productNo, int quantity) {
        Cart foundCart = this.cartDao.retrieve(cartId);
        foundCart.changeQuantity(productNo, quantity);
        this.cartDao.update(foundCart);
    }
}
```

- CartService는 비즈니스 흐름을 조정하는 애플리케이션 서비스이다. 직접 비즈니스 규칙을 담기보다는, 애그리게이트(Cart)가 제공하는 기능을 호출하는 역할을 한다.
- 여기서 CartService는 DB 접근이나 외부 시스템 연동 같은 작업을 조율하고, 실제 규칙은 Cart가 책임진다.
이렇게 역할을 분리함으로써 애그리게이트의 불변식을 보장하면서도 애플리케이션 전체 구조가 명확해진다.

## 애그리게이트와 단위 테스트

비즈니스 로직을 애그리게이트 내부에 두면, 해당 로직을 처리하는 협력 대상이 기술에 중립적인 POJO 클래스로 한정된다.

POJO(Plain Old Java Object)를 활용하면 프레임워크나 실행 환경(Spring 등)에 종속되지 않으므로 자유로운 단위 테스트가 가능하다는 장점이 있다.

예를 들어 Cart 애그리게이트를 단위 테스트하는 경우는 다음과 같다.

```java
public class CartTest {

    String productNo;
    Product product;
    Cart cart;

    @BeforeEach
    public void beforeEach() {
        Product product = new Product(productNo, 680000, "iPad mini");
        Cart cart = new Cart("1234");
    }

    @Test
    public void testAddItem() {
        cart.addItem(product, 2);
        Assert.assertEquals(1360000, cart.getTotal());
    }

    @Test
    public void testChangeQuantity() {
        cart.addItem(product, 2);
        cart.changeQuantity(productNo, 1);
        Assert.assertEquals(680000, cart.getTotal());
    }

    @Test
    public void testRemoveItem() {
        cart.removeItem(productNo);
        Assert.assertTrue(cart.isEmpty());
    }
}
```

- 위 테스트는 Spring Context 실행 없이도 수행되며, 애그리게이트의 핵심 로직만 검증할 수 있다.

## 애그리게이트 설계 규칙

애그리게이트를 올바르게 설계하기 위해 따라야 할 몇 가지 규칙이 있다.

1. **비즈니스 불변식을 애그리게이트로 한정**
    - 불변식은 애그리게이트의 기능을 호출하고 나서, 엔티티와 값 객체가 반드시 만족해야 하는 조건을 의미한다.
    - 불변식은 다른 애그리게이트와는 독립적으로 유지되며, 데이터베이스에 저장되는 단위이기도 하다.
    - 따라서 불변식의 범위를 트랜잭션 단위 또는 일관성 범위라고도 부른다
2. **작은 애그리게이트로 설계**
    - 애그리게이트는 가능한 작게 설계해야 한다.
    - 예를 들어, Item을 Cart 내부 엔티티로 두는 대신 독립된 애그리게이트로 분리할 수도 있다. Item을 별도의 애그리게이트로 설계하면, productNo로 Item을 조회 후 가격을 변경할 수 있고, 이 과정은 Cart의 상태와 직접적으로 연결되지 않는다.즉, Cart와 Item이 각자 독립적인 불변식 범위를 가지게 된다.
    - 반대로 Cart와 Item을 하나의 애그리게이트로 묶으면, Item의 판매 가격 변경 로직이 Cart에도 영향을 줄 수 있어 불필요하게 경계가 넓어진다.
    
    <img width="756" height="198" alt="image" src="https://github.com/user-attachments/assets/0207096b-63cf-4db8-8c45-989e7a493df7" />
    
3. **다른 애그리게이트는 식별자로 참조**
    - Cart와 Item을 독립적인 애그리게이트로 설계하면 Item이 어느 Cart에 포함되는지 알 수 있는 참조값이 필요하다.
    - 가장 좋은 방법은 CartId로 네이밍한 식별자 타입을 선언하는 것이다.
    
    <img width="761" height="346" alt="image" src="https://github.com/user-attachments/assets/ca0c1a64-e427-4964-9063-52b969a17c97" />

    
    ```java
    public class Item {
        private String cartId;
    }
    
    //
    
    public class Item {
    
        private CartId cartId;
    
        public static class CartId {
            private String value;
        }
    }
    ```
    
    - 이렇게 하면 애그리게이트 간 결합도가 낮아지고, 독립성이 유지된다.
4. **애그리게이트 간 변화는 결과적 일관성을 이용**
    - 예를 들어, Item의 수량이나 가격이 변경되면 Cart의 총 금액(total)도 다시 계산해야 한다.
    - 만약 Cart와 Item이 독립 애그리게이트라면, Item은 수량 변경 이벤트를 발행하고, Cart가 이 이벤트를 구독해 total을 갱신하는 방식으로 동작할 수 있다.
    - 이처럼 이벤트를 활용한 결과적 일관성(Eventual Consistency)은 전체 시스템 차원의 동기화를 강제하지 않고, 애그리게이트 단위로만 비즈니스 일관성을 유지하게 해준다.
    - 결과적으로 애플리케이션 서비스는 훨씬 단순해지고, 복잡한 동기 로직을 줄일 수 있다.

<img width="472" height="243" alt="image" src="https://github.com/user-attachments/assets/e9ea944f-3597-4a07-8039-c83a394e3ce6" />

## 팩토리

애그리게이트를 생성하는 과정이 복잡하거나 내부 구조를 지나치게 노출해야 하는 경우에는 팩토리를 사용해 생성 과정을 캡슐화한다.

도메인 객체의 생명주기를 보면 생성은 한 번뿐이지만 그 이후 객체의 상태는 계속 변한다. 즉, 객체의 생성 과정과 생성 이후의 행위는 별개로 볼 수 있다. 따라서 복잡한 생성 로직을 도메인 객체에서 분리하면, 도메인을 이해하고 유지보수하기 훨씬 쉬워진다.

팩토리는 여러 곳에 둘 수 있지만, 주로 애그리게이트 루트, 팩토리 패턴을 적용한 전용 클래스에 두는 것이 적절하다.

### 애그리게이트 루트

커머스 도메인에서 Cart와 Item은 has-a 관계이므로, Item 생성 책임을 Cart가 가질 수 있다. 특히 Item을 생성할 때 필요한 속성인 cartId는 Cart가 소유하고 있기 때문에, Cart가 Item 생성의 주체가 되는 것이 자연스럽다.

```java
public class Cart {

    private String cartId;
    private List<Item> items;

    public Cart(String userId) {
        this.cartId = userId;
    }

    public void addItem(String productNo, String productName,
                        int price, int quantity) {
        Item item = new Item(this.cartId, productNo, productName, price, quantity);
        this.items.add(item);
    }
}
```

- 카트에 담은 Item을 값 객체로 설계했을 때의 팩토리 구현이다.

```java
public class Cart {

    public Item addItem(String productNo, String productName,
                        int price, int quantity) {
        return new Item(this.cartId, productNo, productName, price, quantity);
    }
}
```

- 엔티티로 설계하면 addItem 메소드는 생성한 Item 클래스의 인스턴스를 반환해야 한다.

### 전용 클래스

생성 로직이 복잡할 경우, 전용 팩토리 클래스를 두는 편이 더 적합하다. 예를 들어, Cart를 생성할 때 고객의 등급에 따라 총 금액 제한(limit)을 다르게 설정해야 한다고 하자.

이 경우,

1. UserDao를 통해 고객 정보를 조회
2. LimitDao를 통해 고객 등급에 맞는 제한 금액을 조회
3. 제한 금액을 Cart 생성자의 파라미터로 전달

하는 과정이 필요하다. 이 로직을 CartFactory라는 전용 클래스에서 담당하게 만들면 도메인 모델이 훨씬 깔끔해진다.

```java
public class CartFactory {

    private UserDao userDao;
    private LimitDao limitDao;

    public Cart createCart(String userId) {
        User foundUser = this.userDao.select(userId);              // (1)
        Limit foundLimit = this.limitDao
                                .select(foundUser.getGrade());    // (2)
        return new Cart(userId, foundLimit);                      // (3)
    }
}
```

## 리포지터리

도메인 객체를 단순히 인포메이션 홀더(Information Holder) 로 취급하면 설계가 객체 간 협력보다는 데이터 조회 쿼리나 그 결과 값을 변경하는 코드 중심으로 흘러가기 쉽다. 이 경우 비즈니스 규칙이 애플리케이션 서비스나 여러 계층에 분산되어 오류 가능성이 높아진다.

리포지터리는 이런 문제를 해결하기 위해 존재한다.

- JPA, MyBatis 같은 기술 세부사항을 감춘 채 애그리게이트 단위로 저장, 조회 기능을 제공한다.
- 클라이언트는 쿼리를 어떻게 작성하는지 신경 쓰지 않고, 리포지터리의 메소드를 통해 도메인 모델만 다루면 된다.

특히 Cart 애그리게이트에서 Item을 엔티티로 설계했을 때, 리포지터리를 거치지 않고 Item에 직접 접근하면 Cart-Item 사이의 비즈니스 규칙이 무시될 수 있다. 따라서 리포지터리는 반드시 애그리게이트 단위로 기능을 제공해야 한다.

```java
public class CartRepository {

    public void create(Cart cart) {
        // Cart - Items - Product의 연관관계를 한번에 저장한다.
    }

    public void retrieve(String cartId) {
        // Cart - Items - Product의 연관관계를 한번에 조회해 반환한다.
    }

    public void update(Cart cart) {
        // Cart - Items - Product의 연관관계를 한번에 변경한다.
    }

    public void delete(String cartId) {
        // Cart에 포함된 Items, Product도 함께 삭제한다.
    }
}
```

- 리포지터리의 메소드는 항상 애그리게이트 단위로 제공되어야 하며, 각 연산은 하나의 트랜잭션으로 처리해야 한다.

리포지터리를 어떻게 구현하느냐에 따라 데이터베이스 설계 방식도 달라진다. 크게 세 가지 방식이 있다.

### 단일 테이블 접근법

- Cart–Items–Product 관계를 하나의 테이블에 저장한다.
- 관계형 DB에서는 Item을 기준으로 Cart, Product 데이터를 중복 저장할 수 있다.
- 만약 Item을 값 객체로 설계했다면, Cart 객체 전체를 JSON 직렬화 문자열로 컬럼에 매핑하는 방법도 가능하다.

<img width="484" height="152" alt="image" src="https://github.com/user-attachments/assets/685594d1-7a90-44cf-8510-3f5a9c8a2c1a" />

### 다중 테이블 접근법

- 가장 일반적인 방법으로, TB_CART와 TB_ITEM을 테이블 분리한다.
- TB_ITEM은 자신이 속한 Cart를 식별하기 위해 CART_ID 외래키를 가진다.
- 정규화된 구조로 데이터 중복이 줄고 유지보수성이 높다.

<img width="488" height="153" alt="image" src="https://github.com/user-attachments/assets/2d059b72-ba7e-44d2-907f-160e79c19b2e" />

### 하이브리드 테이블 접근법

- 단일/다중 테이블 장점을 결합한 방식이다.
- TB_CART와 TB_ITEM을 테이블로 분리하면서, Item이 소유한 값 객체 Product를 JSON 직렬화하여 저장한다.
- 이렇게 하면 정규화의 장점은 살리면서, 일부 복잡한 객체 매핑을 단순화할 수 있다.

기술적으로 리포지터리는 애그리게이트를 조회할 때 새로운 인스턴스를 생성하므로 팩토리처럼 보일 수 있다. 하지만 역할은 분명히 다르다.

- 팩토리: 애그리게이트의 최초 생성을 담당
- 리포지터리: 이미 존재하는 애그리게이트를 재구성(복원) 하는 역할

따라서 두 개념은 구분되어야 하며, 각자의 책임을 명확히 해야 한다.

# 추상화된 핵심

---

에릭 에반스는 모델의 가장 근본적인 개념을 식별해 별도의 클래스, 추상 클래스, 인터페이스로 추출할 것을 제안한다. 즉, 구체적인 개념에 얽매이지 않고 도메인의 본질적 역할을 드러내도록 설계해야 한다는 것이다.

## 항만과 크레인 사례

항만에서 크레인의 주요 책임은 단순하다. 컨테이너를 이동시키는 것이다. 크레인의 주요 책임은 컨테이너를 이동시키는 것이고, 핵심 시나리오는 다음과 같다.

1. 선박에서 차량으로 직접 이동
2. 선박에서 야적장의 특정 위치로 이동
3. 야적장의 특정 위치에서 야적장의 다른 위치로 이동
4. 야적장의 특정 위치에서 차량으로 이동

여기서 등장하는 엔티티는 다음과 같다.

- 컨테이너 : 이동 대상
- 선박, 야적장, 차량 : 컨테이너가 위치할 수 있는 장소
- 크레인 : 컨테이너를 실제로 이동시키는 주체

<img width="563" height="163" alt="image" src="https://github.com/user-attachments/assets/bc8aaa54-faff-4ad5-a4c7-c334a8d8a723" />

처음에는 컨테이너 이동 기능을 애플리케이션 서비스로 정의하면, 출발지와 도착지에 따라 다양한 moveContainer() 오퍼레이션이 필요하다.

```java
public interface MovingService {

    void moveContainer(Ship ship, Yard yard,
                       Container container);

    void moveContainer(Yard fromYard, Yard toYard,
                       Container container);

    void moveContainer(Yard yard, Vehicle vehicle,
                       Container container);

    void moveContainer(Ship ship, Vehicle vehicle,
                       Container container);
}
```

- 이 케이스가 늘어날수록 메소드 오버로딩이 불가피하다. 파라미터 설계를 고민하는 시간이 증가하고, 도메인 모델이 복잡해진다.

이럴 때는 도메인을 더 근본적으로 바라봐야 한다. 선박, 차량, 야적장은 모두 컨테이너가 위치할 수 있는 장소(Location)라는 공통점을 가진다. 따라서 세 가지 개념을 하나의 추상화된 개념 Location으로 일반화할 수 있다.

이렇게 하면 도메인을 더 단순하고 직관적으로 표현할 수 있다.

<img width="524" height="136" alt="image" src="https://github.com/user-attachments/assets/c7a2a215-1a08-426d-b365-5fd950cd81c7" />

```java
public interface MovingService {

    void move(Container container, Location from, Location to);

}
```

- 오퍼레이션은 단 하나의 move()로 충분하다.
- 도메인 모델이 단순해지고, 유비쿼터스 언어(위치에서 위치로 컨테이너 이동)와도 일치한다.
- 구체적인 장소는 Location의 하위 타입으로 표현할 수 있다.
