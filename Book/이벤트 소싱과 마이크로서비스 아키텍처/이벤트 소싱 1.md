커머스 도메인에서 고객은 카트에 상품을 추가하거나, 수량과 옵션을 변경한다. 

이 과정에서 고객이 마지막 주문 전까지 특정 상품을 반복적으로 추가하고 삭제했다면, 이는 해당 상품의 구매를 고민 중이라는 신호로 해석할 수 있다. 이러한 데이터를 기반으로 담당자는 고객에게 유사한 상품을 추천하거나, 할인 쿠폰을 제공해 구매를 유도할 수 있다.

이처럼 데이터의 상태 변화 과정을 세밀하게 기록할 수 있다면, 단순한 데이터 저장을 넘어 데이터의 활용 가치가 훨씬 높아질 수 있다.

이 장에서는 **데이터를 단순히 최종 상태로만 관리하는 것이 아니라, 상태가 어떻게 변화했는지 전 과정을 기록하는 방식, 즉 이벤트 소싱(Event Sourcing) 의 원리를 살펴보고 이를 구현하는 방법**을 다룬다.

# 부서 이동

기업용 애플리케이션에서는 일반적으로 직원(Employee) 과 소속 부서(Department) 를 관리한다.

예를 들어, 직원 테이블에 John Doe 라는 직원이 있다고 하자. 시간이 지나 인사 발령으로 John Doe가 다른 부서로 이동하면, 시스템은 데이터베이스에서 UPDATE 문을 실행해 DEPT_NO 값을 변경한다.

이 방식은 단순하고 효율적이다. 하지만 인사 담당자가 나중에 “John Doe가 2년 전에는 어느 부서에 있었지?”라고 물어보면 시스템은 이전 기록을 알 수 없다. **왜냐하면 UPDATE 문으로 변경된 후에는 이전 부서 정보가 덮어쓰기 되었기 때문이다.**

즉, **직원의 부서 이동처럼 시간이 지남에 따라 변하는 데이터의 중간 상태를 알 수 없다는 한계**가 있다. 마지막 상태만을 저장하는 시스템 구조에서는 변경 이력이나 과거 상태를 추적할 수 없기 때문이다.

이러한 문제로 인해 인사 담당자는 다음과 같은 새로운 요구사항을 제시한다.

> 직원의 부서 이동 이력 전체와, 각 시점에서 맡았던 역할까지 확인할 수 있도록 해주세요.
> 

이 요구사항을 만족하려면 단순히 데이터를 수정(UPDATE)하는 방식이 아니라, **데이터의 모든 상태 변화를 기록으로 남기는 구조, 즉 이벤트 소싱(Event Sourcing) 이 필요하다.**

# 감사와 이력

대부분의 시스템은 감사 기능을 통해 **무엇이, 언제, 어떻게 변경되었는지**를 상세히 기록한다. 이를 위해 보통 **이전 상태를 별도로 저장해 두고**, 필요할 때 **현재 상태와 비교**하는 방식을 사용한다. 

이 절에서는 데이터 변경 이력을 관리하는 세 가지 대표적인 방법을 살펴본다.

## 1. 단일 테이블과 시퀀스

첫 번째 방법은 **단일 테이블 내에서 일련번호(Sequence) 를 활용**하는 방식이다. 즉, 직원 테이블의 기본 식별자인 EMP_NO 외에 일련번호 컬럼(SEQ) 을 추가하여,

데이터가 변경될 때 기존 레코드를 유지한 채 일련번호를 증가시켜 새로운 레코드를 추가한다.

| **EMP_NO** | **SEQ** | **EMP_NM** | **DEPT_NO** | **INS_ID** | **INS_DT** | **UP_ID** | **UP_DT** | **DEL_ID** | **DEL_DT** |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1234 | 1 | John Doe | 0001 | 9582 | 18-01-02 09:23 |  |  |  |  |
| 2345 | 1 | Jane Doe | 0002 | 9582 | 22-01-02 09:23 |  |  |  |  |
| 3456 | 1 | Michle John | 0002 | 9582 | 22-01-02 09:23 |  |  |  |  |
| 1234 | 2 | John Doe | 0004 | 8987 | 21-01-02 09:23 | 9881 | 22-01-23 17:34 |  |  |
| 1234 | 3 | John Doe | 0004 | 8987 | 21-01-02 09:23 | 9881 | 22-01-23 17:34 | 8987 | 22-03-17 17:00 |

EMP_NO와 SEQ를 복합 유일키(Unique Key) 로 설정하면, 동일한 EMP_NO에 중복된 시퀀스가 저장되는 것을 방지할 수 있다. 

이 구조에서 가장 큰 SEQ 값을 가진 레코드가 최신 데이터이다. 따라서 최종 데이터를 조회하려면 GROUP BY와 MAX(SEQ)를 사용하거나, SEQ를 내림차순 정렬하여 LIMIT 1로 조회할 수 있다.

하지만 이 방식은 **상태 테이블과 이력 테이블을 분리한 구조에 비해 SQL이 다소 복잡**하며, 새로운 데이터를 추가할 때마다 **현재의 최대 SEQ를 조회하고 증가시키는 로직**도 필요하다.

## 2. 상태 테이블과 이력 테이블 분리

두 번째 방법은 **현재 상태 테이블**과 **이력 테이블**을 분리하는 방식이다.

이력 테이블은 현재 테이블과 동일한 컬럼 구조를 가지며, 상태 변화 순서를 구별하기 위해 **일련번호(Sequence)** 컬럼을 추가한다.

이 방식에서는 현재 데이터를 변경하기 전, 현재 레코드를 이력 테이블에 복사한 뒤 새로운 값을 현재 테이블에 반영한다. 즉, “현재 상태 → 이력 테이블 복사 → 변경 반영”의 순서로 진행된다.

이력 저장 과정은 다음과 같다.

1. 현재 직원 정보의 일련번호를 조회
2. 일련번호를 증가시켜 이력 테이블에 추가
3. 변경된 직원 정보를 현재 상태 테이블에 반영

이 방식의 장점은, 이력 테이블에 직접 접근할 일이 적기 때문에 SQL이 단순하고 명확하다는 것이다. 하지만 데이터를 저장할 때는 **현재 테이블과 이력 테이블 모두에 접근해야 하므로 코드량이 증가**한다는 단점이 있다.

## 3. 변경 값

앞의 두 가지 방식은 데이터의 전체 복사본을 저장하기 때문에 변경되지 않은 속성까지 모두 포함되어 비효율적이다. 또한 변경된 속성을 찾기 위해서는 모든 필드를 일일이 비교해야 한다.

세 번째 방법은 **변경된 속성 이름과 값의 목록만 기록**하는 방식이다. 즉, 전체 복사본이 아니라 **변경된 부분만 추출하여 저장**한다. 이렇게 하면 데이터베이스를 훨씬 효율적으로 사용할 수 있으며, 변경 속성을 찾기 위해 전체 비교를 수행할 필요가 없다.

이때 **변경 속성 목록을 생성하는 책임**을 어디에 둘지가 중요하다. 애그리게이트(Aggregate)는 **변경 요청에 영향을 받는 엔티티와 값 객체(Value Object)** 를 알고 있고, **불변식(Invariant)** 을 유지하는 단위이므로 가장 적합한 후보이다.

따라서 변경 속성 목록을 생성하는 책임을 애그리게이트에 두면 유지보수 시 변경 범위를 자연스럽게 해당 애그리게이트로 한정할 수 있다.

애플리케이션 서비스는 기존처럼 애그리게이트를 호출하고, 리포지터리는 변경된 속성 목록만 전달받아 데이터베이스에 저장한다.

| **ID** | **SEQ** | **DELTA** |
| --- | --- | --- |
| 1234 | 1 | {“id”:“1234”,“nm”:“JohnDoe”,“deptNo”:“0001”,“insId”:“8987”,“insDt”:“20210102092312”} |
| 2345 | 1 |  |
| 1234 | 2 | {“deptNo”:“0004”,“upld”:“9881”,“upDt”:“20220123173421”} |
| 3456 | 1 |  |
| 1234 | 3 | {“delId”:“8987”,“delDt”:“20220317170000”} |

위 표는 변경된 속성 목록의 예시이다.

애그리게이트의 상태가 변할 때 생성되는 변경 속성 목록은 Map<K, V> 형태로 구성하며, 키(K)는 속성명(String), 값(V)은 변경된 속성값(String)이다. 모든 속성이 String 타입은 아니지만, 프리미티브 타입, 값 객체(Value Object), 엔티티(Entity)도 **문자열로 변환하여 저장**한다.

```java
public class Employee {

    public Map<String, String> changeValues(Map<String, String> values) {
        Map<String, String> affectedValues = new HashMap<>();

        Set<String> keys = values.keySet();
        for (String key : keys) {
            String value = values.get(key);
            switch (key) {
                case "email":                              // (1)
                    if (!value.equals(this.email)) {        // (2)
                        this.email = value;
                        affectedValues.put(key, value);     // (3)
                    }
                    break;
                case "password":
                    if (!value.equals(this.password)) {
                        this.password = value;
                        affectedValues.put(key, value);
                    }
                    break;
                case "address":
                    if (!JsonUtil.fromJson(value, Address.class).equals(this.address)) { // (4)
                        this.address = value;
                        affectedValues.put(key, JsonUtil.toJson(value));                 // (5)
                    }
                    break;
            }
        }
        return affectedValues; // (6)
    }
}
```

- 위 코드는 애그리게이트가 속성 변경을 감지하고, 변경된 항목만 Map에 담아 반환하는 로직이다.
- 즉, 속성명을 기준으로 현재 값과 변경될 값을 비교하고, 차이가 있을 경우만 변경 목록에 추가한다.

### 비밀번호 작성 규칙 도메인 서비스

비밀번호 변경은 단순한 값 비교만으로 처리할 수 없다. 비밀번호 작성 규칙(Password Policy) 을 검사해야 하며, 이를 도메인 서비스로 분리해 관리한다.

```java
public class PasswordWritingPolicy {

    public static boolean isValid(String value) {
        if (value.length() < 8) {
            return false;
        }
        Pattern passwordPattern = Pattern.compile("^(?=.*[A-Z])(?=.*\\d).+$");
        return passwordPattern.matcher(value).matches();
    }

}
```

이 도메인 서비스는 비밀번호가 규칙을 준수하는지 검사하며, 추가적으로 **비밀번호 암호화 처리**에도 활용할 수 있다.

무상태(Stateless) 서비스이므로 **단위 테스트 작성이 용이**하며, 규칙이 바뀌더라도 테스트를 통해 영향을 빠르게 검증할 수 있다.

### **변경 흐름을 조정하는 애플리케이션 서비스**

직원 정보 변경의 전체 흐름은 EmployeeService가 담당한다. 서비스는 애그리게이트의 changeValues() 메서드를 호출해 변경된 속성 목록을 얻고, 이를 이력 리포지터리에 저장한 뒤 현재 상태를 업데이트한다.

```java
public class EmployeeService {

    private final EmployeeDao employeeDao;
    private final EmployeeHistoryDao employeeHistoryDao;

    public void changeEmployee(String employeeId,
                               Map<String, String> values) {
        Employee employee = this.employeeDao.select(employeeId);

        Map<String, String> affectedValues =
                employee.changeValues(values);                 // (1)
        this.employeeHistoryDao.insert(employeeId, affectedValues); // (2)
        this.employeeDao.update(employee);                      // (3)
    }
}
```

지금까지 살펴본 세 가지 방법 모두 **“누가, 언제, 무엇을 변경했는가”** 를 추적할 수는 있지만, **“왜 변경했는가”**, 즉 **비즈니스적 이유와 맥락**은 알 수 없다.

이러한 변경의 이유를 추적하기 위해서는 다음 장에서 다룰 도메인 이벤트(Domain Event) 개념이 필요하다.

# 도메인 이벤트

부서 번호처럼 속성 하나만 변경된 경우에는 변경 이유를 비교적 쉽게 유추할 수 있다. 하지만 여러 속성이 한 번에 변경된 경우, 왜 그렇게 변경되었는지 이유를 파악하기가 어렵다.

속성 조합이 많아질수록 가능한 케이스를 모두 고려해야 하므로 시간이 많이 걸리고, 데이터 활용 가치도 떨어지게 된다.

도메인 주도 설계는 이러한 문제를 해결하기 위해 **도메인 이벤트(Domain Event)**를 강조한다.

도메인 이벤트는 단순히 **변경된 값을 기록하는 것**이 아니라, **비즈니스 처리 과정에서 발생한 결과**를 하나의 단위로 정의하는 개념이다.

즉, 이벤트는 단순한 데이터 변경이 아니라 “**사용자가 시스템에 어떤 처리를 요청했는가**”를 알려주는 힌트이자, “**왜 변경이 발생했는가**”를 설명하는 근거이다.

시스템이 관리하는 정보의 변화를 도메인 이벤트로 기록하면 도메인 모델을 더욱 명확하고 풍부하게 표현할 수 있다. 예를 들어, 사용자가 **비밀번호 변경을 요청**하면 그 결과를 PasswordChanged 라는 이벤트 클래스로 정의할 수 있다.

이렇게 하면 클래스 이름만 보더라도 **도메인에서 어떤 일이 일어났는지 즉시 이해**할 수 있다.

**또한 대부분의 도메인 이벤트는 사용자의 요청과 1:1 관계를 가지므로, 이벤트 클래스의 이름만으로도 시스템이 어떤 요청에 의해 변경되었는지를 쉽게 유추할 수 있다.**

# 이벤트 소싱

**이벤트 소싱(Event Sourcing)** 은 도메인에서 발생하는 **이벤트 자체를 시스템의 상태 변화로 간주**하는 개념이다.

즉, 애그리게이트(Aggregate)에서 발생하는 **모든 도메인 이벤트를 데이터베이스에 기록**하고, 이 기록을 통해 시스템의 상태를 추적하고 복원할 수 있다.

<img width="683" height="152" alt="image" src="https://github.com/user-attachments/assets/e17ad4f4-6ef5-4247-85b9-2ae3ac8fff26" />

데이터베이스에 저장된 도메인 이벤트를 **리플레이**하면 현재 상태를 다시 복원할 수 있다. 이 방식에서는 전통적인 CRUD 모델처럼 “현재 상태만을 저장”하지 않고, “**상태가 만들어진 모든 과정을 저장**”한다.

이벤트 소싱은 MyBatis나 JPA와 같은 일반적인 데이터 접근 방식과 달리, 도메인 객체에 새로운 속성을 추가하더라도 데이터베이스 테이블에 컬럼을 추가할 필요가 없다. 따라서 **객체와 테이블 간의 임피던스 불일치 문제**가 발생하지 않는다.

또한, 애그리게이트를 저장하는 리포지터리와 마찬가지로 애그리게이트에서 발생한 이벤트를 데이터베이스에 저장하는 과정도 **원자적**으로 처리되어야 한다.

<img width="379" height="213" alt="image" src="https://github.com/user-attachments/assets/25d7ce66-9581-44b9-a95a-c98e42de3055" />

시스템은 외부 요청을 받아 애그리게이트를 찾고, 해당 요청을 애그리게이트에 전달한다. 애그리게이트가 요청을 처리하면 그 결과로 도메인 이벤트를 생성하고, 이 이벤트를 데이터베이스에 기록한다.

이 일련의 흐름  요청 수신 → 애그리게이트 조회 → 요청 처리 → 이벤트 저장 은 하나의 트랜잭션으로 처리되어야 한다.

# 이벤트 소싱 구현

이벤트 기반으로 애그리게이트의 상태를 관리하기 때문에, 구현 시에는 애그리게이트가 이벤트를 처리하는 일정한 코딩 규칙과 패턴이 필요하다.

## 데이터 모델

이벤트 소싱에서는 애그리게이트의 속성을 개별 컬럼으로 저장하지 않고, **해당 애그리게이트에서 발생한 도메인 이벤트만을 기록**한다.

데이터 모델은 다음 두 개의 테이블로 구성된다.

- TB_CART : 애그리게이트(카트)를 식별하기 위한 테이블이다. 각 카트의 고유 식별자를 관리한다.
- TB_CART_EVENT : 애그리게이트에서 발생한 도메인 이벤트를 저장하는 테이블이다.
    
    
    | **컬럼명** | **설명** |
    | --- | --- |
    | event_id | 이벤트 엔티티의 식별자 |
    | cart_id | 이벤트가 발생한 애그리게이트를 식별하기 위한 외래키 |
    | payload | 이벤트 내용을 JSON으로 직렬화해 저장 |
    | occurred_at | 이벤트 발생 시각 |

이벤트는 직렬화 과정을 거쳐 JSON 형태로 payload 컬럼에 저장된다. 이를 통해 이벤트 구조를 유연하게 관리할 수 있으며, 리플레이 시에는 해당 JSON을 역직렬화하여 애그리게이트의 상태를 복원한다.

## 애그리게이트와 이벤트 저장

카트의 주요 기능은 상품 추가, 삭제, 수량 변경이며 주요 도메인 객체는 Cart와 Item이다. 카트는 엔티티이면서 애그리게이트 루트이고, Item은 값 객체이다.

즉, 상품을 카트에 아이템으로 추가하고, 카트에 있는 아이템의 수량을 변경하며, 카트에 있는 아이템을 삭제하는 기능을 제공한다.

<img width="385" height="188" alt="image" src="https://github.com/user-attachments/assets/85b2cb6b-deae-4651-bb11-cfb8fbb41846" />

카트 애그리게이트가 제공하는 메서드를 호출하면 ItemAdded, QuantityChanged, ItemRemoved 도메인 이벤트를 발생시켜야 한다. 이러한 도메인 이벤트는 식별하여 클래스로 선언한다. 이벤트가 발생한 시간은 각 이벤트 객체가 생성된 시간으로, 생성자에서 현재 시간을 time 속성에 할당한다.

또한 도메인 이벤트는 과거에 발생한 사건으로 **변경할 수 없는 객체**여야 하므로 setter는 제공하지 않는다.

```java
public class ItemAdded {
    private String eventId;
    private String productNo;
    private String productName;
    private int quantity;
    private long time;

    private ItemAdded() {
        this.eventId = UUID.randomUUID().toString();
        this.time = System.currentTimeMillis();
    }

    public ItemAdded(String productNo, String productName, int quantity) { // (1)
        this();
        this.productNo = productNo;
        this.productName = productName;
        this.quantity = quantity;
    }
}
```

카트 애그리게이트의 메서드를 호출하면 실행 결과로 도메인 이벤트 인스턴스가 생성되고, 이벤트 저장소에 저장하기 전까지는 카트 애그리게이트가 이를 임시로 보관한다.

이를 위해 카트 애그리게이트에는 발생한 이벤트를 담는 events 속성이 List 타입으로 선언되어 있다.

```java
public class Cart {

    private String cartId;
    private List<Item> items;

    private List<Object> events;     // (1)

    public Cart(String cartId) {
        this.cartId = cartId;
        this.items = new ArrayList<>();

        this.events = new ArrayList<>();
    }

    public void addItem(String productNo, String productName,
                        int quantity) {
        this.items.add(new Item(productNo, productName, quantity));
        ItemAdded event = new ItemAdded(productNo, productName,
                                        quantity);                     // (2)
        this.events.add(event);                                        // (3)
    }

}
```

애그리게이트가 요청을 실행하고 오류가 없으면, 애플리케이션 서비스는 이벤트를 데이터베이스에 기록하기 위해 리포지터리 객체를 사용한다. 이벤트 스토어(리포지터리)는 이벤트 객체를 직렬화해 TB_CART_EVENT 테이블에 저장한다.

애그리게이트는 일관성을 유지해야 하는 단위이므로, 애그리게이트에서 발생한 이벤트를 한 번에 저장하거나 조회해서 애그리게이트를 반환하는 메서드를 제공해야 한다.

```java
public class CartStore {
    public void save(Cart cart) { ... }        (1)
    public Cart load(String cartId) { ... }    (2)
}
```

이벤트 저장소는 JPA를 래핑한 Spring Data JPA를 사용하면 된다. 애그리게이트와 도메인 이벤트를 저장하기 위해 클래스를 JPA 엔티티로 선언한다.

```java
@Entity
@Table(name = "TB_CART_EVENT")
public class CartEventJpo {

    @Id
    private String eventId;     (1)
    private String cartId;      (2)
    @Lob
    private String payload;     (3)
    private long time;          (4)

    public CartEventJpo(Cart cart, ItemAdded event) {
        this.eventId = event.eventId();
        this.cartId = cart.getCartId();
        this.payload = JsonUtil.toJson(event);
        this.time = event.getTime();
    }

    public CartEventJpo(String cartId, QuantityChanged event) {
        // 생략
    }

    public CartEventJpo(String cartId, ItemRemoved event) {
        // 생략
    }
}
```

시스템을 운영하면서는 이벤트 클래스를 추가로 선언하거나, 기존 클래스의 속성을 변경해야 하는 경우가 생긴다.

새로운 이벤트 타입을 추가할 때마다 메서드를 오버라이드해야 하는 불편함이 있는데, 이를 해결하기 위해 Event라는 이름의 추상 클래스를 선언하고 구체적인 도메인 이벤트들이 이 클래스를 상속하도록 하면 불필요한 중복 코드를 줄일 수 있다.

```java
public abstract class Event {

    private String eventId;    // (1)
    private long time;         // (2)
    private String cartId;

    public Event() {
        this.eventId = UUID.ramdomUUID().toString();
        this.time = System.currentTimeMillis();
    }

    public String getPayload() {   // (3)
        return JsonUtil.toJson(this);
    }
}
```

```java
public class ItemAdded extends Event {}
public class QuantityChanged extends Event {}
public class ItemRemoved extends Event {}
```

CartStore.save 메서드는 CartJpo를 카트 테이블에 저장하고, CartEventJpo를 이벤트 테이블에 저장한다.

리포지터리인 CartStore는 애그리게이트 단위의 트랜잭션을 보장해야 하므로 스프링의 @Transactional을 사용해 두 엔티티에 영향을 주는 작업을 하나로 묶는다.

```java
@Repository
@Transactional
public class CartStore {

    private final CartRepository cartRepository;
    private final CartEventRepository cartEventRepository;

    public void save(Cart cart) {
        this.cartRepository.save(new CartJpo(cart));
        this.cartEventRepository.saveAll(cart.getEvents().stream()
                .map(event -> new CartEventJpo(cart, event))
                .collect(Collectors.toList()));
    }
}
```

결과적으로, 카트 애그리게이트가 네 번의 사용자 요청을 처리하면 테이블에는 다음과 같이 도메인 이벤트가 순차적으로 기록된다.

<img width="416" height="321" alt="image" src="https://github.com/user-attachments/assets/e23ab307-16b9-42e5-a819-5ef0504d9791" />

## 커맨드와 이벤트

일반적으로 소프트웨어에서 요청이란, 시스템에 어떤 작업을 수행하도록 지시하는 것이다. 이 요청은 비즈니스 유스케이스를 시작하는 트리거가 되며, 객체의 상태를 변경한다.

즉, 소프트웨어가 어떤 일을 수행하게 하는 **의도(목표)**를 **커맨드**라 하고, 그 수행 결과를 **이벤트**라 한다. 커맨드와 이벤트는 모두 **정보를 전달하기 위한 메시지**라는 공통점을 가지지만, 기술적으로 처리 방식에 차이가 있다.

커맨드는 일반적으로 **동기**로 처리되고, 이벤트는 **비동기**로 처리된다.

### 커맨드

커맨드는 시스템 내의 **행위를 실행하는 방법**을 정의한다. 즉, 시스템 상태를 변경하기 위한 의도를 가진 메시지이며, 사용자 또는 시스템의 다른 부분에서 생성된다.

특징을 정리하면 다음과 같다.

- 행위를 실행하는 방법이다.
- 사이드 이펙트(Side Effect)가 있는 작업이다.
- 시스템 상태를 변경하는 의도를 가진 메시지이다.
- 사용자 혹은 시스템의 다른 부분에서 생성된다.

### 이벤트

이벤트는 이미 발생한 사실에 대한 설명이다. 즉, 커맨드가 실행된 결과이며, 시스템 내부에서 발생한 것이다. 메소드의 반환값이 아니라, 명령이 실행된 뒤의 결과적 사실이다.

특징은 다음과 같다.

- 이미 발생한 사실을 표현한다.
- 발생한 일이므로 과거형으로 네이밍한다.
- 시스템 내부에서 발생한 것이다.
- 명령을 실행한 결과이며, 메소드의 반환값이 아니다.

### 커맨드와 이벤트 네이밍

커맨드는 도메인에서 식별한 동사 를 주로 사용한다. 예를 들어 createCart, addItem, removeItem 같은 이름으로 표현할 수 있다.

이러한 동사는 애플리케이션 서비스의 메소드(createCart, addItem, removeItem)뿐 아니라 각 오퍼레이션의 파라미터 객체(CreateCart, AddItem) 네이밍에도 사용할 수 있다. 사용자 인터페이스(UI)가 제공하는 버튼이나 링크 또한 커맨드 객체를 식별하는 데 유용한 단서가 된다.

경우에 따라 커맨드를 먼저 식별하면, 그로부터 자연스럽게 이벤트를 유추할 수도 있다.

이벤트는 커맨드에 의해 발생한 사건이므로, 커맨드를 단순히 과거형으로 바꿔 사용할 수도 있다. 예를 들어 다음과 같다. CartCreated, ItemAdded, ItemRemoved.

### 커맨드와 이벤트

비즈니스 프로세스는 식별한 이벤트뿐 아니라, 그 이벤트에 의해 다시 발생하는 커맨드와 파생 이벤트까지 고려해야 한다.

예를 들어, 사용자 등록 시 UserRegistered 이벤트를 식별할 수 있다. 이 이벤트에 반응해 “가입 환영 이메일을 발송하는 커맨드”와 그에 따른 이벤트를 추가로 식별할 수 있다.

이처럼 이벤트와 커맨드는 서로 연쇄적으로 연결되며, 하나의 비즈니스 흐름을 완성한다.

### 커맨드 객체 필요성

CartService의 addItem 메소드처럼 단순히 프리미티브 타입 파라미터를 나열하는 것도 일종의 커맨드라고 볼 수 있다. 하지만 이러한 방식은 **파라미터 타입이나 개수 변화**에 따라 여러 클래스가 영향을 받게 되는 단점이 있다.

<img width="557" height="257" alt="image" src="https://github.com/user-attachments/assets/bbdc2538-e26f-4745-9121-a08862d7d378" />

변경에 따른 영향도를 낮추고, 설계 의도를 명확하게 표현하기 위해서는 커맨드 객체(Command Object) 를 사용하는 것이 좋다.

예를 들어 AddItem이라는 커맨드 클래스를 네 개의 속성으로 정의하면 설계 의도를 명확히 전달할 수 있으며, 추가적인 속성이 필요할 때도 파라미터 목록 전체를 수정할 필요가 없다.

즉, 애플리케이션 서비스부터 인프라스트럭처 서비스까지 호출 구조의 변경 영향을 최소화할 수 있다.

<img width="512" height="282" alt="image" src="https://github.com/user-attachments/assets/ca10e6c2-c248-4c99-87a0-33142a4e686f" />

```java
public class AddItem {
    private String cartId;

    private String productNo;
    private String productName;
    private int quantity;
}
```

이처럼 커맨드 클래스를 사용하면 응집도와 결합도가 개선되고, 유지보수성이 높아진다. 따라서 파라미터 목록 대신 **명확한 의도를 가진 커맨드 클래스**를 사용하는 것이 바람직하다

## 커맨드와 유효성 검사

비즈니스 전문가들은 일반적으로 유효성 검사에 큰 관심을 두지 않기 때문에, 이 책임을 애플리케이션 서비스 계층에 두는 경우가 많다.

하지만 유효성 검사를 단순히 기술적 처리로 보지 않고, 도메인 영역의 일부로 정의한다면 커맨드 내부에서 유효성 검사를 수행하여 응집도를 높일 수 있다.

다음 예시는 ChangeQuantity 커맨드 클래스에서 자체적으로 유효성 검사를 수행하는 구조를 보여준다.

```java
public class ChangeQuantity {

    private String cartId;
    private String itemId;
    private int quantity;

    public void validate() {
        if (cartId.isEmpty()) {
            throw new IllegalArgumentException();
        }

        if (quantity <= 0) {
            throw new QuantityZeroException();
        }
    }
}
```

커맨드 객체가 스스로 자신의 유효성을 검증하면, 애플리케이션 서비스는 단순히 커맨드를 전달받아 검증 메소드를 호출하는 형태로 책임이 명확히 분리된다.

```java
public class CartService {

    public void changeQuantity(ChangeQuantity command) {
        command.validate();

        Cart foundCart = this.cartStore.load(command.getCartId());
    }
}
```

## 재수화(이벤트 리플레이)

애그리게이트 상태의 변화 기록인 도메인 이벤트를 데이터베이스에 빠짐없이 기록했다면, 이벤트를 리플레이하여 애그리게이트의 현재 상태로 복원할 수 있다. 도메인 이벤트로 상태를 복원하는 과정을 **재수화(Rehydration)** 라고 한다.

이벤트를 기록하기 위해 코딩 규칙을 정의했던 것처럼, 재수화를 위해서도 도메인 이벤트를 애그리게이트에 반영하여 현재 상태로 복원하는 코딩 규칙이 필요하다.

일반적으로 시스템은 쓰기보다 읽기 빈도가 훨씬 높다. 이벤트 소싱을 적용하면 다양한 조건으로 데이터를 조회할 때 한계가 생기는데, 조회 성능과 개발 편의성을 해소하기 위해 도메인 이벤트에서 **조회 전용 데이터를 미리 생성**하는 방식을 **프로젝션(Projection)** 이라고 한다.

도메인 주도 설계에서 리포지터리는 도메인 객체의 라이프사이클 중간 단계인 애그리게이트를 재구성하는 책임도 가진다.

load 메소드는 애그리게이트인 Cart 식별자를 사용하여 다음 다섯 단계를 거쳐 현재 상태를 복원한다.

1. 애그리게이트와 매핑된 CartJpo를 조회한다.
2. 도메인 이벤트와 매핑된 CartEventJpo 목록을 발생 시간 순으로 조회한다.
3. 조회한 CartJpo를 Cart 애그리게이트로 변환한다.
4. 조회한 CartEventJpo들을 도메인 이벤트(ItemAdded, ItemRemoved, …)로 변환한다.
5. Cart 애그리게이트가 제공하는 재수화 메소드를 호출해 이벤트를 리플레이한다.

```java
@Entity
@Table(name = "TB_CART")
public class CartJpo {

    @Id
    private String cartId;

    public Cart toCart() {
        return new Cart(this.cartId);
    }
}
```

CartJpo와 마찬가지로 이벤트도 도메인 이벤트로 변환해야 하지만, 리플레이할 이벤트를 저장한 이벤트 테이블은 원래 도메인 이벤트로 역직렬화할 타입을 포함하지 않는다. 따라서 도메인 이벤트를 저장할 때 역직렬화할 타입명을 가지는 type 컬럼을 추가해야 한다.

```java
@Entity
@Table(name = "TB_CART_EVENT")
public class CartEventJpo {

    @Id
    private String id;
    private String cartId;
    private String type;

    @Lob
    private String payload;
    private long time;
}
```

```java
public abstract class Event {

    public String typeName() {
        return this.getClass().getTypeName();
    }
}
```

```java
public class CartEventJpo {

    public CartEventJpo(Cart cart, Event event) {
        this.eventId = event.eventId();
        this.cartId = cart.getCartId();

        this.payload = event.getPayload();
        this.type = event.typeName();
        this.time = event.getTime();
    }
}
```

CartEventJpo도 CartJpo의 toCart()처럼 도메인 이벤트로 역직렬화할 수 있는 메소드를 추가해야 한다.

```java
@Entity
@Table(name = "TB_CART_EVENT")
public class CartEventJpo {

    public Event toEvent() {
        Class clazz = Class.forName(this.type);
        Event event = JsonUtil.fromJson(this.payload, clazz);
        return event;
    }
}
```

CartStore의 load 메소드는 다음과 같이 애그리게이트를 재구성한다.

```java
@Repository
@Transactional
public class CartStore {

    private final CartRepository cartRepository;
    private final CartEventRepository cartEventRepository;

    public Cart load(String cartId) {
        CartJpo cartJpo = this.cartRepository.findById(cartId);
        List<CartEventJpo> eventJpos = this.cartEventRepository
                .findByCartIdOrderByTimeAsc(cartId);

        Cart foundCart = cartJpo.toCart();

        List<Event> events = eventJpos.stream()
                .map(eventJpo -> eventJpo.toEvent())
                .collect(Collectors.toList());
        events.forEach(event -> foundCart.?(event));

        return foundCart;
    }
}
```

지금까지 구현한 Cart 애그리게이트의 메소드는 도메인 이벤트를 events 속성에 임시로 보관한다. 하지만 리플레이에서 사용한 도메인 이벤트는 상태 복원에만 사용되므로 events에 보관할 필요가 없다.

이를 위해 커맨드 처리 메소드와 도메인 이벤트 리플레이 메소드를 분리해야 한다. 이렇게 하면 리플레이 이벤트는 상태 복원에만 사용되고, events에는 저장되지 않는다.

```java
public class Cart {

    public void addItem(AddItem command) {
        if (!this.containsItem(command.getProductNo())) {
            ItemAdded event = new ItemAdded(productNo, productName,
                                            quantity);
            this.on(event);
        }
    }

    public void on(ItemAdded event) {
        this.items.add(new Item(event.getProductNo(),
                                event.getProductName(),
                                event.getQuantity()));
        this.events.add(event);
    }

    private boolean containsItem(String productNo) {
        return !this.items.stream.filter(item -> {
            return productNo.equals(item.getProductNo());
        })
        .findFirst().isEmpty();
    }
}
```

Cart 클래스의 이벤트 핸들러 on 메소드를 public으로 선언하면 CartStore에서 직접 호출할 수 있다. 하지만 상태를 변경하는 코드를 그대로 이동하여 호출하면 여전히 리플레이에서 사용한 도메인 이벤트를 events 목록에 기록하게 된다.

따라서 Cart 클래스는 리플레이와 임시 저장 이벤트를 구분해 선택적으로 호출할 수 있는 메소드를 제공해야 한다.

이를 위해 외부에서 호출할 수 있는 이벤트 핸들러 메소드를 추가하고, 이벤트를 “적용하다”라는 의미로 apply라는 이름을 사용한다. apply는 파라미터로 전달받은 이벤트 타입에 맞는 이벤트 핸들러(on 메소드)를 찾아 호출한다.

CartStore는 리플레이 시 apply 메소드를 사용한다. apply가 on을 대신 호출하므로 on 메소드는 private으로 변경한다. 자바 리플렉션은 기본적으로 private 메소드를 호출할 수 없으므로 setAccessible(true)를 이용해 접근할 수 있게 한다.

```java
public class Cart {

    public void apply(Event event, boolean isNew) {
        Method handler = this.getClass()
                             .getDeclaredMethod("on", event.getClass());
        if (handler != null) {
            handler.setAccessible(true);
            handler.invoke(this, event);
            if (isNew) {
                this.events.add(event);
            }
        }
    }
}
```

또한 apply 메소드는 새로운 이벤트인지 여부를 판단하기 위해 isNew 파라미터를 추가한다. 이 값에 따라 이벤트를 events 목록에 추가할지 여부를 선택한다.

이로써 이벤트 리플레이에서 불필요한 도메인 이벤트가 events에 보관되지 않도록 개선할 수 있었다. 하지만 CartStore.load()와 애그리게이트의 커맨드 핸들러가 apply를 호출할 때마다 isNew 값을 전달해야 하는 불편함이 남는다.

이는 코드 중복을 야기하고, 잘못된 파라미터 전달로 오류가 발생할 가능성을 높인다. 이를 해결하기 위해 isNew 파라미터가 없는 apply 메소드를 추가하고, 기본적으로 true를 전달하도록 오버로딩한다.

이렇게 하면 새로운 이벤트와 리플레이 이벤트를 명확히 구분할 수 있고, 실수 가능성을 줄일 수 있다.

```java
public class Cart {

    public void apply(Event event) {
        this.apply(event, true);
    }

    public void apply(Event event, boolean isNew) {
        Method handler = this.getClass()
                             .getDeclaredMethod("on", event.getClass());
        if (handler != null) {
            handler.setAccessible(true);
            handler.invoke(this, event);
            if (isNew) {
                this.events.add(event);
            }
        }
    }
}
```

최종적으로, CartStore.load()는 리플레이 시 apply(event, false)를 호출하여 상태를 복원한다.

```java
@Repository
@Transactional
public class CartStore {

    public Cart load(String cartId) {
        CartJpo cartJpo = this.cartRepository.findById(cartId);
        List<CartEventJpo> eventJpos =
                this.cartEventRepository.findByCartIdOrderByTimeAsc(cartId);

        Cart foundCart = cartJpo.toCart();

        List<Event> events = eventJpos.stream()
                .map(eventJpo -> eventJpo.toEvent())
                .collect(Collectors.toList());

        events.forEach(event -> foundCart.apply(event, false));

        return foundCart;
    }
}
```

이와 같이 이벤트 리플레이를 적용하면, 도메인 이벤트를 기반으로 애그리게이트의 현재 상태를 재구성할 수 있다. 

이는 이벤트 소싱 패턴의 핵심이자, 시스템의 상태 변화를 시간 순으로 추적하고 복원할 수 있게 하는 기반이 된다.

# 마이크로서비스 모듈

도메인 주도 설계에서 인지 과부하를 막기 위해 모듈을 사용한다고 했다.

이벤트 소싱을 적용한 마이크로서비스의 핵심 모듈은 aggregate, command, event, service, store 패키지로 구분한다.

<img width="427" height="305" alt="image" src="https://github.com/user-attachments/assets/71a0f426-6a33-48e8-8a24-dc20693587a3" />

도메인 주도 설계와 이벤트 소싱을 적용하는 마이크로서비스는 식별한 애그리게이트 클래스를 aggregate에 패키지에 둔다.

애그리게이트를 생성하고 폐기할때까지 영향을 주는 커맨드와 영향을 받은 결과인 이벤트 클래스를 각각 command와 event 패키지에 둔다.

애그리게이트에 변화가 발생한 결과인 도메인 이벤트를 데이터베이스에 저장하고 복원하는 책임을 부여한 이벤트 저장소와 애그리게이트와 이벤트를 테이블과 매핑한 JPA 엔티티 클래스는 store 패키지에 둔다.

사용하는 데이터베이스 접근 기술에 따라 jpa, caassandra , mongor와 같은 하위 패키지로 둘 ㅜ 있다.

# 이벤트 소싱과 단위 테스트

이벤트 소싱을 적용하더라도 주요 비즈니스 로직은 여전히 도메인 객체에 있기 때문에 도메인 객체만 사용하는 단위 테스트를 구현할 수 있다.

도메인 주도 설계에서 설명한 단위 테스트와의 차이점은 행위를 실행시키는 프리미티브 타입이 파라미터 목록을 커맨드 객체로 변경한 것

```java
public class CartTest {

    private static final String CART_ID = "1234";

    @Test
    public void testAddItem() {
        Cart cart = new Cart(CART_ID);
        AddItem addItem = new AddItem(CART_ID, "PD002", "iPad mini", 650000);

        cart.addItem(addItem);
        Assert.assertEquals(1, cart.getItems().size());
    }

    @Test
    public void testRemoveItem() {
        Cart cart = new Cart(CART_ID);
        AddItem addItem = new AddItem(CART_ID, "PD002", "iPad mini", 650000);

        cart.addItem(addItem);

        RemoveItem removeItem = new RemoveItem(CART_ID, "PD001");
        cart.removeItem(removeItem);
        Assert.assertEquals(0, cart.getItems().size());
    }
}
```

하나의 커맨드가 여러 개의 도메인 이벤트를 발생시키는 경우 단위 테스트의 통과 조건으로 이벤트 개수도 검사할 수 있다.
