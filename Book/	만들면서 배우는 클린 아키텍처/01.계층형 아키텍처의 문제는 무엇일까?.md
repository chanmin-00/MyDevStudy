# 계층형 아키텍처 개요


계층형 아키텍처는 우리가 오랫동안 배워온 익숙한 구조다. 

<img width="272" alt="image" src="https://github.com/user-attachments/assets/bc870b8a-912c-4738-aaba-5de9c54413d9" />


일반적으로 웹 계층 → 도메인 계층 → 영속성 계층 순으로 요청이 흐르며, 각 계층은 아래 계층에만 의존한다. 

잘 설계된 계층형 아키텍처는 기술을 유연하게 바꾸거나 기능을 쉽게 추가하는 데 도움이 된다.  그러나 실제 프로젝트에서는 시간이 지날수록 여러 문제를 드러낸다.

# 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다



전통적인 계층 구조에서는 영속성 계층이 기반이 되며, 도메인 계층은 영속성 계층에 의존하고, 웹 계층은 도메인 계층에 의존한다. 이 구조는 도메인 로직보다 데이터베이스 설계를 먼저 하게 만든다.

하지만 애플리케이션의 목적은 데이터를 다루는 것이 아니라 비즈니스 규칙과 정책을 반영하는 것이다. 중요한 것은 `상태`가 아니라 상태를 바꾸는 `행동`이다. 그럼에도 불구하고 우리는 종종 영속성 계층의 구현부터 시작한다.

<img width="624" alt="image" src="https://github.com/user-attachments/assets/5d91db9a-8ac5-4786-8fe9-11d0c31e7254" />


# 지름길을 택하기 쉬워진다



계층형 아키텍처가 유일하게 강제하는 규칙은 `하위 계층만 접근할 수 있다는 것` 이다. 

그러나 실제 개발 현장에서는 마감 압박이나 편의성 때문에 위 계층에서 하위 계층을 우회하거나, 특정 컴포넌트를 억지로 아래 계층으로 내려 배치하는 등의 지름길을 택하게 된다.

이러한 지름길은 처음엔 빠른 해결책이 되지만, 점점 더 많은 예외 상황을 만들고 팀 전체가 이를 따라하게 된다. 결과적으로 규칙은 유명무실해지고, 코드의 품질은 낮아진다.

특히 영속성 계층은 아래에 위치하기 때문에 모든 곳에서 접근 가능하고, 다양한 컴포넌트가 모이면서 시간이 지날수록 점점 커지고 복잡해진다.

<img width="581" alt="image" src="https://github.com/user-attachments/assets/f953308f-187e-4147-bb81-b7eeeab6e8d2" />


# 테스트하기 어려워진다


계층형 아키텍처에서는 도메인 계층을 우회하여 웹 계층에서 직접 엔티티를 조작하는 경우가 발생한다. 예를 들어, 단일 필드 조작과 같은 간단한 작업을 위해 도메인 계층을 생략하고 영속성 계층에 바로 접근하면 도메인 로직이 웹 계층에 흩어지게 된다.

이렇게 되면 테스트 코드 작성이 어려워진다. 웹 계층에서 단위 테스트를 할 때 도메인과 영속성 계층을 모두 모킹해야 하며, 테스트 설정이 복잡해져 테스트 자체를 회피하게 된다.

결국 테스트 커버리지는 낮아지고, 시스템의 안정성 확보는 점점 더 어려워진다.

# 유스케이스를 숨긴다



새로운 유스케이스를 개발할 때 우리는 대부분 기존 코드를 수정하게 된다. 이때 계층형 구조는 유스케이스가 흩어지게 만들고, 관련 로직이 어디 있는지 찾는 데 오랜 시간이 걸린다.

도메인 계층이 생략되거나 영속성 계층으로 컴포넌트가 내려가면, 도메인 로직은 여기저기 흩어진다. 더욱이 도메인 서비스가 너무 많은 유스케이스를 담당하게 되면 하나의 서비스 클래스가 지나치게 비대해진다.

<img width="495" alt="image" src="https://github.com/user-attachments/assets/4d0e40e4-4877-474e-b33f-2166ba0046d6" />


이러한 구조에서는 유스케이스별로 기능을 파악하고 수정하는 데 큰 어려움을 겪게 된다.

# 동시 작업이 어려워진다



현실에서는 기능을 빠르게 완성하기 위해 여러 개발자가 동시에 작업해야 한다. 하지만 계층형 아키텍처에서는 특정 기능을 구현하기 위해 반드시 아래 계층부터 작업해야 하므로, 동시에 작업하기 어렵다.

예를 들어, 어떤 유스케이스를 개발할 때 먼저 영속성 계층을 개발해야 도메인 계층 작업이 가능하고, 도메인 계층이 완성되어야 웹 계층을 개발할 수 있다.

또한 하나의 서비스 클래스가 많은 기능을 담당하면, 여러 개발자가 동시에 같은 파일을 수정하게 되어 충돌이 자주 발생한다. 이는 병합 충돌, 수정 충돌, 심지어는 기능 간 간섭으로 이어진다.

# 결론



계층형 아키텍처는 구조적으로 보기 좋고, 몇 가지 규칙만 더해지면 유지보수에도 도움이 될 수 있다. 그러나 지름길을 방지하고 코드 품질을 유지하기 위해서는 개발자들의 자기 훈련이 필요하며, 이 훈련은 마감일이 닥칠수록 점점 느슨해진다.

계층형 아키텍처를 사용할지, 다른 아키텍처 스타일을 적용할지는 자유지만, 계층형 아키텍처의 함정을 명확히 이해하고, 이를 방지할 수 있는 실천이 동반되어야만 유지보수 가능한 소프트웨어를 만들 수 있다.
