이 장의 목적은 지름길의 존재를 인식하고, 그것이 무의식적으로 사용되지 않도록 하며, 필요하다면 의식적으로 선택하고 관리할 수 있게 돕는 것이다.

소프트웨어는 물리적인 구조물이 아니며, 변경이 자유롭기 때문에 때로는 지름길을 취하는 것이 더 경제적인 선택일 수도 있다. 하지만 그 지름길이 쌓이면 시스템 전체를 망가뜨릴 수 있기 때문에 반드시 의식적인 판단이 필요하다.

# **왜 지름길은 깨진 창문 같을까?**

1969년 심리학자 필립 짐바르도가 실행한 실험은 ‘깨진 창문 이론’이라는 행동 심리 이론을 낳았다. 그 핵심은 환경이 방치돼 보이면 사람들은 그 환경을 더 쉽게 망가뜨리려 한다는 것이다.

이 이론은 소프트웨어 개발에도 그대로 적용된다.

- 정돈되지 않은 코드에서는 품질 낮은 코드가 더 쉽게 추가되고,
- 규칙이 무시된 환경에서는 더 많은 규칙 위반이 발생하며,
- 지름길을 남용한 코드에선 더 많은 지름길이 덧붙여진다.

이러한 심리가 반복되면, 결국 `레거시 코드`라고 불리는 관리되지 않는 코드 덩어리로 변하게 된다.

# **깨끗한 상태로 시작할 책임**

모든 개발자는 ‘깨진 창문’을 만드는 데 책임이 있다. 가능한 한 처음부터 지름길 없이 깔끔하게 시작해야 한다. 한 번 허용된 지름길은 또 다른 지름길을 끌어들이고, 결국 아키텍처의 기반을 무너뜨릴 수 있기 때문이다.

그러나 언제나 지름길이 나쁜 것만은 아니다. 예를 들어 프로토타입, 비핵심 기능, 시간 제약이 심한 작업이라면 일시적인 지름길을 허용할 수도 있다.

이때 중요한 건, 그 지름길을 문서화하고 팀 전체가 인지하도록 만드는 것이다. 예를 들어 `ADR(Architecture Decision Record)` 형식을 활용하면 나중에 프로젝트를 인계받는 사람도 지름길이 의도적인 결정이었다는 점을 이해할 수 있다.

# **유스케이스 간 모델 공유하기**

4장에서 유스케이스마다 고유한 입출력 모델을 가져야 한다고 설명했지만, 비슷한 유스케이스끼리 **하나의 모델을 공유**하는 것도 흔한 지름길이다.

![image](https://github.com/user-attachments/assets/4d64f8d5-4d04-46ff-9e95-bafe82435f6b)


예를 들어 `SendMoneyUseCase`와 `RevokeActivityUseCase`가 `SendMoneyCommand`를 공유할 경우, 이 모델에 변경이 생기면 두 유스케이스 모두 영향을 받는다.

이런 공유는 기능적으로 강하게 묶여 있고 변경 이유가 동일한 경우에는 괜찮다. 하지만 그렇지 않다면 유스케이스 간 결합이 생기고, 독립적인 진화를 방해하게 된다.

따라서 “이 유스케이스들이 장기적으로 서로 독립적으로 진화할 수 있어야 하는가?”라는 질문을 주기적으로 해야 하고, 그렇다면 입출력 모델을 분리하는 것이 맞다.

# 도메인 엔터티를 입출력 모델로 사용하기

`Account` 같은 도메인 엔터티를 유스케이스의 입출력 모델로 직접 사용하는 것도 흔한 지름길이다.

![image](https://github.com/user-attachments/assets/adc3d2e6-dcb0-46f7-9186-55c41a741206)


간단한 CRUD 작업이라면 괜찮지만, 유스케이스가 복잡해지면 도메인 엔터티에 존재하지 않아야 할 필드나 책임이 유스케이스 요구에 의해 추가되기 시작한다. 이는 도메인 모델이 애플리케이션 요구로 오염되는 결과를 초래한다.

애자일 환경에서 대부분의 유스케이스는 처음에는 단순하지만 점점 복잡해진다. 그러므로 초반에 도메인 엔터티를 사용하더라도, 전용 입출력 모델로 바꿔야 할 시점을 팀이 인지하고 준비해야 한다.

# 인커밍 포트 건너뛰기

인커밍 포트를 생략하고, 인커밍 어댑터(예: 컨트롤러)가 애플리케이션 서비스의 메서드를 직접 호출하는 것도 자주 쓰이는 지름길이다.

![image](https://github.com/user-attachments/assets/492d90c4-da8b-4464-9ed1-a20f3c9ab6de)


이 방식은 구조를 간단하게 만들어 주지만, 문제가 있다

- 유스케이스의 진입점이 명확하지 않아 이해가 어려워지고,
- 실수로 의도하지 않은 메서드를 외부에서 호출할 수 있는 가능성이 생긴다.

또한, 인커밍 포트를 정의하면 ArchUnit 등의 도구를 통해 아키텍처 규칙을 쉽게 강제할 수 있다는 장점도 있다. 따라서 규모가 커질 가능성이 있는 애플리케이션이라면 포트를 생략하지 말고 유지하는 것이 좋다.

# 애플리케이션 서비스 건너뛰기

간단한 유스케이스의 경우, 애플리케이션 계층을 생략하고 아웃고잉 어댑터가 직접 유스케이스를 구현하는 방법도 있다. 이 경우 어댑터가 인커밍 포트를 직접 구현하게 된다.

![image](https://github.com/user-attachments/assets/b4197927-4d51-400c-be51-0f7c542ad132)


이 지름길은 코드를 줄여주고 간결해 보이지만, 다음과 같은 문제가 있다

- 도메인 로직이 어댑터에 섞이게 되어 응집도가 약화된다.
- 시간이 지나면 도메인 로직이 어댑터 곳곳에 퍼져 유지보수가 어려워진다.

처음에는 단순 전달만 하던 유스케이스라도 시간이 지나면 복잡한 흐름을 가지게 된다. 그렇기 때문에 어떤 시점부터는 애플리케이션 서비스를 도입할 시점을 명확히 정해두는 것이 좋다.

# 결론

지름길은 개발 생산성을 높일 수 있는 합리적인 선택일 수도 있다. 하지만 그 사용은 신중하고 의식적이어야 하며, 반드시 기록으로 남겨져야 한다.

모든 유스케이스가 복잡해지진 않는다. 일부는 처음부터 끝까지 단순한 CRUD로 머무를 수도 있다. 이런 경우에는 구조를 복잡하게 가져가는 것보다 지름길을 유지하는 편이 더 경제적이다.

하지만 언젠가는 구조를 정비해야 할 시점이 올 수도 있으므로, “이 시점이 바로 그때다”라고 팀이 합의할 기준을 마련해 두는 것이 중요하다. 그리고 지름길을 쓴 결정에 대해서는 기록을 남겨야 이후 유지보수나 인계에서도 혼란이 생기지 않는다.
