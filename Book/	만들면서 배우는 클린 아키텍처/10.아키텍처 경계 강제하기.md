클린 아키텍처를 적용하면, 코드를 어디에 두고 어떻게 연결할지 명확한 뼈대를 갖추게 된다.

하지만 프로젝트 규모가 커지고 시간이 지나면 계층 간 경계가 무너지고, 테스트는 어려워지며, 개발 속도도 점점 느려진다.

이 장에서는 아키텍처가 무너지지 않도록 경계를 명확히 하고 강제하는 방법들을 소개한다.

# 경계와 의존성

아키텍처에서는 도메인 → 애플리케이션 → 어댑터 → 설정으로 계층이 구성되며, 의존성은 항상 안쪽 방향(도메인 방향)으로 향해야 한다.

하지만 시간이 지나면 잘못된 방향의 의존성이 생기기 쉽기 때문에 이를 방지하는 강제 도구들이 필요하다.

# 접근 제한자

자바에서 가장 기본적인 경계 강제 수단은 접근 제한자(visibility modifier)다.

많은 개발자가 `public`, `protected`, `private`만 알지만, `package-private`(default)은 매우 중요한 도구다.

같은 패키지 내에서만 접근을 허용하므로 응집도 있는 모듈을 구성할 수 있고, 외부에 노출도 최소화할 수 있다.

```
1   buckpal
2     └── account
3         ├── adapter
4         │   ├── in
5         │   │   └── web
6         │   │       └── AccountController
7         │   └── out
8         │       └── persistence
9         │           ├── AccountPersistenceAdapter
10        │           └── SpringDataAccountRepository
11        ├── domain
12        │   ├── Account
13        │   └── Activity
14        └── application
15            └── SendMoneyService
16            └── port
17                ├── in
18                │   └── SendMoneyUseCase
19                └── out
20                    ├── LoadAccountPort
21                    └── UpdateAccountStatePort
```

예를 들어

- AccountPersistenceAdapter, SendMoneyService는 외부에서 접근할 필요가 없기 때문에 package-private로 둘 수 있다.
- 포트 인터페이스, 도메인 엔티티 등은 계층 간 접근이 필요하므로 `public`으로 유지해야 한다.

단점도 있다. 자바는 하위 패키지를 다른 패키지로 취급하기 때문에, 계층 분리를 위해 하위 패키지를 만들면 `package-private` 제한이 무력화되고 결국 `public`으로 노출해야 하는 상황이 생긴다.

# 컴파일 후 체크

접근 제한자만으로는 의존성 규칙 위반을 컴파일 타임에 완벽히 잡아낼 수 없다. 그래서 컴파일 이후에 검사하는 도구가 필요하다. 대표적으로 `ArchUnit`이 있다.

ArchUnit은 다음과 같은 규칙을 검사할 수 있다

- 도메인 계층이 애플리케이션 계층에 의존하지 않는지
- 어댑터가 포트를 통해서만 서비스를 사용하는지

JUnit 기반으로 동작하며, 의존성 규칙을 위반하면 테스트를 실패시킨다. 간단한 API로 아키텍처 구조를 명시적으로 선언할 수 있고, 이를 자동으로 검사할 수 있다.

```java
class DependencyRuleTests {
  @Test
  void domainLayerDoesNotDependOnApplicationLayer() {
    noClasses()
      .that()
      .resideInAPackage("buckpal.domain..")
      .should()
      .dependOnClassesThat()
      .resideInAnyPackage("buckpal.application..")
      .check(new ClassFileImporter()
      .importPackages("buckpal.."));
  }
}
```

단, 오타나 리팩터링으로 테스트가 무력화될 수 있기 때문에, 정기적인 유지보수와 검증 체계가 필요하다.

# 빌드 아티팩트

아키텍처의 경계를 가장 확실하게 지키는 방법은 각 계층을 서로 다른 `모듈`로 분리하는 것이다. 

> 여기서 말하는 모듈(module)은 단순히 패키지를 나눈다는 의미가 아니라, Gradle이나 Maven 같은 빌드 도구에서 독립적으로 관리되는 코드 단위를 의미한다. 쉽게 말해, 하나의 모듈은 하나의 작은 프로젝트처럼 작동한다. 각 모듈은 자체 `build.gradle`(또는 `pom.xml`) 파일을 가지고 있고, 어떤 다른 모듈에 의존할지 명시적으로 선언해야만 사용할 수 있다.
> 

모듈을 나눈다는 건, 예를 들어 도메인, 애플리케이션, 웹 어댑터, DB 어댑터, 설정 계층을 각각 별도의 Gradle 프로젝트로 나누는 것을 의미한다. 이렇게 분리하면 각 계층이 필요 이상으로 다른 계층에 접근할 수 없게 된다. 만약 잘못된 의존성을 시도하면 컴파일 타임에 오류가 발생하므로, 사람이 실수해도 구조적으로 막을 수 있다.

예를 들어 아키텍처를 다음처럼 나눌 수 있다

- `domain` 모듈: 도메인 엔티티와 로직만 포함. 외부 의존성 없음.
- `application` 모듈: 유스케이스(service)와 포트 인터페이스 포함. domain에만 의존.
- `adapter-web`, `adapter-persistence` 모듈: 웹 요청과 DB 접근 담당. application에만 의존.
- `configuration` 모듈: 전체 애플리케이션 조립. 모든 모듈을 조합하여 실행.

이렇게 구성된 모듈 구조는 단지 코드 구조만 바꾸는 것이 아니라, 빌드 도구가 강제로 경계를 지켜주는 설계를 만들어준다.

이 방식의 주요 장점은 다음과 같다

- 실수 방지: 잘못된 방향의 의존성은 애초에 컴파일 자체가 불가능하다.
- 모듈별 테스트와 리팩터링 가능: 예를 들어 웹 계층이 깨져도, 도메인 계층은 문제없이 테스트 가능하다.
- 의존성 명시 필요: build.gradle에 어떤 모듈을 사용할지 선언해야 하므로, 우연한 참조가 차단된다.
- 협업에 유리: 각 모듈을 다른 팀이 따로 개발하거나, Git 저장소를 따로 관리하는 것도 가능하다.

하지만 단점도 있다

- 초기 설정이 복잡하다. 모듈이 늘어나면 각 모듈의 `build.gradle`이나 의존성 설정이 많아지고, 관리할 것이 많아진다.
- 초기 개발 속도가 느려질 수 있다. 기능 하나를 만들기 위해 여러 모듈에 걸쳐 코드를 나눠야 하기 때문에 처음에는 번거롭게 느껴질 수 있다.
- 그래서 이런 구조는 프로젝트 초기에 바로 적용하기보다는, 전체 아키텍처의 기본 틀이 안정된 이후에 도입하는 것이 일반적이다.

# 결론

패키지 구조 + 접근 제한자 + ArchUnit + 빌드 모듈 분리를 함께 사용하면 가장 효과적이다.

- 평소에는 패키지 구조와 접근 제한자로 아키텍처 경계를 지키고,
- 중요한 계층 규칙은 ArchUnit으로 정적 분석하고,
- 아키텍처가 어느 정도 안정되면 Gradle/Maven 모듈로 분리해서 경계를 물리적으로 강제하는 것이 좋다.
