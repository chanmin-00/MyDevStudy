웹, 애플리케이션, 도메인, 영속성 계층은 각기 다른 책임을 가지며, 하나의 유스케이스를 구현하기 위해 협력한다. 하지만 각 계층 간의 모델을 공유할지, 매핑할지에 대해서는 팀 내에서 논쟁이 많다.

- 매핑에 찬성하는 입장: 같은 모델을 사용하면 계층 간 결합이 강해진다.
- 매핑에 반대하는 입장: 매핑은 지나치게 많은 보일러플레이트를 만든다.

> 보일러플레이트(Boilerplate)는 개발에서 자주 반복되며 거의 변하지 않는 코드나 설정을 의미하며, 보통 프로젝트를 시작할 때 기본적으로 필요한 구조나 틀을 빠르게 구축하기 위해 사용됩니다. 예를 들어 HTML 문서의 기본 구조, React 앱의 초기 설정 코드, 또는 웹 서버의 기본 라우팅 코드 등이 이에 해당하며, 개발자가 매번 새로 작성하지 않고 복사하거나 템플릿화해서 사용하는 경우가 많습니다.
> 

이 장에서는 대표적인 4가지 매핑 전략을 소개하고, 언제 어떤 전략을 사용할지를 안내한다.

# 매핑하지 않기 전략

모든 계층에서 동일한 도메인 모델을 그대로 사용한다. 

![image](https://github.com/user-attachments/assets/79f8fef4-db37-42fe-9e0f-f355551a577e)


예: `Account` 객체를 웹, 애플리케이션, 영속성 계층 모두가 공유한다.

- 장점:
    - 각 계층에서 동일한 모델을 사용하므로 매핑 코드를 작성하지 않아도 되어 개발 속도가 빠르다
    - 보일러플레이트 코드가 없다. 매핑 클래스나 변환 로직이 필요 없기 때문에 코드가 간결해진다.
- 단점:
    - 도메인 모델이 직렬화(JSON), ORM 등 기술적 요구사항에 오염된다. 도메인 모델 클래스에 `@Entity`, `@JsonProperty` 같은 애너테이션이 추가되어 기술 세부사항에 노출될 수 있다.
    - 이로 인해 단일 책임 원칙을 위반하고, 과부화된 모델로 이어진다. 하나의 도메인 모델이 모든 계층의 요구사항을 감당하며 점점 무거워진다.
    - 도메인 모델의 변화가 모든 계층에 전파되어 높은 결합도를 초래한다. 예를 들어 웹에 새로운 필드를 추가하면, 애플리케이션과 영속성 계층도 해당 필드에 대해 알아야 한다.

단순한 CRUD 유스케이스나, 모든 계층이 동일한 구조와 정보를 필요로 할 때 적합하다.

> 많은 유스케이스가 처음에는 CRUD로 시작하지만 점차 비즈니스 로직이 복잡해지면서 매핑이 필요해지는 경우가 많다. 따라서 이 전략을 선택할 경우에도 전략 변경이 쉽게 가능하도록 구조를 열어두는 것이 중요하다.
> 

# 양방향 매핑 전략

각 계층이 전용 모델을 가지며, 도메인 모델과 상호 매핑한다.

![image](https://github.com/user-attachments/assets/c93e64ca-a51e-430d-8845-8bf9a5a21b95)


- 웹 계층: 웹 모델 ↔ 도메인 모델
- 영속성 계층: 영속성 모델 ↔ 도메인 모델
- 장점:
    - 각 계층의 요구사항에 맞게 최적화된 모델 구성이 가능하다. 예를 들어 웹 모델은 화면 구성에 적합하게, 영속성 모델은 DB 스키마에 적합하게 설계 가능하다.
    - 도메인 모델이 JSON/ORM 애너테이션 없이 깨끗하게 유지하다. 기술적인 의존이 제거되어 도메인 순수성이 보장된다.
- 단점:
    - 매핑 코드가 많아진다. 각 모델 간 매핑을 수동으로 구현하거나 매핑 프레임워크를 설정해야 하며, 이는 보일러플레이트 증가로 이어진다.
    - 도메인 모델이 여전히 인커밍/아웃고잉 포트 인터페이스에서 직접 사용된다. 포트 인터페이스가 도메인 객체를 인자나 반환값으로 사용하면 구조 변경 시 영향을 받기 쉽다.

유연하지만 비용이 높은 전략이다. 복잡한 도메인이나 요구사항이 상이한 계층이 존재하는 경우에 매우 유용하지만, 단순한 CRUD 유스케이스까지 이 전략을 강제하는 것은 오히려 개발 생산성을 떨어뜨릴 수 있다.

# 완전 매핑 전략

각 연산마다 별도의 입력 모델(Command) 을 정의하고, 이를 통해 도메인 모델로 매핑한다.

![image](https://github.com/user-attachments/assets/70b26f4d-ea97-43c1-bfc1-230463582759)


예: `SendMoneyCommand` → 도메인 모델 생성

웹 계층에서 JSON 입력하면, Command를 생성한 후에 유스케이스를 호출한다.

- 장점:
    - 유스케이스 경계를 명확히 한다. 하나의 커맨드는 하나의 유스케이스를 표현하므로 목적이 뚜렷하고 응집력을 높일 수 있다.
    - 입력 유효성 검증을 명확하게 구현 가능하다. 각 커맨드 객체 내부에서 필드 제약 조건이나 유효성 검증 로직을 처리할 수 있어 견고한 입력 검증이 가능하다.
    - 유연한 확장성과 유지보수가 용이하다. 유스케이스에 변화가 생겨도 해당 커맨드만 수정하면 되므로 파급 범위가 좁다.
- 단점:
    - 매핑 코드가 증가한다. 유스케이스마다 전용 커맨드를 만들어야 하고, 이를 도메인 객체로 매핑하는 코드도 필요하다.
    - 유사한 구조가 반복되며 중복이 늘어날 수 있다. 단순한 유스케이스가 많아질수록 커맨드 클래스 수가 폭증할 수 있다.

상태 변경 유스케이스에서 강력한 전략이다. 유효성 검증, 명확한 경계, 테스트 용이성 면에서 효과적이다. 

단순한 조회/쿼리 유스케이스에서는 지나치게 복잡해질 수 있으므로 과도하게 적용하지 않도록 주의해야 한다.

# 단방향 매핑 전략

모든 모델이 공통 인터페이스를 구현하여 도메인 객체의 상태를 노출하되, 행동은 숨긴다.

![image](https://github.com/user-attachments/assets/86fa02ff-e17f-421d-a118-721c3e56d89f)


각 계층에서는 상위 인터페이스만 사용하고, 실제 도메인 객체는 애플리케이션 계층에서만 직접 사용한다. DDD의 팩터리 패턴과 결합하여 특정 상태로부터 도메인 객체를 재구성한다.

- 장점:
    - 행동 숨기고, 상태만 노출한다. 외부 계층은 도메인 내부 동작에 접근할 수 없어 실수로 `withdraw()` 같은 메서드를 호출할 일이 없다.
    - 인터페이스 기반 설계로 안정성 증가한다. 계층 간 의존도가 낮아지고 필요한 정보만 노출되므로, 보안성과 유지보수성이 향상된다.
    - 읽기 전용 연산에 최적화되어 있다. 데이터 읽기만 필요한 경우 인터페이스만으로 충분하므로 도메인 객체 전체를 전달할 필요 없이 효율적인 설계가 가능하다.
    - 팩터리 패턴과의 결합이 용이하다. 애플리케이션 계층에서 전달받은 인터페이스 객체의 상태를 바탕으로 도메인 객체를 재구성할 수 있다. 이를 통해 도메인 객체의 일관성과 캡슐화를 유지하면서 외부 계층과의 경계를 명확히 할 수 있다.
- 단점:
    - 설계 복잡도 증가한다. 인터페이스, 구현 클래스, 팩터리 등 여러 컴포넌트가 필요해 구조가 복잡해지고 학습 곡선이 존재한다.
    - 코드 흐름 추적 어렵다. 외부 계층에서 전달받은 인터페이스 기반 객체가 내부에서 어떻게 구현되고 도메인 모델로 전환되는지 파악하는 데 시간이 걸릴 수 있다.

조회/읽기 중심 유스케이스에 적합하다. 도메인 행동을 숨기면서도 필요한 상태 정보만 노출해 실수나 불필요한 접근을 방지하며, 유연하고 안전한 구조를 제공한다.

# 언제 어떤 매핑 전략을 사용할 것인가?

모든 유스케이스에 동일한 전략을 강제하면 유지보수가 어렵다. 상황에 맞게 유연하게 전략을 조합해야 하며, 팀 내 공통 가이드라인 마련이 중요하다.

예:

- 변경 유스케이스
    - 웹 ↔ 앱: 완전 매핑 (명령 모델)
    - 앱 ↔ 영속성: 매핑하지 않기 → 필요 시 양방향 매핑
- 조회 유스케이스
    - 모든 계층: 매핑하지 않기 → 필요 시 양방향 매핑 또는 단방향 매핑

전략은 상황에 따라 유동적으로 선택 가능해야 하며, 하나의 전략에 고정되기보다는 각 유스케이스에 맞게 점진적으로 진화할 수 있어야 한다.

# 결론

포트는 계층 간의 모델 여과 필터 역할을 수행한다. 유스케이스마다 최적의 매핑 전략을 적용하면

- 다른 유스케이스에 영향을 주지 않고 개선 가능하.
- 유스케이스별로 모델을 정확하게 설계 가능하.
- 아키텍처가 단단해지고, 팀 생산성이 향상된다.
