auto_increment 속성이 설정된 관계형 데이터베이스의 기본 키를 사용해서 유일 ID를 생성하는 전략은 분산 환경에서 통하지 않는다. 

데이터베이스 서버 한 대로는 요구를 감당할 수 없고, 여러 데이터베이스 서버를 쓰는 경우에는 지연 시간을 낮추기가 무척 힘들다.

# 문제 이해 및 설계 범위 확정

문제의 요구사항은 다음과 같다.

- **ID는 유일해야 한다.**
- **ID는 숫자로만 구성되어야 한다.**
- **ID는 64비트로 표현될 수 있는 값이어야 한다.**
- **ID는 발급 날짜에 따라 정렬 가능해야 한다.**
- **초다 10000개의 ID를 만들 수 있어야 한다.**

# 개략적 설계안 제시 및 동의안 구하기

분산 시스템에서 유일성이 보장되는 ID를 만든 방법에는 다음과 같은 것들이 있다.

- **다중 마스터 복제(multi-master replication)**
- **UUID(Universally Unique Identifier)**
- **티켓 서버(ticket server)**
- **트위터 스노플레이크(twitter snowflake) 접근법**

# 다중 마스터 복제

<img width="383" height="188" alt="image" src="https://github.com/user-attachments/assets/0c22d22d-8d8c-4e17-b3fb-6c9c04580eca" />

이 방법은 데이터베이스의 `auto_increment` 기능을 활용한다. **하지만 ID의 값을 구할 때 1만큼 증가시켜 얻는 것이 아니라, k만큼 증가시킨다**. **k는 현재 사용 중인 데이터베이스 서버의 수다.**

위의 그림에서 ID를 만들 경우, **어떤 서버가 만들어 낼 다음 아이디는, 해당 서버가 생성한 이전 ID 값에 전체 서버의 수 2를 더한 값**이다. 데이터베이스 수를 늘리면 초당 생산 가능 ID 수도 늘릴 수 있기 때문에 규모 확장성 문제를 어느 정도 해결 할 수 있다.

### 다중 마스터 복제의 단점

1. 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다
    
    > 각 서버에 **서버 ID와 auto_increment_offset** 을 따로 설정해야 하는데, 데이터 센터가 늘어나면 설정과 관리 복잡성이 기하급수적으로 증가합니다.
    > 
    > 
    > 서울에 3대, 미국에 3대 서버가 있을 때 총 6대를 고려해야 하므로 각 서버에 offset을 정교하게 맞춰야 합니다. 서버 한 대라도 설정이 잘못되면 ID 충돌이 발생할 수 있습니다.
    > 
2. ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지도록 보장할 수 없다.
    
    > auto_increment를 `+k`씩 증가시키므로, 생성된 ID의 순서가 **실제 생성 시간 순서와 일치하지 않을 수 있습니다.**
    > 
    > 
    > 서버 A와 서버 B가 동시에 insert를 수행하면 서버 A는 ID 101을 생성했는데, 그보다 늦게 insert한 서버 B가 ID 100을 생성할 수 있습니다.
    > 
3. 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.
    
    > 서버 수(`k`)가 변하면 auto_increment 증가폭도 바꿔야 합니다. 기존에 서버 2대는 ID가 +2씩 증가하지만, 서버 3대 추가 시, 각 서버의 증가폭을 +3으로 바꿔야 합니다.
    > 
    > 
    > 문제는 이미 생성된 ID들이 +2 규칙으로 되어 있는데, 중간에 +3으로 바꾸면 ID 패턴이 깨져서 중복 위험이나 순서 꼬임이 발생할 수 있습니다.
    > 

# UUID

**UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수다.** UUID 값은 충돌 가능성이 지극히 낮다.

UUID 값은 09c93e62-50b4-468d-bf8a-c07e104bfb2와 같은 형태를 띄며, **서버 간 조율 없이 독립적으로 생성 가능하다**.

<img width="520" height="141" alt="image" src="https://github.com/user-attachments/assets/818e5bb0-83c6-429b-9706-1374e158bd1d" />


위 구조에서 각 웹 서버는 별도의 ID 생성기를 사용해 독립적으로 ID를 만들어낸다.

### UUID의 장점

- UUID를 만드는 것은 단순하다. **서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.**
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 **규모 확장이 쉽다.**

### UUID의 단점

- ID가 128비트로 길다. 문제의 요구사항은 64비트였다.
- **ID를 시간순으로 정렬할 수 없다.**
- ID에 숫자가 아닌 값이 포함될 수 있다.

# 티켓 서버

플리커(Flickr)는 분산 기본 키(`distibuted primary key`)를 만들어 내기 위해 이 기술을 사용했다.

<img width="509" height="232" alt="image" src="https://github.com/user-attachments/assets/7247f80c-1753-4ebe-b1ca-76ad4064dad6" />


이 방법은 **auto_increment 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것이다.**

### 티켓 서버의 장점

- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고, 중소 규모의 애플리케이션에 적합하다.

### 티켓 서버의 단점

- 티켓 서버가 SPOF(Single-Point-of-Failure)가 된다. 해당 서버에 장애가 발생하면, 해당 서버를 이용하는 모든 시스템이 영향을 받는다.
- 이 문제를 해결하려면 티켓 서버를 여러 대 만들어야 하지만, 이 경우 데이터 동기화 문제가 발생할 것이다.

# 트위터 스노플레이크 접근법

트위터는 스노플레이크(`snowflake`)라고 부르는 독창적인 ID 생성 기법을 사용한다. 이 방법은 이번 장의 요구사항을 만족시킨다.

<img width="640" height="117" alt="image" src="https://github.com/user-attachments/assets/4502e5b7-accc-4e80-bf3d-12aa9149058b" />


이 기법은 생성해야 하는 ID의 구조를 여러 절로 분할한다. 위 그림은 생성해야 할 64비트 ID의 구조다.

- `사인(sign) 비트` : 1비트를 할당한다. 특별한 쓰임새는 없지만 음수와 양수를 구별하는데 사용할 수 있다.
- `타임스태프` : 41비트를 할당한다. 기원 시각 이후로 몇밀리초가 경과했는지를 나타낸다.
- `데이터센터 ID` : 5비트를 할당한다. 따라서 2$^5$ = 32개의 데이터센터를 지원할 수 있다.
- `서버 ID` : 5비트를 할당한다. 데이터 센터당 32개 서버를 사용할 수 있다.
- `일련번호` : 12비트를 할당한다.각 서버에서는 ID를 생성할 때마다 일련번호를 1씩 증가시킨다. **이 값은 1밀리초가 경과될 때마다 0으로 초기화된다.**

# 상세 설계

<img width="640" height="117" alt="image" src="https://github.com/user-attachments/assets/1a52a346-7bf1-4158-b5bd-c0530f0bf0e9" />


데이터 센터 ID와 서버 ID는 시스템이 시작할 때 결정되며, 일반적으로 운영 중에는 바뀌지 않는다. 이 두 ID를 잘못 변경하게 되면 ID 충돌이 발생할 수 있으므로, 변경 작업을 할 때는 신중해야 한다.

타임스탬프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어지는 값이다.

## 타임스탬프

**타임스탬프는 시간이 흐름에 따라 점점 큰 값을 갖게 되므로, 결국 ID는 시간순으로 정렬 가능하게 된다**. 

41비트로 표현할 수 있는 타임스탬프의 최댓값은 대략 69년에 해당한다. 따라서 이 ID 생성기는 69년동안만 정상 동작한다. 기원 시각을 현재에 가깝게 맞춰놓아 오버플러가 발생하는 시점을 늦춰놓았다. 기원 시각으로부터 69년이 지나면 기원 시각을 바꾸거나 ID 체계를 이전해야 한다.

## 일련 번호

일련번호는 12비트로 4096개의 값을 가질 수 있다. 이 값은 1밀리초가 경과될 때마다 0으로 초기화 되기 때문에 **어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 일련번호를 가질 수 있다.**

# 추가 논의사항

## 시계 동기화

설계를 진행하면서 ID 생성 서버들이 전부 같은 시계를 사용한다고 가정했지만, 이 가정은 하나의 서버가 여러 코어에서 실행 될 경우 유효하지 않을 수 있다. 여러 서버가 물리적으로 독립된 여러 장비에서 실행되는 경우도 마찬가지다.

시계 동기화 문제가 존재한다는 것을 인식하고, NTP(Network Time Protocol)와 같은 해결 수단이 있음을 인식해야 한다.

## 각 절의 최적화 문제

**동시성이 낮고 수명이 긴 애플리케이션의 경우**에는 **일련번호 절의 길이를 줄이고, 타임스탬프 절의 길이를 늘리는 것이 효과적일 수 있다.**

## 고가용성

ID 생성기는 필수 불가결 컴포넌트이므로 아주 높은 고가용성을 제공해야 한다.
