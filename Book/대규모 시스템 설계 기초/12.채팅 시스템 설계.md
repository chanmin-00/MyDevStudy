# 문제 이해 및 설계 범위 확정

- 1:1 채팅 앱과 그룹 채팅 앱 둘 다 지원할 수 있어야 한다.
- 모바일 앱과 웹 앱 둘 다 지원한다.
- 일별 능동 사용자 수(DAU: Daily Active User) 기준으로 5천만명을 처리할 수 있어야 한다.
- 그룹 채팅의 경우 최대 100명까지 참가할 수 있어야 한다.
- 1:1 채팅, 그룹 채팅, 사용자 접속상태 표시를 지원해야 하고, 텍스트 메시지만 주고받을 수 있어야 한다.
- 메시지 길이는 100000자 이하여야 한다.
- 종단 간 암호화(end-to-end encryption)를 현재로서는 지원할 필요 없다.
- 채팅 이력은 영원히 보관해야 한다.

우리는 만들어야 하는 채팅 앱은 다음과 같은 기능을 갖는다.

- 응답 지연이 낮은 일대일 채팅 기능을 지원해야 한다.
- 최대 100명까지 참여할 수 있는 그룹 채팅 기능을 제공해야 한다.
- 사용자의 접속 상태 표시 기능을 제공해야 한다.
- 다양한 단말을 지원하고, 하나의 계정으로 여러 단말에 동시 접속을 지원해야 한다.
- 푸시 알림

# 개략적 설계안제시 및 동의 구하기

채팅의 경우 클라이언트는 모바일 앱이거나 웹 애플리케이션인데, 클라이언트끼리는 서로 직접 통신하지 않는다. **각 클라이언트는 나열한 모든 기능을 지원하는 채팅 서비스와 통신**한다.

채팅 시스템은 다음과 같은 기능을 제공한다.

- **클라이언트들로부터 메시지 수신**
- **메시지 수신자 결정 및 전달**
- **수신자가 접속 상태가 아닌 경우에는 접속할 때까지 메시지를 보관**한다.

<img width="550" height="138" alt="image" src="https://github.com/user-attachments/assets/9af1a868-0846-417b-8b47-7c7d33fadd1b" />


채팅 서비스를 시작하려는 클라이언트는 네트워크 통신 프로토콜을 사용해 서버에 접속한다. 대부분의 클라이언트/서버 애플리케이션과 마찬가지로 **채팅에서도 송신 클라이언트가 서버로 메시지를 보내며, 이때 오랫동안 검증된 HTTP 프로토콜이 사용**된다. 

HTTP는 현재 웹에서 가장 널리 쓰이는 프로토콜로, **keep-alive 헤더를 사용하면 연결을 끊지 않고 유지해 TCP 핸드셰이크 횟수를 줄일 수 있어 효율적**이다. 실제로 페이스북 같은 대중적 채팅 서비스도 초기에는 HTTP를 이용했다.

그러나 메시지 **수신 과정**은 더 복잡하다. **HTTP는 클라이언트가 요청해야 서버가 응답하는 구조**라, 서버가 임의 시점에 메시지를 보내기는 어렵다. 이를 해결하기 위해 폴링, 롱 폴링, 웹소켓과 같은 기술이 제안되었으며, 이들은 시스템 설계 면접에서도 자주 다뤄지는 중요한 주제다.

## 폴링

폴링은 **클라이언트가 일정 주기로 서버에 접속해 새 메시지가 있는지를 확인하는 방식**이다. 클라이언트가 “새 메시지가 있느냐”라고 계속 물어보는 구조다. 

하지만 이 방법은 폴링을 자주 할수록 비용이 증가하고, 새 메시지가 없을 때도 서버 자원이 불필요하게 낭비된다는 문제가 있다.

<img width="415" height="427" alt="image" src="https://github.com/user-attachments/assets/d4a4959c-2d11-4404-9a2a-cfb95baf2e79" />


## 롱 폴링

롱 폴링은 폴링의 비효율을 줄이기 위해 나온 방식으로, **클라이언트가 새 메시지가 도착하거나 타임아웃이 발생할 때까지 연결을 유지**한다. 메시지를 받으면 기존 연결을 종료하고 다시 서버에 요청을 보내는 식으로 절차가 반복된다. 하지만 이 방식에도 몇 가지 약점이 있다.

- 메시지를 보낸 클라이언트와 받은 클라이언트가 같은 서버에 연결되지 않을 수 있다. HTTP 서버는 보통 무상태(stateless)이기 때문에, 로드 밸런싱에 라운드 로빈을 사용하면 **메시지를 가진 서버와 실제 수신자가 연결된 서버**가 다를 수 있다.
    
    롱 폴링에서 **송신자가 붙은 서버와 수신자가 붙은 서버가 다르면**, 메시지가 한쪽 서버에만 머물러 전달되지 않을 수 있는데, 이는 HTTP 서버가 무상태(stateless)이고 로드 밸런서가 단순히 요청을 분산시키기 때문에 생기는 문제다.
    
- 서버는 클라이언트가 연결을 끊었는지 여부를 명확히 알기 어렵다.
- 또한 여전히 효율적이지 못한데, **메시지를 거의 받지 않는 클라이언트라도 타임아웃이 발생할 때마다 주기적으로 서버에 재접속**해야 하기 때문이다.

<img width="366" height="356" alt="image" src="https://github.com/user-attachments/assets/355960d0-2b17-4e7f-a1be-3f5be6344de5" />


## 웹 소켓

<img width="404" height="220" alt="image" src="https://github.com/user-attachments/assets/94fd177a-541b-444b-bbe1-0a9e4558c8f5" />


웹소켓은 서버가 클라이언트에게 **비동기적으로 메시지를 보낼 수 있도록 해주는 가장 널리 사용되는 기술**이다. 기본적으로 연결은 클라이언트가 시작하며, 처음에는 HTTP로 시작하지만 **특정한 핸드셰이크 절차를 거쳐 웹소켓으로 업그레이드**된다. 일단 업그레이드가 완료되면 **연결은 항구적으로 유지되고, 양방향 통신이 가능**해진다. 이 덕분에 **서버는 클라이언트 요청이 없어도 자유롭게 메시지**를 보낼 수 있다.

웹소켓은 **HTTP/HTTPS와 같은 기본 포트(80, 443)를 그대로 사용**하기 때문에 방화벽이 있는 환경에서도 안정적으로 동작한다는 장점이 있다. 앞서 설명한 HTTP가 메시지를 보내는 데는 충분히 괜찮은 프로토콜이었다면, 웹소켓은 그 위에 더해 수신까지 자연스럽게 처리할 수 있어 별도로 HTTP를 고집할 이유가 없어진다. 

<img width="398" height="191" alt="image" src="https://github.com/user-attachments/assets/41565de0-3d17-49ed-902b-21f9ec8ae2f8" />


또한 웹소켓을 이용하면 **메시지 송신과 수신을 동일한 프로토콜로 처리**할 수 있으므로 시스템 설계뿐 아니라 구현 측면에서도 단순하고 직관적이다. 다만 한 가지 주의할 점은, **웹소켓 연결은 항구적으로 유지되므로 서버 입장에서는 많은 연결을 효율적으로 관리할 수 있는 구조가 반드시 필요**하다는 것이다.

# 개략적 설계안

채팅 시스템의 **개략적 설계안**을 보면, 주 통신 프로토콜은 웹소켓을 사용하기로 결정했지만 모든 기능에 굳이 웹소켓을 적용할 필요는 없다. 예를 들어 회원가입, 로그인, 사용자 프로필과 같은 **대부분의 기능은 일반적인 HTTP 요청/응답 기반으로 충분히 구현**할 수 있다.

전체 시스템은 크게 세 부분으로 나눌 수 있다. 첫째는 **무상태(stateless) 서비스**, 둘째는 **상태 유지(stateful) 서비스**, 그리고 셋째는 **제3자 서비스 연동**이다.

## 무상태 서비스

무상태 서비스는 로그인, 회원가입, 사용자 프로필 표시와 같이 **전통적인 요청/응답 방식으로 처리되는 기능**들을 담당한다. 이는 일반적인 웹사이트나 앱에서도 흔히 제공하는 기본 기능에 해당한다. 이러한 **무상태 서비스들은 로드 밸런서 뒤에 배치되며, 로드 밸런서는 들어오는 요청을 적절한 서비스로 정확하게 전달**한다.

로드 밸런서 뒤의 서비스는 모놀리식 구조일 수도, 마이크로서비스 구조일 수도 있다. 실제로 이 중 많은 기능은 이미 시장에 완제품으로 제공되고 있어 직접 구현하지 않고 사서 사용할 수도 있다. 이때 중요한 구성 요소 중 하나가 **서비스 탐색(service discovery)인데, 이는 클라이언트가 접속해야 할 채팅 서버의 DNS 호스트명을 알려주는 역할**을 한다.

## 상태 유지 서비스

본 설계안에서 **상태 유지를 필요로 하는 유일한 서비스는 채팅 서비스**다. **각 클라이언트는 채팅 서버와 독립적인 네트워크 연결을 지속적으로 유지**해야 하며, 서버가 정상적으로 동작하는 동안에는 다른 서버로 연결을 바꾸지 않는다. 이 과정에서 앞서 언급한 **서비스 탐색**이 중요한 역할을 하며, 채팅 서버에 특정 클라이언트가 과도하게 몰리지 않도록 연결을 적절히 분산시킨다.

## 제3자 서비스 연동

채팅 앱에서 가장 중요한 **제3자 서비스는 푸시 알림**이다. 사용자가 새 메시지를 받으면 앱이 실행 중이지 않더라도 알림을 받아야 하기 때문에, 푸시 알림 서비스와의 통합은 핵심 요소라 할 수 있다.

## 규모 확장성

트래픽이 많지 않을 때는 지금까지 설명한 모든 기능을 **서버 한 대로도 구현**할 수 있다. 이론적으로는 대량의 트래픽을 처리해야 하는 경우에도 최신 클라우드 서버 한 대라면 모든 사용자의 연결을 감당할 수도 있다. 

예를 들어 동시 접속자가 100만 명이고, 접속당 10KB 메모리가 필요하다고 가정하면 10GB 메모리만으로도 처리가 가능하다. 하지만 누구도 실제로 서버 한 대에 모든 것을 담으려 하지 않기 때문이다. **단일 장애 지점(SPOF)** 문제 같은 이유도 그중 하나다.

<img width="495" height="462" alt="image" src="https://github.com/user-attachments/assets/d487b0bf-d17f-4784-8ad6-3bbfaac75aa7" />


개략적 설계안을 보면, 실시간 메시지를 주고받기 위해 클라이언트는 **채팅 서버와 웹소켓 연결을 끊지 않고 유지**한다. 여기서 각 컴포넌트의 역할은 다음과 같다.

- `채팅 서버`: 클라이언트 사이에서 메시지를 중계한다.
- `접속 상태 서버(Presence Server)`: 사용자의 접속 여부를 관리한다.
- `API 서버`: 로그인, 회원가입, 프로필 변경 등 나머지 기능을 담당한다.
- `알림 서버`: 푸시 알림을 발송한다.
- `키-값 저장소(Key-Value Store)`: 채팅 이력을 보관하여, 사용자가 접속하면 이전 대화 내용을 모두 확인할 수 있게 한다.

## 저장소

이제 서버와 제3자 서비스 연동이 준비되었다면, 남은 중요한 과제는 **데이터 계층 설계**다. 여기서 핵심은 **어떤 데이터베이스를 쓸지, 즉 관계형 데이터베이스를 선택할 것인지 NoSQL을 선택**할 것인지다. 올바른 판단을 위해서는 **데이터의 유형과 읽기/쓰기 패턴을 먼저 고려**해야 한다.

채팅 시스템이 다루는 데이터는 크게 두 가지다. 

- 첫째, **사용자 프로필, 설정. 친구 목록과 같은 일반적인 데이터**다. 이런 데이터는 안정성이 보장되는 관계형 데이터베이스에 저장하며, **복제(replication)**와 **샤딩(sharding)** 같은 기술을 활용해 가용성과 확장성을 높인다.
- 둘째, 채팅 시스템 고유의 데이터인 **채팅 이력(chat history)**이다. 이 데이터를 보관하려면 특유의 접근 패턴을 이해해야 한다.

채팅 이력은 방대한 양을 차지하며, 실제로 페이스북 메신저나 왓츠앱은 매일 600억 건의 메시지를 처리한다. 자주 활용되는 것은 주로 최근 메시지이며, 오래된 메시지는 거의 열람되지 않는다. 

그러나 검색 기능, 특정 사용자 언급, 특정 메시지로 점프하기 같은 기능 때문에 무작위 접근(random access)도 지원해야 한다. 1:1 채팅의 경우 읽기와 쓰기 비율은 대략 1:1에 가깝다.

이러한 특성을 모두 만족시키려면 어떤 데이터베이스를 쓰느냐가 매우 중요하다. 설계안에서는 **키-값 저장소**를 추천한다. 그 이유는 다음과 같다.

- 수평적 확장(horizontal scaling)이 용이하다.
- 데이터 접근 지연(latency)이 낮다.
- 관계형 데이터베이스는 인덱스가 커지면 무작위 접근 처리 비용이 급격히 늘어나, 롱테일(long-tail) 데이터 처리에 약하다.
- 이미 많은 안정적인 채팅 시스템들이 키-값 저장소를 채택하고 있다. 예를 들어, 페이스북 메신저는 **HBase**, 디스코드는 **Cassandra**를 사용한다.

## 데이터 모델

채팅 데이터는 키-값 저장소에 보관하기로 했고, 이제 구체 스키마와 message_id 설계가 핵심이다.

### 1:1 채팅을 위한 메시지 테이블

<img width="235" height="186" alt="image" src="https://github.com/user-attachments/assets/e048ffbd-5008-4d6e-a465-4e20b4019158" />


기본키는 message_id. 메시지 순서를 결정하는 역할도 맡는다. created_at만으로는 동시 생성(타임스탬프 충돌) 때문에 정확한 순서 보장이 어렵다.

### 그룹 채팅을 위한 메시지 테이블

<img width="228" height="189" alt="image" src="https://github.com/user-attachments/assets/f2391b7d-baa7-4727-86fb-9a62ba2a7926" />


기본키는 **복합키** (channel_id, message_id). 여기서 channel_id는 파티션 키로도 쓰인다. 그룹 채팅에 대한 모든 조회는 특정 채널을 대상으로 하므로 이 구조가 맞다.

### 메시지 ID

요구사항은 두 가지이다. **고유성**(uniqueness)과 **정렬 가능성/시간 순서 일치**(새 ID가 이전 ID보다 커야 함)이다.

RDBMS라면 auto_increment가 대안이 될 수 있으나, 일반적인 NoSQL에는 해당 기능이 없다.

- **전역 64비트 시퀀스**(예: 스노우플레이크 스타일)를 써서 정렬 가능한 ID를 만들 수 있다.
- **로컬 시퀀스 생성기**(채널/1:1 세션 단위 고유성 보장)도 방법이다. 메시지의 순서는 같은 채널(또는 같은 1:1 세션) 안에서만 유지되면 충분하므로, 전역 ID보다 구현이 단순하다.

# 상세 설계

## 서비스 탐색

서비스 탐색 기능의 핵심 역할은 **클라이언트에게 가장 적합한 채팅 서버를 추천하는 것**이다. 이때 고려되는 기준은 클라이언트의 지리적 위치나 서버의 용량 같은 요소들이다.

구현을 위해 흔히 사용하는 오픈 소스 솔루션으로는 **Apache Zookeeper**가 있다. 모든 채팅 서버를 서비스 탐색 기능에 등록해 두고, 클라이언트가 접속을 시도하면 정해둔 기준에 따라 최적의 서버를 선택해 반환하는 방식이다.

<img width="429" height="421" alt="image" src="https://github.com/user-attachments/assets/182bc2c3-d87e-4c86-a009-c5d98066cfd5" />


1. 사용자 A가 시스템에 로그인한다.
2. 로드 밸런서는 로그인 요청을 여러 API 서버 중 하나로 전달한다.
3. API 서버가 사용자 인증을 처리한 뒤, 서비스 탐색 기능을 동작시켜 사용자 A에게 가장 적합한 채팅 서버를 찾는다. 이 경우 선택된 서버는 **채팅 서버 2**다.
4. 사용자 A는 채팅 서버 2와 웹소켓 연결을 맺고 이후 메시지를 주고받는다.

즉, 서비스 탐색은 로그인 과정과 긴밀하게 연결되어 클라이언트가 **최적의 서버에 안정적으로 접속**하도록 해 주는 중요한 기능이다.

## 메시지 흐름

### 1:1 채팅 메시지 처리 흐름

<img width="416" height="364" alt="image" src="https://github.com/user-attachments/assets/0ecf19f2-1466-4c2b-9d79-23da06c74812" />


1. 사용자 A가 채팅 서버 1에 메시지를 전송한다.
2. 채팅 서버 1은 ID 생성기를 통해 메시지의 고유 ID를 만든다.
3. 메시지는 메시지 동기화 큐로 전송된다.
4. 이후 키-값 저장소에 저장된다.
5. 수신자 B가 접속 중이라면, 메시지는 B가 연결된 채팅 서버(이 예에서는 서버 2)로 전달된다. 접속 중이 아니라면 푸시 알림 서버를 통해 알림이 전송된다.
6. 채팅 서버 2는 웹소켓 연결을 통해 사용자 B에게 메시지를 전송한다.

### 여러 단말 사이의 메시지 동기화

<img width="446" height="287" alt="image" src="https://github.com/user-attachments/assets/2cb02c91-9259-48f3-b1cd-0b53214aa8e0" />


사용자가 여러 기기(예: 스마트폰, 노트북)를 동시에 사용한다면, **각 단말은 채팅 서버와 별도의 웹소켓 연결을 맺는다**

- 각 단말은 cur_max_message_id라는 변수를 유지한다. 이는 **해당 단말에서 확인한 가장 최신 메시지 ID를 의미**한다.
- 새로운 메시지로 간주되는 조건은 두 가지다:
    1. 메시지의 수신자 ID가 현재 로그인한 사용자 ID와 일치할 것
    2. 메시지 ID가 단말의 cur_max_message_id보다 클 것
- **단말마다 cur_max_message_id를 별도로 관리**하므로, **키-값 저장소에서 동기화 작업을 수행하기 쉽다.**

### 소규모 그룹 채팅에서의 메시지 흐름

<img width="340" height="312" alt="image" src="https://github.com/user-attachments/assets/6316a1af-f880-412f-bed8-10664722c7d8" />

그룹 채팅은 1:1보다 조금 더 복잡하다. 예를 들어 그룹에 사용자 A, B, C가 있다고 하자. A가 메시지를 보내면, 그 메시지는 B와 C 각각의 메시지 동기화 큐(message sync queue)에 복사된다. 즉, 각 수신자별로 개인 수신함이 따로 있다고 볼 수 있다.

이 방식은 **소규모 그룹**에 적합하다. 이유는 다음과 같다.

- 수신자는 자신의 큐만 확인하면 되므로 메시지 동기화 흐름이 단순하다.
- 그룹이 크지 않다면 메시지를 사용자별로 복사해 큐에 넣는 비용도 크게 문제 되지 않는다.

실제로 위챗(WeChat)이 이 방식을 사용하며, 그룹 크기를 최대 500명으로 제한하고 있다. 하지만 **대규모 그룹 채팅**에서는 동일한 메시지를 모든 사용자 큐에 복사하는 것이 비효율적이다. 이 경우에는 다른 설계 방식이 필요하다.

<img width="383" height="245" alt="image" src="https://github.com/user-attachments/assets/4a5c8a46-3564-4f5d-966a-bded13dfbc20" />


## 접속 상태 표시

사용자의 접속 상태를 표시하는 기능은 많은 채팅 애플리케이션에서 핵심이다. 흔히 프로필 사진 옆의 녹색 점으로 온라인 여부를 확인할 수 있는데, 이를 구현하려면 별도의 **접속 상태 서버(presence server)** 가 필요하다. 이 서버는 실시간 서비스의 일부로 클라이언트와 웹소켓으로 연결된다.

### **로그인과 로그아웃**

사용자가 로그인하면 클라이언트와 서버 사이에 웹소켓 연결이 맺어진다. 접속 상태 서버는 해당 사용자의 상태를 **online**으로 설정하고 last_active_at 타임스탬프를 키-값 저장소에 기록한다.

로그아웃 시에는 저장소에 있던 상태 값이 **offline**으로 바뀌고, UI에서도 접속 중이 아님이 표시된다.

<img width="564" height="145" alt="image" src="https://github.com/user-attachments/assets/079736e4-37c2-45e1-afec-4c25750776b8" />


### **접속 장애와 하트비트(heartbeat)**

네트워크 연결은 항상 안정적이지 않기 때문에, 단순히 연결이 끊겼다고 바로 offline으로 처리하는 것은 사용자 경험에 좋지 않다. 예를 들어 차를 타고 터널을 지날 때 잠깐 연결이 끊겼다가 금세 복구되는 상황이 흔하다.

이를 해결하기 위해 접속 상태 서버는 **하트비트 검사**를 사용한다. 클라이언트는 일정 주기(예: 5초)마다 하트비트 이벤트를 보낸다. 서버가 마지막 하트비트를 받은 지 일정 시간(예: 30초)을 초과하면 비로소 해당 사용자를 offline으로 처리한다.

### **상태 정보의 전송**

사용자의 상태 변화가 있으면, 그 사실은 친구들에게도 전파되어야 한다. 접속 상태 서버는 **발행-구독(pub-sub) 모델**을 사용한다. 예를 들어 사용자 A의 상태가 바뀌면, A와 연결된 친구 관계(AB, AC, AD 같은 채널)에 상태 변경 이벤트를 기록하고, 각각 B, C, D가 이를 구독해 알림을 받는다. 이 방식은 실시간 웹소켓 연결을 통해 동작한다.

이 접근법은 **소규모 그룹**이나 친구 관계 기반에서는 효과적이다. 실제로 위챗(WeChat)은 그룹 크기를 500명으로 제한하고 있어 이런 모델을 활용할 수 있었다. 하지만 그룹 규모가 수십만 명에 달하면, 상태 변화 한 건마다 동일한 수의 이벤트가 발생하므로 성능 문제가 커진다. 이 경우에는 그룹에 입장할 때만 상태 정보를 갱신하거나, 사용자가 직접 친구의 상태를 **수동으로 조회**하도록 유도하는 방식이 대안이 된다.

<img width="480" height="265" alt="image" src="https://github.com/user-attachments/assets/4b166aa6-348d-4e2e-8d94-4ed232cae411" />


# 마무리

추가로 논의할 만한 주제로는 사진, 영상 등 **미디어 지원** 방식(압축, 클라우드 저장, 썸네일), **종단 간 암호화**, **클라이언트 캐시 활용**, **로딩 속도 개선(지역 분산)**, 그리고 **오류 처리**가 있다. 오류 처리에는 서버 장애 시 서비스 탐색을 통한 자동 재접속, 메시지 재전송을 위한 재시도·큐 기법 등이 포함된다.
