# 뉴스 피드

**뉴스피드는 사용자의 홈페이지 중앙에 지속적으로 업데이트되는 스토리**들로, 상태 업데이트, 사진, 동영상, 링크, 앱 활동(app activity), 그리고 사용자가 팔로우하는 사람, 페이지, 그룹에서 발생하는 좋아요(likes)등을 포함한다.

즉 뉴스피드는 다양한 활동과 콘텐츠를 모아 사용자에게 제공하는 **실시간 정보 스트림**이다.

# 문제 이해 및 설계 범위 확정

- 모바일 앱과 웹 모두 지원해야 한다.
- 사용자가 뉴스피드 페이지에 새로운 스토리를 올릴 수 있어야 하고, 사용자는 친구들이 올린 스토리를 볼 수 있어야 한다.
- 피드 정렬은 단순히 시간 역순(Reverse Chronological Order) 으로 표시한다.
- 한 명의 사용자는 최대 5,000명의 친구를 가질 수 있다.
- 트래픽 규모는 하루 1,000만 명(10 million DAU, Daily Active Users)이 방문한다고 가정한다.
- 스토리에는 텍스트 외에도 이미지, 비디오 등 미디어 파일을 포함할 수 있다.

# 개략적 설계안 제시 및 동의 구하기

이번에 살펴볼 뉴스피드 시스템 설계는 두 가지로 나뉜다.

1. **피드 발행(Feed Publishing)**: 사용자가 새로운 스토리를 포스팅할 때 동작하는 과정.
2. **뉴스피드 생성(News Feed Building)**: 친구들의 포스팅을 모아 사용자에게 보여주는 과정.

**피드 발행은 포스팅을 데이터베이스와 캐시에 기록**하고, 이를 **친구들의 뉴스피드에 전송하는 흐름**을 가진다. 반면 뉴스피드 생성은 **모든 친구들의 포스팅을 시간 역순(reverse chronological order)으로 모아 피드를 구성**하는 방식이다.

## 뉴스 피드 API

**뉴스피드 API는 클라이언트가 서버와 통신하기 위한 수단**이다. HTTP 기반 프로토콜을 사용하며, 상태 정보 업데이트, 뉴스피드 조회, 친구 추가 등 다양한 작업을 수행한다. 

이 가운데 가장 중요한 두 가지 API는 **피드 발행 API**와 **피드 읽기 API**다.

### 피드 발행 API

- 새로운 스토리를 포스팅할 때 사용된다.
- POST /v1/me/feed 형식으로 호출하며, 본문(body)에는 **포스팅 내용**이 담기고, **인증을 위해 Authorization 헤더**가 필요하다.

### 피드 읽기 API

- 사용자의 뉴스피드를 가져올 때 사용된다.
- GET /v1/me/feed 형식이며, Authorization 헤더를 통해 인증한다.

## 피드 발행

피드 발행 시스템은 사용자가 앱이나 웹 브라우저에서 **POST /v1/me/feed API를 호출하는 순간부터 시작된다.** 요청에는 새 포스팅의 내용과 인증 토큰이 포함된다.

<img width="338" height="488" alt="image" src="https://github.com/user-attachments/assets/fce07eb0-9d92-4d5e-9aa8-6d39450ee1ca" />

흐름은 다음과 같다. **저장 → 전파 → 알림**까지 이어지는 전체 사이클을 포함한다.

- **로드 밸런서**: 들어오는 트래픽을 여러 웹 서버로 분산한다.
- **웹 서버**: 클라이언트 요청을 내부 서비스로 중계한다.
- **포스팅 저장 서비스(post service)**: 새로운 포스팅을 데이터베이스와 캐시에 기록한다.
- **포스팅 전송 서비스(fanout service)**: 새 포스팅을 **사용자의 친구 뉴스피드 캐시에 푸시하여 빠르게 조회할 수 있도록 한다.**
- **알림 서비스(Notification Service)**: 친구들에게 새 포스팅이 올라왔음을 알리고, 필요할 경우 푸시 알림을 보낸다.

## 뉴스 피드 생성

뉴스피드 생성 과정은 사용자가 자신의 피드를 조회할 때 시작된다. 이때 GET /v1/me/feed API가 사용된다.

<img width="310" height="533" alt="image" src="https://github.com/user-attachments/assets/ef06de46-5277-4346-a9cf-8f6dab183ff3" />

요청이 들어오면 로드 밸런서를 거쳐 웹 서버에 도착하고, 다시 News Feed Service로 전달된다.

- 뉴스 피드 서비스는 캐시에서 사용자의 뉴스피드 데이터를 불러온다.
- 뉴스 피드 캐시에는 뉴스 피드를 렌더링할 때 필요한 피드 ID를 보관한다.

# 상세 설계

## 피드 발행 흐름 상세 설계

### 웹 서버

웹 서버는 단순히 클라이언트와 통신하는 역할을 넘어, **인증과 처리율 제한 같은 중요한 기능도 담당한다.**

- 올바른 Authorization 토큰을 가진 사용자만 포스팅을 할 수 있도록 제한해야 한다.
- 또한 스팸성 글이나 유해한 콘텐츠가 과도하게 올라오지 않도록, **일정 기간 동안 사용자가 올릴 수 있는 포스팅 수에 제한을 두는 기능도 필요**하다.

### 포스팅 전송(팬아웃) 서비스

포스팅 전송은 **특정 사용자의 새 포스팅을 친구 관계에 있는 모든 사용자에게 전달하는 과정**이다. 이때 두 가지 모델이 존재한다.

1. **쓰기 시점 Fanout (fanout-on-write, push 모델)**
    - 새로운 포스팅이 작성되면 **즉시 친구들의 뉴스피드 캐시에 해당 포스팅을 기록**한다.
    - **장점**
        - 뉴스피드가 실시간으로 갱신되고, 사용자에게 즉시 전달된다.
        - **사전에 피드가 구성되므로 읽기 속도가 빠르다.**
    - **단점**
        - 친구 수가 많은 사용자의 경우, 모든 친구 피드를 갱신하는 데 큰 자원이 소모된다(핫키 문제).
        - 서비스를 자주 이용하지 않는 사용자에게도 불필요하게 업데이트가 수행되어 자원 낭비가 발생한다.
2. **읽기 시점 Fanout (fanout-on-read, pull 모델)**
    - 사용자가 뉴스피드를 읽는 순간 새로운 포스팅을 불러온다. 따라서 요청 기반 모델이다. 타임라인을 로딩하는 시점에 새로운 포스트를 가져오게 된다.
    - **장점**
        - 비활성 사용자에게 자원이 낭비되지 않는다. 로그인하기 까지는 어떤 컴퓨팅 자원도 소모되지 않는다.
        - 모든 친구에게 데이터를 푸시하지 않으므로 핫키 문제도 발생하지 않는다.
    - **단점**
        - 읽기 시점에 연산이 몰려 뉴스피드를 불러오는 데 시간이 오래 걸릴 수 있다.

설계 전략은 두 방식을 절충한다.

- 대부분의 사용자에 대해서는 푸시(push) 모델을 적용해 빠른 응답을 제공한다.
- **하지만 팔로워가 지나치게 많은 사용자의 경우에는 풀(pull) 모델을 적용하여 시스템 부하를 줄인다.**
- 여기에 **안정 해싱(consistent hashing) 기법을 더해 요청과 데이터를 균등하게 분산**시킴으로써 핫키 문제를 완화한다.

팬아웃 서비스는 다음과 같이 동작한다.

<img width="401" height="400" alt="image" src="https://github.com/user-attachments/assets/999e6b51-be71-4f63-9e7b-1c00bbe26cc3" />


1. 그래프 데이터베이스에서 친구 ID 목록을 가져온다. (그래프 DB는 친구 관계 및 추천 관리에 적합하다.)
2. **사용자 정보 캐시**에서 친구들의 정보를 불러온 뒤, 사용자 설정에 따라 특정 친구의 포스팅을 걸러낸다. (예: mute 기능, 일부 사용자에게만 공개하는 제한 설정 등)
3. 가져온 친구 목록과 새 포스팅 ID를 **메시지 큐**에 넣는다.
4. **팬아웃 작업 서버**가 메시지 큐에서 데이터를 읽어, <포스팅 ID, 사용자 ID> 쌍을 **뉴스피드 캐시**에 기록한다.
    - **이 캐시는 단순히 ID 매핑 테이블 형태로 구성되며, 모든 상세 데이터는 저장하지 않는다.** 사용자 정보와 포스팅 정보 전부를 이 테이블에 저장하지 않는 이유는, 메모리 요구량이 지나치게 증가할 수 있기 때문이다.
    - 메모리 효율성을 위해 캐시 크기에는 제한을 두며, 대부분의 사용자가 실제로 확인하는 것은 최신 스토리이기 때문에 cache miss 확률은 낮다.
    
    <img width="297" height="276" alt="image" src="https://github.com/user-attachments/assets/d79a29cf-8ecb-41f4-95e6-32aaf4a064cb" />
    

## **피드 읽기 흐름 상세 설계**

피드 읽기 과정은 사용자가 /v1/me/feed API를 호출하면서 시작된다.

<img width="473" height="456" alt="image" src="https://github.com/user-attachments/assets/580d270d-989a-4ff2-8bd9-8b6e57267bb4" />


1. 사용자가 피드 조회 요청을 보낸다.
2. 로드 밸런서가 요청을 여러 웹 서버 중 하나로 분산한다.
3. 웹 서버는 내부의 뉴스피드 서비스를 호출한다.
4. 뉴스피드 서비스는 뉴스피드 캐시에서 포스팅 ID 목록을 가져온다.
5. 필요한 상세 데이터(사용자 이름, 프로필 사진, 포스팅 내용, 이미지 등)는 사용자 캐시와 포스팅 캐시에서 불러온다.
6. 완성된 뉴스피드는 JSON 형태로 변환되어 클라이언트에 전달되며, 클라이언트는 이를 렌더링한다.

이미지나 비디오 같은 대용량 콘텐츠는 **CDN**에 저장해두고, 빠른 전송과 조회가 가능하도록 한다.

## 캐시 구조

캐시는 뉴스피드 시스템의 핵심이며, 본 설계에서는 다섯 계층으로 구분된다.

<img width="508" height="273" alt="image" src="https://github.com/user-attachments/assets/acf6bb05-9fd8-4cec-a91e-640c40a25d35" />

- `뉴스피드 캐시`: 뉴스피드의 ID를 저장한다.
- `콘텐츠 캐시`: 포스팅 데이터(본문, 미디어 등)를 저장한다. 인기 콘텐츠는 별도 관리한다.
- `소셜 그래프 캐시`: 사용자 간 관계 정보를 저장한다.
- `행동(Action) 캐시`: 좋아요, 댓글 등 포스팅에 대한 사용자 행동 데이터를 보관한다.
- 카운터(Cache Counter): 좋아요 수, 댓글 수, 팔로워 수, 팔로잉 수 등 통계성 데이터를 관리한다.

이 다층 캐시 구조 덕분에, 뉴스피드 조회 시 필요한 정보가 각 계층에서 빠르게 결합될 수 있다.
