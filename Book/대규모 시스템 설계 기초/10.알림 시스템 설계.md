# 알림 시스템

**알림 시스템을 갖춘 애플리케이션 프로그램은 최신 뉴스, 제품 업데이트, 이벤트, 선물 등 고객에게 중요할 만한 정보를 비동기적으로 제공**한다. 알림 시스템은 모바일 푸시 알림, SMS 메시지, 그리고 이메일의 세 가지로 분류할 수 있다.

# 문제 이해 및 설계 범위 확정

하루에 백만 건 이상의 알림을 처리하는 확장성 높은 시스템을 구축하는 것은 쉽지 않기 때문에, 알림 시스템이 어떻게 구현되는지에 대한 깊은 이해가 필요하다.

### 문제 요구사항

- 푸시 알림, SMS 메시지, 이메일의 알림을 지원해야 한다.
- 연성 실시간(Soft real-time) 시스템을 지원해야 한다. 가능한 한 빨리 전달해야 하나, **시스템 부하 시 약간의 지연을 허용**한다.
- iOS 단말, 안드로이드(Android) 단말, 웹/데스크톱을 지원해야 한다.
- 알림 생성 주체는 클라이언트 애플리케이션, 서버 측 스케줄링에 의해서 발생한다.
- 알림 수신 거부(Opt-out)가 가능하다.
- (모바일 푸시: 1,000,000건), (SMS: 1,000,000건), (이메일: 5,000,000건)의 하루 전송량 제한이 있다.

# 개략적 설계안 제시 및 동의안 구하기

## 알림 유형별 지원 방안

### ios 푸시 알림

ios에서 푸시 알림으 보내기 위해서는 세 가지 컴포넌트가 필요하다.

1. 알림 제공자 : 알림 요청을 만들어 애플 푸시 알림 서비스(APNS: Apple Push Notificaton Service)로 보내는 주체다. 알림 요청을 만들기 위해서는 다음과 같은 데이터가 필요하다.
    - 단말 토큰(device token): 알림 요청을 보내는 데 필요한 고유 식별자다.
    - 페이로드: 알림 내용을 담은 JSON 딕셔너리다.
        
        ```json
        {
            "aps": {
                "alert": {
                    "title": "Game Request",
                    "body": "Bob wants to play chess",
                    "action-loc-key": "PLAY"
                },
                "badge": 5
            }
        }
        ```
        

1. APNS: 애플이 제공하는 원격 서비스다. 푸시 알림을 iOS 장치로 보내는 역할을 한다.
2. iOS 단말: 푸시 알림을 수신하는 사용자 단말이다.

### 안드로이드 푸시 알림

안드로이드 푸시 알림은 APNS 대신 FCM(Firebase Cloud Messaging)을 사용한다는 점만 다르다.

### SMS 메시지

SMS 메시지를 보낼 때는 보통 트윌리오, 넥스모 같은 제 3사업자의 서비스를 많이 이용한다. 대부분 상용 서비스라서 이용 요금을 내야 한다.

### 이메일

대부분의 회사는 고유 이메일 서버를 구축할 역량은 갖추고 있지만, 많은 회사가 상용 이메일 서비스를 이용한다. 유명한 서비스로 센드그리드, 메일침프가 있다. 전송 성공률도 높고, 데이터 분석 서비스도 제공한다.

<img width="229" height="348" alt="image" src="https://github.com/user-attachments/assets/e6a936c7-b119-408c-8f2e-d1de3061753c" />


## 연락처 정보 수집 절차

사용자가 앱을 설치하거나 계정을 등록하면 API 서버는 해당 사용자의 정보를 수집하여 데이터베이스에 저장한다.

<img width="471" height="130" alt="image" src="https://github.com/user-attachments/assets/e8859471-e4b1-4d45-adad-def851861aa9" />


데이터베이스 연락처 정보를 저장할 테이블 구조는 다음과 같이 이루어진다.

<img width="499" height="179" alt="image" src="https://github.com/user-attachments/assets/a9421850-d582-413c-bf42-bf5873f8f373" />


- 이메일 주소와 전화번호는 user 테이블, 단말 토큰은 device 테이블에 저장한다.
- 한 사용자가 여러 단말을 가질 수 있고, 알림은 모든 단말에 전송되어야 한다는 점을 고려한다.

## 알림 전송 및 수신 절차

### 개략적인 설계안(초안)

<img width="420" height="315" alt="image" src="https://github.com/user-attachments/assets/a14b64d7-5ab0-45ad-a141-206418c6b93a" />


초기 설계안은 **서비스(1~N)**, **알림 시스템**, **제3자 서비스**, **단말(iOS/Android/SMS/Email)**로 구성된다.

- 서비스(1~N)는 마이크로서비스, 크론잡, 분산 시스템 등으로, 예를 들어 과금 서비스나 쇼핑몰 배송 알림 서비스가 해당된다.
- 알림 시스템은 핵심으로, 각 **서비스에 알림을 전송하는 API를 제공**하고 **제3자 서비스에 전달할 페이로드**를 생성한다. 현재는 단일 서버만 사용한다고 가정한다.
- 제3자 서비스는 실제 알림을 사용자에게 전달한다. **확장성(extensibility)이 중요**하다. 쉽게 새로운 서비스를 통합하거나, 기존 서비스를 제거할 수 있어야 한다.
    - 시장에 따라 사용 불가한 서비스가 있을 수 있다(예: 중국에서 FCM 불가 → 제이푸시, Pushy 사용 필요).
- 사용자는 모바일 단말이나 이메일로 알림을 수신한다.

그러나 이 설계에는 다음과 같은 문제점이 존재한다.

1. **SPOF(단일 장애 지점)**: 알림 서버가 하나뿐이라 장애 시 전체 서비스가 중단된다.
2. **확장성 부족**: 모든 알림 처리를 한 서버가 담당해 DB, 캐시 등 주요 컴포넌트를 개별적으로 확장할 수 없다.
3. **성능 병목**: 알림 생성, 전송 과정은 자원 소모가 크고 응답 대기 시간이 길어질 수 있어, 트래픽 집중 시 과부하가 발생할 가능성이 크다.

### 개략적 설계안 (개선된 버전)

초안의 문제점(SPOF, 확장성 부족, 성능 병목)을 해결하기 위해 다음과 같은 개선책을 적용한다.

1. **DB와 캐시를 알림 서버에서 분리**하여 독립적으로 확장 가능하게 만든다.
2. **알림 서버를 다수 운영**하고 자동 수평 확장(오토스케일링)을 지원한다.
3. 메시지 큐(Message Queue)를 도입하여 컴포넌트 간 결합도를 낮추고, **대량 전송 시 버퍼 역할을 하게 한다.**

<img width="523" height="331" alt="image" src="https://github.com/user-attachments/assets/ecb33042-4644-452d-9433-a0f8e989a669" />

- **서비스(1~N)**: 기존과 동일하게 알림을 요청하는 서비스들(마이크로서비스, 크론잡 등).
- **알림 서버**: 핵심 역할을 담당하며 다음 기능을 포함한다.
    - 알림 전송 API (내부 서비스 또는 인증된 클라이언트만 사용 가능)
    - 알림 검증 (이메일 주소, 전화번호 등)
    - DB/캐시 조회 (알림에 필요한 사용자 정보, 템플릿, 설정 값 등 데이터를 가져온다)
    - 알림 생성 후 **메시지 큐에 이벤트를 등록**한다. 하나 이상의 메시지 큐를 사용하므로 알림을 병렬적으로 처리할 수 있다.
- **캐시(Cache)**: 사용자 정보, 단말 정보, 알림 템플릿 등을 저장해 빠르게 접근한다.
- **데이터베이스(DB)**: 사용자, 알림 이력, 환경설정 등 주요 데이터 저장한다.
- **메시지 큐(Message Queue)**: 알림 종류별 큐 분리(iOS Push, Android Push, SMS 등).
    - 특정 제3자 서비스 장애 시에도 다른 큐는 정상 동작한다.
    - 시스템 컴포넌트 간의 의존성을 제거하기 위해 사용한다.
- **작업 서버(Worker)**: **큐에서 알림 이벤트를 꺼내 제3자 서비스로 전달한다.**
- **제3자 서비스(Third-party Services)**: FCM, APNs, SMS 게이트웨이, 이메일 서비스 등.
- **단말(iOS, Android, SMS, Email)**: 최종적으로 사용자가 알림을 수신

개선안을 통한 알람 처리 흐름은 다음과 같다.

1. 서비스가 알림 서버 API를 호출한다.
    
    ```json
    {
      "to": [
        {
          "user_id": 123456
        }
      ],
      "from": {
        "email": "from_address@example.com",
        "subject": "Hello, World!"
      },
      "content": [
        {
          "type": "text/plain",
          "value": "Hello, World!"
        }
      ]
    }
    ```
    
2. 알림 서버는 DB/캐시에서 사용자 정보. 단말 토큰, 알림 설정 등 메타데이터를 조회한다.
3. 알림 서버는 알림 이벤트를 생성하여 해당 종류의 메시지 큐에 넣는다.
4. 작업 서버가 큐에서 이벤트를 꺼낸다.
5. 작업 서버가 제3자 서비스에 알림을 전달한다.
6. 제3자 서비스가 사용자 단말로 알림을 전송한다.

# 상세 설계

## 안정성

### 데이터 손실 방지

알림 시스템에서 가장 중요한 요구사항 중 하나는 **알림이 어떤 상황에서도 사라지면 안 된다는 점**이다. 지연이나 순서 꼬임은 허용할 수 있지만, 알림 자체가 소실되는 것은 치명적이다. 

<img width="469" height="270" alt="image" src="https://github.com/user-attachments/assets/56db713a-88c2-4a28-99c6-c08f396728bb" />


이를 위해 **알림 로그 데이터베이스**를 유지하고, **실패한 알림은 재시도 전용 큐에 넣어 다시 발송하는 메커니즘**이 필요하다. 이렇게 하면 외부 서비스 장애나 일시적 오류가 발생하더라도 알림이 끝내 사용자에게 도달하도록 보장할 수 있다.

### 알림 중복 전송 방지

**분산 환경에서는 알림이 중복되어 전송되는 상황을 완전히 피할 수 없다.** 다만 **이벤트 ID를 기반으로 이전에 처리한 이벤트인지 확인하는 방식을 통해 불필요한 중복을 줄일 수 있다.** 

새로운 이벤트라면 발송하고, 이미 처리된 이벤트라면 버리는 식이다. 이를 통해 사용자에게 같은 알림이 반복적으로 가는 빈도를 최소화할 수 있다.

## 추가로 필요한 컴포넌트 및 고려사항

### 알림 템플릿

대형 알림 시스템에서는 하루에도 수백만 건 이상의 알림이 전송된다. **대부분의 메시지는 유사한 형식을 갖기 때문에, 매번 처음부터 작성하는 것은 비효율적**이다. 

**템플릿을 사용**하면 일정한 형식과 스타일을 유지하면서 **변수나 추적 링크만 바꿀 수 있어, 작성 시간을 줄이고 오류 가능성을 낮출 수 있다.** 또한 템플릿 기반의 전송은 전체 메시지에 일관성을 제공한다.

### 알림 설정

사용자는 이미 많은 알림을 받고 있기 때문에, 수신 채널과 알림 종류를 직접 조정할 수 있어야 한다. 

**알림 설정 테이블에는 사용자 ID, 채널 정보(푸시, 이메일, SMS 등), 그리고 해당 채널 수신 여부** 같은 항목이 포함된다. 알림을 발송하기 전에는 반드시 사용자가 해당 알림을 켜 두었는지를 확인해야 하며, 이를 통해 불필요한 발송을 줄이고 사용자 피로도를 낮출 수 있다.

| user_id | bigInt |
| --- | --- |
| channel | varchar |
| opt_in | boolean |

### 전송률 제한

특정 사용자에게 알림이 과도하게 발송되는 것을 막는 것도 중요하다. 너무 많은 알림은 사용자가 알림 기능 자체를 꺼 버리는 결과로 이어질 수 있다. 

따라서 사용자별 전송 빈도를 제한하는 기능을 두어, 일정 시간 동안 발송할 수 있는 알림 수를 제어해야 한다.

### 재시도 방법

**제3자 서비스가 알림 전송에 실패하는 경우에는 해당 알림을 재시도 전용 큐에 넣는다.** 이후 지정된 횟수만큼 다시 시도하며, 동일 문제가 계속 반복되면 개발자에게 알림을 보낸다. 이렇게 하면 **일시적인 오류에는 자동으로 대응하고, 근본적인 장애에는 빠르게 사람의 개입을 유도할 수 있다.**

### 푸시 알림과 보안

iOS와 Android 푸시 알림은 보안이 특히 중요하다. 알림 전송 API는 appKey와 appSecret을 사용해 인증을 수행하고, 승인된 클라이언트만 발송할 수 있도록 해야 한다. 이를 통해 악의적인 사용자가 무단으로 알림을 보내는 것을 차단할 수 있다.

### 큐 모니터링

**알림 큐에 쌓인 메시지의 수는 시스템 상태를 판단하는 중요한 지표**다. 큐의 길이가 지나치게 길어지면 **작업 서버가 이벤트를 충분히 빠르게 처리하지 못하고 있다는 의미이므로, 서버를 증설하거나 성능 개선**이 필요하다. 이를 시각화한 모니터링 대시보드를 운영하면 장애를 조기에 감지하고 대응할 수 있다.

<img width="449" height="193" alt="image" src="https://github.com/user-attachments/assets/e5449d0f-f63a-4b42-b101-a03da2ae7ea6" />


### 이벤트 추적

알림이 실제로 사용자에게 어떤 영향을 주는지 분석하는 것도 중요하다. **수신 확인율, 클릭률, 앱 사용으로 이어지는 전환율 같은 지표 및 메트릭은 알림의 효과를 파악하는 핵심 자료**가 된다. 따라서 **알림 시스템은 데이터 분석 서비스와 통합**되어야 하며, 이를 통해 알림 전략을 지속적으로 최적화할 수 있다.

## 수정된 설계안

<img width="570" height="337" alt="image" src="https://github.com/user-attachments/assets/9fd32369-6fc3-46d8-820f-321bc5a3b4c3" />


이러한 안정성 고려사항과 추가 컴포넌트가 반영된 수정된 설계안은 한층 더 완성된 알림 플랫폼의 모습을 갖춘다. 

- **알림 서버에는 인증과 전송률 제한 기능이 포함**되었고, **전송 실패에 대응하는 재시도 기능도 추가**되었다.
- 또한 템플릿을 사용해 **알림 메시지 생성 과정을 단순화**하고, **모니터링과 이벤트 추적 기능을 통해 시스템 상태를 실시간으로 확인하고 분석**할 수 있게 되었다.
- 결과적으로 이 설계는 안정성, 보안, 효율성, 그리고 분석 가능성을 고루 갖춘 구조로 발전하게 된다.
