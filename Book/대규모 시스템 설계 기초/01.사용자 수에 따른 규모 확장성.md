# 단일 서버

<img width="488" alt="image" src="https://github.com/user-attachments/assets/7a16ae70-9b41-45be-978a-cf1183a3e047" />


# 데이터베이스

사용자가 늘면 서버 하나로는 충분하지 않다 → 여러 서버가 필요(`웹/모바일 트래픽 처리용`, `데이터베이스용`)

- 여러 서버로 나누면 각각을 독립적으로 확장해나갈 수 있다.

데이터베이스의 종류는 `관계형 데이터베이스`, `비-관계형 데이터베이스`로 나눌 수 있다.

- 비관계형 데이터베이스(NoSQL)
    - 키-값 저장소(key-value store)
    - 그래프 저장소(graph store)
    - 칼럼 저장소(column store)
    - 문서 저장소(document store)
- 관계형 데이터베이스가 최선일 수 있지만, 구축하려는 시스템에 적합하지 않은 경우 비-관계형 데이터베이스 선택을 고려해볼 수 있다.
- 비-관계형 데이터베이스가 바람직한 경우
    - 아주 낮은 응답 지연시간(latency)
    - 다루는 데이터가 비정형(unstrucured)인 경우
    - 데이터(JSON, YAML, XML 등)를 직렬화하거나 역직렬화 할 수 있기만 하면 되는 경우
    - 아무 많은 양의 데이터를 저장할 필요가 있는 경우

# 수직적 규모 확장 vs 수평적 규모 확장

수직적 규모 확장은 심각한 단점이 존재한다.

- 한 대의 서버에 CPU나 메모리를 무한대로 증설할 수 없다.
- 장애에 대한 자동복구(`failover`), 다중화(`redundancy`) 방안을 제시하지 않는다.

이 이유로, 대규모 애플리케이션은 수평적 규모 확장법이 보다 적절하다.

하나의 웹 서버에 너무 많은 사용자가 접속하는 경우 응답속도 저하, 서버 접속 불가 문제가 발생한다. 이를 해결하기 위해 부하 분산기, 로드밸런서를 도입하는 것이 최선이다.

## 로드밸런서

부하 분산 집합(load balancing set)에 속한 웹 서버에 트래픽을 고르게 분산하는 역할

<img width="431" alt="image" src="https://github.com/user-attachments/assets/13042346-67d5-44c2-9b61-5a9b8953048e" />


**cf) 사설 IP 주소**

- 서버 간 통신에는 사설 IP 주소를 이용
- 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소로, 인터넷을 통해 접속할 수 없다.

로드밸런서의 부하 분산 집합에 여러 개의 웹 서버를 추가하고 나면 장애를 자동 복구하지 못하는 문제(no failover) 해소, 가용성 향상 등이 이루어짐

로드밸런서를 통해 웹 계층의 문제를 해결할 수 있지만, 데이터베이스 서버는 하나뿐이기 때문에 장애 자동복구, 다중화를 지원할 수 없다. 이 문제를 데이터베이스 다중화를 통해 해결한다.

## 데이터베이스 다중화

다중화 시스템은 일반적으로 서버 사이에 주(`master`)-부(`slave`) 관계를 설정, 데이터 원본은 주 서버에, 사본은 부 서버에 저장하는 방식이다.

- `쓰기 연산`은 마스터에서만 지원, 부 데이터베이스는 주로부터 사본을 전달받으며 `읽기 연산`만을 지원
- 대부분의 애플리케이션은 읽기 연산의 비중이 쓰기 연산보다 높기 때문에, 통상 부 데이터베이스의 수가 주 데이터베이스의 수보다 많다

<img width="354" alt="image" src="https://github.com/user-attachments/assets/eb143238-31b0-4d75-a40f-114c57acf8e1" />


### **데이터베이스 다중화의 장점**

- 변경 연산은 주 데이터베이스 서버로만, 읽기 연산은 부 데이터베이스들로 분산되기 때문에 병렬로 처리될 수 있는 질의 수의 증가 (`성능 향상`)
- 데이터베이스 서버 가운데 일부가 파괴되어도 데이터는 보존 (`안정성`)
- 하나의 데이터베이스 서버에 장애가 발생해도 다른 서버에 있는 데이터를 가져와 계속 서비스 가능 (`가용성`)

데이터베이스 다중화를 통해 하나의 서버가 다운되더라도 감내할 수 있다.

- 예를 들어, 주 데이터베이스 서버가 다운되면 부 데이터베이스 서버가 새로운 주 데이터베이스 서버가 된다.
- 하지만 프로덕션 환경에서는 부 서버에 보관된 데이터가 최신 상태가 아닐 수 있기 때문에 없는 데이터는 복구 스크립트(`recovery script`)를 돌려야 한다.

> 이제부터 웹 계층과 데이터 계층에 대한 이해를 바탕으로 응답 시간을 개선하는 방법에 대해 알아본다.
> 

# 캐시

캐시는 값 비싼 연산 결과, 자주 참조되는 데이터를 메모리 안에 두고, 뒤이은 요청이 보다 빨리 처리 될 수 있도록 하는 저장소

- 애플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우된다. 캐시는 이 문제를 완화한다.

## 캐시 계층

데이터가 잠시 보관되는 곳으로, 데이터베이스보다 훨씬 빠르다.

- 별도의 캐시 계층을 두면 성능 개선 뿐 아니라, 데이터베이스의 부하를 줄일 수 있고 캐시 계층의 규모를 독립적으로 확장하는 것도 가능하다.

### cf) 읽기 주도형 캐시 전략(read-through caching strategy)

1. 요청을 받은 웹 서버는 캐시에 응답이 저장되어 있는지 확인
2. 저장되어 있는 경우는 바로 반환
3. 없는 경우는 데이터베이스 질의를 통해 데이터를 찾아 캐시에 저장한 뒤 클라이언트에 반환

## 캐시 사용 시 유의할 점

- 데이터 갱신은 자주 일어나지 않지만, 참조는 빈번하게 일어나는 경우에 적합
- 영속적으로 저장할 데이터는 캐시에 두지 않는 것이 좋다. 캐시 서버가 재시작되면 캐시 내의 모든 데이터는 사라진다.
- 캐시 만료 정책을 마련해두는 것이 좋다.
- 일관성(데이터 저장소의 원본과의 일치 여부)을 유지하는 것이 좋다.
- 캐시 서버를 한대만 두는 경우 해당 서버는 단일 장애 지점(`Single Point of Failure, SPOF`)이 될 수 있다.
    
    > 어떤 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버릴 수 있는 경우, 우리는 해당 지점을 단일 장애 지점이라고 부른다.
    > 
- 캐시 메모리가 너무 작으면, 엑세스 패턴에 따라 데이터가 너무 자주 밀러나버려 (`eviction`) 캐시의 성능이 저하된다. 이를 막기 위해 캐시 메모리를 과할당(`overprovision`) 한다.
- 적절한 데이터 방출(`eviction`) 정책을 선택해야 한다.
    - `LRU(Least Recently Used)` : 마지막으로 사용된 시점이 가장 오래된 데이터를 내보내야 한다.
    - `LFU(Least Frequently Used)` : 사용된 빈도가 가장 낮은 데이터를 내보낸다.
    - `FIFO`…

# 콘텐츠 전송 네트워크(CDN)

정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크. 이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있다.

- `요청 경로`, `질의 문자열`, `쿠키`, `요청 헤더` 등의 정보에 기반하여 HTML 페이지를 캐시
- 사용자가 웹 사이트를 방문하면, 사용자에게 가장 가까운 CDN 서버가 정적 콘텐츠를 전달

<img width="549" alt="image" src="https://github.com/user-attachments/assets/9da6ccc1-852e-41b2-9b09-faed20037de9" />

<img width="436" alt="image" src="https://github.com/user-attachments/assets/b3687741-19db-4fff-a615-8f20f56e700c" />

CDN과 캐시가 추가된 설계

CDN과 캐시가 추가됨으로써 다음과 같이 변경되었다.

- 정적 콘텐츠(JS, CSS, 이미지 등)는 더 이상 웹 서버를 통해 서비스하지 않으며, CDN을 통해 더 빠르게 제공 가능하다.
- 캐시가 데이터베이스 부하를 줄여준다.

# 무상태(stateless) 웹 계층

웹 계층을 수평적으로 확장하기 위해서는 상태 정보(ex : 사용자 세션 데이터)를 웹 계층에서 제거해야 한다.

- 이를 위해 상태 정보를 `관계형 데이터베이스`나 `NoSQL` 같은 지속성 저장소에 보관하고 필요할 때 가져온다.

이러한 웹 계층을 무상태 웹 계층

## 상태 정보 의존적인 아키텍처

상태 정보를 보관하는 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유되도록 한다. 이 경우 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다.

- 로드밸런서가 이 문제를 해결하기 위해 고정 세션(`sticky session`)이라는 기능을 제공하지만, 로드밸런서에게 부담을 준다.
- 이때문에 서버 장애 처리 복잡도가 증가한다.

## 무상태 아키텍처

<img width="341" alt="image" src="https://github.com/user-attachments/assets/1780bb65-c350-451f-870e-f849f14599cd" />


무상태 아키텍처의 경우 사용자로부터의 HTTP 요청은 어떤 웹서버로도 전달될 수 있다. 웹 서버는 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져올 수 있다.

이 구조는 단순하고, 안정적이며 규모 확장이 쉽다.

### cf) 자동 규모 확장(autoscaling)

트래픽 양에 따라 웹 서버를 자동으로 추가하거나 삭제하는 기능

상태 정보가 웹 서버들로부터 제거되었기 때문에, 트래픽 양에 따라 웹 서버를 넣거나 빼기만 하면 자동으로 규모를 확장할 수 있다.

# 데이터 센터

장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내되는데, 통상 이 절차를 지리적 라우팅(`geoDNS-routing` 또는 `geo-routing`) 이라 부른다.

- `geoDNS`는 사용자의 위치에 따라 도메인 이름을 어떤 IP 주소로 변환할지 결정해주는 DNS 서비스

<img width="489" alt="image" src="https://github.com/user-attachments/assets/bb241dae-e2ae-437c-b63d-c55b27a98d16" />


위와 같이 다중 데이터센터 아키텍처를 만들기 위해서는 몇 가지 기술적 난제를 해결해야 한다.

- `트래픽 우회` : 올바른 데이터센터로 트래픽을 효과적으로 보내는 방법
- `데이터 동기화` : 데이터 동기화를 위해 데이터를 여러 데이터센터에 걸쳐 다중화해야 한다.
- `테스트와 배포` : 자동화된 배포 도구를 활용해 모든 데이터센터에 동일한 서비스가 설치되도록 할 수 있다.

# 메시지 큐

시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여 , 각기 독립적으로 확장해야 한다. 실제 분산 시스템은 이 문제를 해결하기 위해 메시지 큐 전략을 활용한다.

메시지 큐는 메시지의 무손실을 보장하는, 비동기 통신(`asynchronous communication`)을 지원하는 컴포넌트이다.

- 메시지의 무손실: 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성

### 기본 아키텍처

생산자 또는 발행자 (producer/pubisher)라고 불리는 입력 서비스가 메시지를 만들어 메시지 큐에 발행(publish) 한다. 

큐에는 보통 소비자 혹은 구독자 (consumer/subscriber) 라 불리는 서비스 혹은 서버가 연결되어 있는데 , 메시지를 받아 그에 맞는 동작을 수행하는 역할을 한다.

<img width="827" alt="image" src="https://github.com/user-attachments/assets/aadb266f-a57a-436b-9188-425d2bf36f0c" />


이 구조를 활용하면 서비스 또는 서바 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다

- 생산자는 소비자 프로세스가 다운되어 있어도 메시지를 발행할 수 있고,
- 소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다.

# 로그, 메트릭 그리고 자동화

웹 사이트나 사업 규모가 커지면, `로그`, `메트릭(metric)`, `자동화(automation)` 와 같은 도구에 필수적으로 투자해야 한다.

- `로그` : 시스템의 오류와 문제들을 쉽게 찾아내기 위해 에러 로그를 모니터링 해야한다. 로그를 단일 서비스로 모아주는 도구를 활용하면 더 좋다.
- `메트릭` : 사업 현황에 관한 유용한 정보를 얻을 수도 있으며, 시스템의 현재 상태를 손쉽게 파악할 수도 있다.
    - `호스트 단위 메트릭` :  CPU, 메모리, 디스크 I/O에 관한 메트릭
    - `종합(aggregated) 메트릭` : 데이터베이스 계층의 성능, 캐시 계층의 성능
    - `핵심 비즈니스 메트릭` : 일별 능동 사용자, 수익, 재방문
- `자동화` : 지속적 통합 (`continuous integration`)을 도와주는  도구를 활용하면 개발자가 만드는 코드가 어떤 검증 절차를 자동으로 거치도록 할 수 있어서 문제를 쉽게 감지할 수 있다.

<img width="503" alt="image" src="https://github.com/user-attachments/assets/bfebfb2f-300f-426e-9c5d-b364b71428a9" />


- 메시지 큐를 통해 각 컴포넌트가 느슨히 결합(`loosely coupled`) 될 수 있도록 한다. 이로 인해 결함에 대한 내성이 높아진다.
- 로그, 모니터링, 메트릭, 자동화를 추가하였다.

# 데이터베이스의 규모 확장

데이터베이스의 규모를 확장하기 위해서는 `수직적 규모 확장법`, `수평적 규모 확장법` 을 이용할 수 있다.

## 수직적 확장

스케일 업이라고도 불린다. 기존 서버에 더 많은, 또는 고성능의 자원(CPU, RAM, 디스크 등)을 증설하는 방법이다. 

수직적 접근법에는 몇 가지 심각한 약점이 있다.

- 데이터베이스 서버 하드웨어에는 한계가 있으므로, CPU, RAM 등을 무한히 증설할 수 없기 때문에 사용자가 늘면 한 대의 서버로는 결국 감당할 수 없다.
- `SPOF(Single Point of Failure)` 로 인한 위험성이 존재한다.
- 고성능 서버로 갈 수록 비싸다.

## 수평적 확장

샤딩(`sharding`) 이라고도 부른다. 더 많은 서버를 추가함으로써 성능을 향상시킨다. 

- `샤딩` : 대규모 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술
- 모든 샤드는 같은 스키마를 쓰지만, 샤드에 보관되는 데이터는 중복이 없다.

<img width="381" alt="image" src="https://github.com/user-attachments/assets/56ec5236-bca8-408e-bf1e-1865aac3d75c" />


- 위 예시는 `user % 4` 를 해시 함수로 사용하여 데이터가 보관되는 샤드를 정하는 예시이다.

샤딩 전략을 구현할 때 가장 중요한 것은 샤딩 키 (`sharding key`/`partition key`) 를 어떻게 정햐느냐이다. 샤딩 키를 통해 올바른 데이터베이스에 질의를 보내어 데이터 조회나 변경을 처리하므로 효율을 높일 수 있다.

- 샤딩 키를 정할 때는 **데이터를 고르게 분할 할 수 있도록 하는 게 중요하다**.
- 샤딩을 도입하면 시스템이 복잡해지고 풀어야 할 문제도 증가하는 단점도 있다.

### 데이터의 재 샤딩(resharding)

- 데이터가 너무 많아져서 하나의 샤드로는 더 이상 감당하기 어려울 때,
- 샤드 간 데이터 분포가 균등하지 못하여 어떤 샤드에 할당된 공간 소모가 다른 샤드에 비해 빨리 진행될 때

샤드 소진(`shard exhaustion`) 현상이 발생한다.

이 현상이 발생하면 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치해야 한다. 안정 해시(`consistent hashing`) 기법을 활용하여 해결할 수 있다.

### 유명인사(celebrity) 문제

핫스팟 키(hospot key) 문제라고도 부른다. **특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제**다.

케이티 페리, 저스틴 비버, 레이디 가가 같은 유명인사가 전부 같은 샤드에 저장되는 데이터베이스인 경우, 너무 많은 read 연산 때문에 과부하가 걸릴 것이다.

### 조인과 비정규화(join and de-normalization)

하나의 데이터베이스를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기가 힘들어진다. 이를 해결하기 위해서는 데이터베이스를 비정규화여 하나의 테이블에서 질의가 수행될 수 있도록 해야 한다.

# 백만 사용자, 그리고 그 이상

수백만 사용자 이상을 지원하려면 새로운 전략을 도입해야 하고, 지속적으로 시스템을 가다듬어야 한다. 시스템을 최적화하고 더 작은 단위의 서비스로 분할해야 한다.
