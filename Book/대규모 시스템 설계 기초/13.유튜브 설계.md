# 문제 이해 및 설계 범위 확정

유튜브 같은 비디오 스트리밍 서비스는 겉보기엔 단순하지만, 실제로는 방대한 기술과 인프라가 필요하다. 2020년 기준으로 보면 월간 사용자 20억 명, 하루 영상 재생 50억 회, 광고 수익 150억 달러에 이를 정도로 규모가 크다. 모바일 트래픽의 37%를 차지하고, 80개 언어를 지원한다는 점도 특징이다.

면접 문제에서는 모든 기능을 다루기 어렵기 때문에 핵심 범위를 좁힌다.

- 주요 기능: 영상 업로드와 시청
- 클라이언트: 모바일, 웹, 스마트TV
- 조건: DAU 500만 명, 평균 이용 시간 30분, 업로드 최대 1GB, 다국어 지원, 대부분 해상도 지원

이 서비스가 달성해야 할 목표는 빠른 업로드, 끊김 없는 재생, 화질 선택, 낮은 비용, 높은 가용성과 확장성이다.

규모를 계산해 보면, 하루에 50만 개 영상(평균 300MB)이 업로드되어 150TB 저장 공간이 필요하다. 또, 500만 명이 하루 평균 5개씩 영상을 보면 CDN 트래픽만으로 하루 약 15만 달러의 비용이 발생한다.

# 개략적 설계안 제시 및 동의 구하기

모든 것을 직접 구현하지 않고, **클라우드의 CDN과 BLOB 스토리지** 같은 기존 서비스를 활용한다는 것이다. 실제로 넷플릭스도 AWS를, 페이스북도 Akamai CDN을 사용한다.

개략적으로 시스템은 세 가지 컴포넌트로 나뉜다.

1. 클라이언트(단말): 컴퓨터, 모바일, 스마트 TV 같은 사용자 장치.
2. CDN: 영상을 저장하고 스트리밍을 담당.
3. **API 서버**: 영상 스트리밍 외의 나머지 요청(업로드 URL 생성, 메타데이터 관리, 추천 피드, 사용자 가입 등)을 처리.

## 비디오 업로드 절차

업로드 과정은 여러 컴포넌트가 협력한다.

<img width="464" height="526" alt="image" src="https://github.com/user-attachments/assets/fd3d9008-ceeb-471a-95a6-a7af91d96472" />

- **로드 밸런서**: 요청을 여러 API 서버에 고르게 분산한다.
- **API 서버**: 스트리밍을 제외한 모든 요청을 처리한다.
- **메타데이터 DB와 캐시**: 영상의 URL, 크기, 포맷, 사용자 정보 등 메타데이터를 저장한다. 성능과 가용성을 위해 샤딩, 복제를 적용한다.
- **원본 저장소(BLOB)**: 업로드된 원본 영상을 저장한다.
- **트랜스코딩 서버**: 원본 영상을 가져와 다양한 포맷과 해상도로 변환한다.
- **트랜스코딩 비디오 저장소**: 변환된 영상을 저장하는 공간.
- **CDN**: 최종적으로 영상이 캐시되어 사용자가 재생 버튼을 누르면 여기서 스트리밍된다.
- **트랜스코딩 완료 큐 & 핸들러**: 변환이 끝났음을 알리고, 메타데이터 DB, 캐시를 갱신한다.

업로드는 크게 두 프로세스로 나뉜다.

### **비디오 업로드**

1. 사용자가 영상을 원본 저장소에 업로드한다.
2. 트랜스코딩 서버가 원본 영상을 가져와 변환을 시작한다.
3. 변환이 끝나면 두 가지가 동시에 진행된다.
    - 변환된 영상을 트랜스코딩 저장소와 CDN에 저장.
    - 트랜스코딩 완료 이벤트를 큐에 등록.
4. 핸들러가 큐에서 이벤트를 꺼내 DB와 캐시의 메타데이터를 갱신한다.
5. API 서버가 단말에 “영상 준비 완료” 메시지를 보낸다.

### **메타데이터 갱신**

1. 업로드와 동시에, 단말은 파일 이름, 크기, 포맷 같은 메타데이터를 API 서버에 전달한다.
2. API 서버는 이 정보를 기반으로 메타데이터 DB와 캐시를 갱신한다.

## 비디오 스트리밍 절차

유튜브에서 영상을 재생할 때 사용자는 다운로드가 끝나기를 기다릴 필요가 없다. **스트리밍 방식** 덕분에 영상은 서버에서 단말로 조금씩 전송되면서 바로 재생이 시작된다. 다운로드란 전체 파일을 단말로 다 받아야 하는 것을 의미하고, 스트리밍은 네트워크를 통해 원격지 서버로부터 지속적으로 데이터를 받아와 실시간으로 재생하는 방식이다.

비디오 스트리밍 절차를 이해하기 전에 먼저 **스트리밍 프로토콜** 개념을 알아야 한다. 프로토콜은 영상을 어떤 방식으로 잘라 전송하고, 클라이언트가 어떻게 받아서 재생할지를 정하는 표준이다. 대표적인 프로토콜은 다음과 같다.

- MPEG-DASH, Apple HLS, Microsoft Smooth Streaming,  Adobe HDS

**각 프로토콜마다 지원하는 인코딩 방식과 플레이어가 다르다**. 따라서 어떤 프로토콜을 사용할지는 서비스의 특성과 환경에 따라 선택해야 한다.

<img width="228" height="240" alt="image" src="https://github.com/user-attachments/assets/da030184-1842-482a-aabb-bc786e3fb2ed" />

실제 영상 스트리밍은 CDN을 통해 이루어진다. 사용자가 재생 버튼을 누르면, 단말에서 가장 가까운 CDN의 엣지 서버(edge server) 가 데이터를 전송한다. 이렇게 하면 네트워크 지연(latency)을 최소화할 수 있고, 전 세계 어디서든 빠르게 재생이 가능하다.

# 상세 설계

## 비디오 트랜스코딩

사용자가 휴대폰이나 카메라로 영상을 녹화하면 기기는 해당 영상을 특정 포맷으로 저장한다. 그러나 이 영상을 다른 기기에서도 문제없이 재생하려면, 호환 가능한 비트레이트(bit rate)와 포맷으로 변환하는 과정이 필요하다. 

**비트레이트는 비디오를 구성하는 데이터가 얼마나 빨리 처리되어야 하는지를 나타내는 단위**인데, 비트레이트가 높을수록 화질은 좋아지지만 더 빠른 네트워크와 높은 컴퓨팅 성능이 필요하다.

이 때문에 **비디오 트랜스코딩은 필수적인 과정**이다. 그 이유를 정리하면 다음과 같다.

- 가공되지 않은 원본 비디오는 매우 크다. 예를 들어 초당 60프레임의 HD 영상은 수백 GB에 이를 수 있다.
- 각 기기와 브라우저는 특정 포맷만 지원하기 때문에 하나의 영상을 여러 포맷으로 인코딩해 두어야 한다.
- 네트워크 환경에 따라 저화질/고화질을 다르게 제공해 끊김 없는 재생을 보장한다.
- 이동 중에는 네트워크 상황이 수시로 변하므로, 화질을 자동 또는 수동으로 변경할 수 있어야 한다.

트랜스코딩에서 중요한 개념은 컨테이너(container) 와 코덱(codec) 이다.

- 컨테이너는 비디오, 오디오, 메타데이터를 담는 바구니 같은 역할을 한다. 흔히 볼 수 있는 .avi, .mov, .mp4 같은 확장자가 컨테이너 포맷이다.
- 코덱은 화질을 유지하면서 파일 크기를 줄이는 압축/해제 알고리즘이다. 많이 쓰이는 코덱으로는 H.264, VP9, HEVC 등이 있다.

## 유향 비순환 그래프 모델

비디오 트랜스코딩은 단순한 변환 이상의 의미를 가진다. 우선 이 과정은 **컴퓨팅 자원과 시간이 많이 소모되는 작업**이다. 게다가 창작자마다 원하는 요구 사항이 다르다. 

어떤 이는 영상에 워터마크를 넣길 원하고, 또 다른 이는 직접 만든 썸네일을 지정하고 싶어 하며, 어떤 이는 고화질 영상을 선호하는 반면, 또 다른 이는 저화질로도 충분하다고 생각할 수 있다.

이처럼 서로 다른 요구를 수용하면서도 처리 속도를 높이기 위해서는, 트랜스코딩 파이프라인에 **적절한 추상화**를 도입해야 한다. 대표적인 방법이 바로 **DAG(Directed Acyclic Graph, 유향 비순환 그래프) 모델**이다.

DAG 모델은 복잡한 작업을 여러 개의 **작업(Task)** 으로 쪼개어 순차적 혹은 병렬적으로 실행할 수 있게 해준다. 페이스북의 스트리밍 비디오 엔진도 이 모델을 사용해, 다양한 변환 과정을 유연하게 지원한다. 이번 설계안에서도 DAG 모델을 적용하여 유연성과 병렬성을 달성하려는 것이다.

### **DAG 기반 트랜스코딩 파이프라인**

<img width="493" height="329" alt="image" src="https://github.com/user-attachments/assets/437accd5-aae0-4eeb-b0b9-a3d9931894e8" />

원본 영상은 크게 비디오, 오디오, 메타데이터 세 가지 부분으로 나뉘어 처리된다.

- **검사**: 업로드된 영상이 정상적인지, 손상은 없는지를 확인한다.
- **비디오 인코딩**: 하나의 영상을 다양한 해상도, 코덱, 비트레이트 조합으로 변환한다. 예를 들어 360p.mp4, 480p.mp4, 720p.mp4, 1080p.mp4, 4K.mp4와 같은 결과물이 생성된다.
- **썸네일**: 사용자가 직접 업로드한 이미지를 쓰거나, 영상에서 특정 장면을 추출해 대표 이미지를 만든다.
- **워터마크**: 저작권이나 채널 식별 정보를 오버레이 형태로 영상 위에 삽입한다.

이처럼 DAG 모델을 적용하면, 검사 → 인코딩 → (워터마크, 썸네일 등) 과정을 그래프 형태로 정의해 상황에 따라 병렬로 돌리거나 순차적으로 실행할 수 있다. 

## 비디오 트랜스코딩 아키텍처

본 설계안에서 제시하는 **비디오 트랜스코딩 아키텍처**는 클라우드 서비스를 활용하며, 다섯 개의 주요 컴포넌트로 구성된다.

<img width="518" height="142" alt="image" src="https://github.com/user-attachments/assets/319c8b12-4bf0-4c33-b4bf-b9d978eb8d07" />

이 과정을 통해 최종적으로 **인코딩된 비디오**가 생성된다.

### 전처리기

전처리기가 담당하는 일은 세 가지다.

1. **비디오 분할(Video Splitting)**
    
    비디오 스트림을 GOP(Group of Pictures) 단위로 쪼갠다. GOP는 특정 순서로 배치된 프레임 묶음이며, 독립적으로 재생 가능하다. 
    
    보통 길이는 몇 초 정도다. 일부 오래된 단말이나 브라우저는 GOP 단위 분할을 지원하지 않으므로, 이런 경우 전처리기가 대신 처리한다.
    
2. **DAG 생성**
    
    클라이언트 프로그래머가 작성한 설정 파일을 기반으로 DAG를 만든다. DAG는 트랜스코딩 과정의 작업(Task)들을 어떻게 연결하고 실행할지를 정의한다. 
    
    예시로, 다운로드 → 트랜스코딩 두 작업을 연결하는 DAG가 설정 파일로부터 생성될 수 있다.
    
3. **데이터 캐시(Data Cache)**
    
    전처리기는 비디오를 분할한 GOP와 메타데이터를 **임시 저장소(Temporary Storage)** 에 보관한다. 이렇게 하면 안정성이 높아진다. 
    
    만약 인코딩이 실패했을 때, 시스템은 캐시된 데이터를 이용해 인코딩을 재개할 수 있다.
    

### DAG 스케줄러

DAG 스케줄러의 역할은, 전처리기가 생성한 DAG 그래프를 여러 단계(Stage) 로 나누고, 이를 자원 관리자의 작업 큐에 집어넣는 것이다.

<img width="450" height="265" alt="image" src="https://github.com/user-attachments/assets/58a47718-93d2-4999-9044-2ea19ab032fc" />

1. 1단계: 원본 비디오에서 비디오, 오디오, 메타데이터를 분리한다.
2. 2단계: 분리된 데이터를 활용해 비디오는 인코딩, 영상에서는 썸네일 추출, 오디오는 인코딩이 동시에 진행된다.

즉, DAG 스케줄러는 복잡한 비디오 처리 과정을 작업 단위로 분리하고, 이를 순차적 또는 병렬적 단계로 실행할 수 있도록 정리하는 역할을 한다.

### 자원 관리자

자원 관리자는 트랜스코딩 작업에 필요한 자원 배분을 효과적으로 수행하는 역할을 맡는다. 구조는 세 개의 큐와 하나의 작업 스케줄러로 이루어진다.

- 작업 큐: 실행 대기 중인 작업이 저장되는 우선순위 큐.
- 작업 서버 큐: 각 작업 서버의 가용 상태가 저장된 우선순위 큐.
- 실행 큐: 현재 실행 중인 작업과 작업 서버의 정보를 저장하는 큐.
- 작업 스케줄러(Task Scheduler): 어떤 작업을 어떤 서버에 할당할지 결정하고 실행을 지시하는 핵심 구성 요소.

자원 관리자의 동작 절차는 다음과 같다.

1. 작업 큐에서 가장 높은 우선순위의 작업을 꺼낸다.
2. 해당 작업을 수행하기에 가장 적합한 작업 서버를 선택한다.
3. 작업 스케줄러가 그 서버에 작업 실행을 지시한다.
4. 동시에, “어떤 작업이 어떤 서버에 할당되었는지” 정보를 실행 큐에 기록한다.
5. 작업이 완료되면 해당 항목을 실행 큐에서 제거한다.

### 작업 서버

작업 서버(Resource Worker) 는 DAG에 정의된 개별 작업을 실제로 실행하는 컴포넌트다. 즉, 전처리기와 DAG 스케줄러, 자원 관리자를 거쳐 내려온 작업이 최종적으로 수행되는 곳이다.

작업 서버는 작업 종류에 따라 구분되어 관리된다. 

- 예를 들어, 어떤 서버는 워터마크 삽입을 전담하고, 또 다른 서버는 비디오 인코딩을 처리하며, 다른 서버는 썸네일 추출 및 병합을 수행한다.

### 임시 저장소

임시 저장소는 트랜스코딩 과정 중 생성되는 데이터를 일시적으로 보관하는 공간이다. 어떤 저장소 시스템을 선택할지는 데이터의 유형, 크기, 접근 빈도, 유효 기간 등에 따라 달라진다.

- 메타데이터는 크기가 작고 작업 서버가 자주 참조하므로, 메모리 캐시에 저장하는 것이 효율적이다.
- 반면, 비디오·오디오 데이터는 용량이 크기 때문에 BLOB 스토리지 같은 대형 이진 저장소에 두는 것이 적합하다.

임시 저장소에 있는 데이터는 비디오 프로세싱이 완료되면 삭제된다.

### 인코딩된 비디오

인코딩된 비디오는 트랜스코딩 파이프라인의 최종 결과물이다. 변환 과정이 끝난 뒤에는 해상도와 코덱이 반영된 파일 이름을 갖게 되며, 예를 들어 funny_720p.mp4와 같이 저장된다.

## 시스템 최적화

### 속도 최적화: 비디오 병렬 업로드

속도 최적화 방법으로는 *비디오 병렬 업로드*가 있다. 영상을 한 번에 통째로 업로드하는 것은 비효율적이다. 대신, 영상을 GOP(Group of Pictures) 단위로 쪼개 업로드한다.

<img width="522" height="121" alt="image" src="https://github.com/user-attachments/assets/6cfad982-0148-4f47-a197-298fc39c0c1f" />

- GOP는 몇 초 길이의 프레임 묶음으로 독립적으로 재생 가능하다.
- 영상을 GOP 단위로 나누어 병렬 업로드하면, 일부 구간에서 업로드가 실패해도 해당 부분만 다시 전송하면 되므로 전체 업로드 속도가 빨라진다.
- 이 작업을 단말(사용자 기기)에서 수행하면, 업로드 효율이 크게 향상된다.

### 속도 최적화: 업로드 센터를 사용자 근거리에 지정

속도를 높이는 또 다른 방법은 사용자와 가까운 업로드 센터를 두는 것이다. 예를 들어, 미국 사용자는 북미 지역 업로드 센터를, 중국 사용자는 아시아 업로드 센터를 이용하도록 하는 방식이다.

이를 위해 본 설계안에서는 CDN을 업로드 센터로 활용한다. 즉, 사용자는 가장 가까운 CDN 지점에 영상을 업로드하고, 그곳에서 후속 처리(트랜스코딩 등)로 전달되도록 하여 업로드 지연을 줄이는 것이다.

### 속도 최적화: 모든 절차를 병렬화

낮은 응답 지연을 달성하기 위해 또 다른 방법은 시스템을 느슨하게 결합(Loosely Coupled) 하여 병렬성을 높이는 것이다.

기존 설계에서는, 예를 들어 인코딩 모듈이 실행되기 전에 반드시 다운로드 모듈의 작업이 끝나야 했다. 이런 식으로 단계 간 의존성이 강하면 병렬 처리가 어렵다.

<img width="537" height="313" alt="image" src="https://github.com/user-attachments/assets/52c77af3-9f10-498d-9b95-a0994fd64aaf" />

이를 해결하기 위해 메시지 큐(Message Queue) 를 도입한다.

- 메시지 큐가 없을 때: 인코딩 모듈은 다운로드가 끝날 때까지 기다려야 한다.
- 메시지 큐가 있을 때: 다운로드가 끝난 결과는 큐에 이벤트로 저장되고, 인코딩 모듈은 이를 가져와 병렬적으로 처리할 수 있다.

### 안정성 최적화: 미리  사인된 업로드 URL

안전성은 시스템 설계에서 가장 중요한 요소 중 하나다. 허가된 사용자만 올바른 위치에 비디오를 업로드할 수 있도록 본 설계안에서는 미리 사인된(pre-signed) 업로드 URL을 사용한다.

1. 클라이언트가 API 서버에 POST /upload 요청을 보낸다.
2. **API 서버는 해당 객체에 접근 권한이 미리 부여된 사인된 URL을 반환한다.**
3. 클라이언트는 반환된 URL을 이용해 원본 저장소에 직접 비디오를 업로드한다.

### 안정성 최적화: 비디오 보호

많은 콘텐츠 제작자가 영상을 인터넷에 업로드하기를 주저하는 이유 중 하나는 **원본이 도난당할 위험** 때문이다. 이를 막고 저작권을 보호하기 위해 다음과 같은 선택지가 있다.

1. **디지털 저작권 관리(DRM, Digital Rights Management) 시스템 도입**
    - 업계에서 가장 널리 쓰이는 방식이다.
    - 예: 애플의 FairPlay, 구글의 Widevine, 마이크로소프트의 PlayReady.
    - 각 플랫폼의 생태계와 호환되어 안정적으로 저작권 보호 가능.
2. **AES 암호화(Encryption)**
    - 비디오 파일 자체를 암호화한 뒤, 허가된 사용자만 재생 시 복호화할 수 있도록 한다.
    - 접근 권한이 없는 사용자는 파일을 가져가도 내용을 볼 수 없다.
3. **워터마크(Watermark)**
    - 비디오 화면 위에 소유자 정보(회사명, 사용자명 등) 를 오버레이 형태로 삽입한다.
    - 눈에 보이는 워터마크로 억제 효과를 주거나, 눈에 보이지 않는 워터마크로 추적에 활용할 수도 있다.

### 비용 최적화

CDN은 전 세계 어디서든 끊김 없이 빠르게 영상을 제공하는 핵심 요소이지만, 비용이 매우 크다는 문제가 있다. 특히 동영상 크기가 클수록 CDN 비용이 눈덩이처럼 늘어난다. 이를 줄이기 위해 다음과 같은 최적화 전략을 고려할 수 있다.

1. **인기 비디오와 비인기 비디오 분리**
    - 인기 있는 영상은 CDN을 통해 제공하지만 그렇지 않은 영상은 일반 비디오 서버를 통해 스트리밍한다.
    - 이렇게 하면 CDN을 꼭 필요한 부분에만 집중해 비용을 절약할 수 있다.
2. **온디맨드 인코딩(On-demand Encoding)**
    - 시청자가 거의 없는 영상 특히 짧은 영상은 미리 인코딩하지 않고 필요할 때 즉시 인코딩한다.
    - 불필요한 저장 및 처리 비용을 줄일 수 있다.
3. **지역별 트래픽 최적화**
    - 어떤 영상은 특정 지역에서만 인기가 높다.
    - 이런 영상은 굳이 전 세계 CDN 노드에 배포할 필요 없이 해당 지역에만 배포하면 된다.
4. **자체 CDN 구축 및 ISP와 제휴**
    - 초대형 스트리밍 서비스라면 CDN을 직접 구축하고, ISP와 협력해 사용자와 가까운 곳에서 직접 서비스할 수 있다.
    - 이렇게 하면 사용자 경험도 개선되고 네트워크 비용도 크게 절감된다.

### 오류 처리

대규모 시스템에서는 오류가 불가피하다. 따라서 우아하게 처리하고 빠르게 복구하는 능력이 중요하다. 오류는 크게 두 가지로 나뉜다.

- **회복 가능 오류(Recoverable error)**
    - 예: 특정 비디오 세그먼트 트랜스코딩 실패.
        - 보통 몇 번의 재시도로 해결되지만, 반복 실패하면 클라이언트에 오류 코드를 반환해야 한다.
- **회복 불가능 오류(Non-recoverable error)**
    - 예: 잘못된 비디오 포맷.
    - 이런 경우 작업을 중단하고 클라이언트에 오류 코드를 즉시 반환한다.

컴포넌트별 전형적 대응 방식은 다음과 같다.

- 업로드 오류 : 일정 횟수 재시도.
- 비디오 분할 오류 : 오래된 클라이언트가 GOP 단위 분할을 지원하지 못하면 전체 비디오를 서버로 전송해 서버가 분할을 수행.
- 트랜스코딩 오류 : 재시도.
- 전처리 오류 : DAG 그래프를 재생성.
- DAG 스케줄러 오류 : 작업을 다시 스케줄링.
- 자원 관리자 큐 장애 : 복제(replica) 활용.
- 작업 서버 장애 : 다른 서버에서 해당 작업을 재시도.
- API 서버 장애 : 무상태(stateless)이므로 다른 API 서버로 요청 우회.
- 메타데이터 캐시 서버 장애 : 데이터는 다중화되어 있으므로 다른 노드에서 가져오고, 장애 서버는 교체.
- 메타데이터 DB 서버 장애
    - 주 서버 장애 시 : 부 서버 중 하나를 주 서버로 승격.
    - 부 서버 장애 시 : 다른 부 서버로 읽기 처리, 죽은 서버는 교체.
