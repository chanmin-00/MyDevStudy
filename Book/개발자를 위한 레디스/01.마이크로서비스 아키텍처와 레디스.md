# NoSQL의 등장 배경

소프트웨어에서 데이터 저장소의 선택은 성능, 확장성, 가용성, 신뢰성에 큰 영향을 준다. 디지털 산업의 성장과 함께 아키텍처도 모놀리틱 → 마이크로서비스로 진화하면서, 이에 맞는 데이터 저장 방식도 다양해졌다.

# 모놀리틱 아키텍처의 한계

`모놀리틱 아키텍처`는 전체 애플리케이션을 하나의 통합된 구조로 개발/배포하는 방식이다. 초기에는 개발과 배포가 단순하다는 장점이 있지만, 서비스가 커질수록 유지보수, 배포, 장애 처리의 복잡도가 급격히 증가한다.

- 하나의 모듈 변경에도 전체 재빌드 필요하다
- 하나의 장애가 전체 시스템 장애로 확산된다.
- 특정 기능만 확장 불가하고, 그로 인해 전체 시스템을 확장해야 한다. 이로 인해 리소스 낭비가 발생한다.
- 빠른 대응이 어렵고 릴리스 주기도 느리다.

# 마이크로서비스 아키텍처의 특징

`마이크로서비스`는 기능을 분리해 독립적인 서비스로 구성하며, 각 서비스는 개별적으로 배포, 업데이트, 확장 가능하다.

- 특정 기능만 빠르게 확장 가능하다.
- 각 서비스별로 다양한 언어/프레임워크가 사용 가능하다.
- 한 서비스 장애가 다른 서비스에 영향 미치지 않는다.
- 민첩한 대응이 가능하다.

하지만 운영 서비스가 많아지므로 소규모 팀에는 부담이 될 수 있다.

# 데이터 저장소의 변화

기존에는 Oracle, MySQL, SQL Server 등 관계형 데이터베이스(RDBMS)가 중심이었다. RDB는 `고정된 스키마`, `정형화된 테이블`, `정확한 관계성`을 기반으로 하는 구조이며, ACID 특성(원자성, 일관성, 독립성, 지속성)을 보장한다.

그러나 현대에는 비정형 데이터(예: `JSON`, `시계열`, `그래프 데이터`)의 증가로 RDB의 한계가 드러나고 있다.

- 스키마 유연성 부족하기 때문에 데이터 구조 변경이 어렵다.
- 테이블 구조 복잡해질수록 쿼리 성능 저하가 발생한다.
- 테이블 구조를 바꾸기 위한 변경에 DBA의 승인이 필요하기 때문에 개발 속도의 저하가 발생한다.

이런 문제를 해결하기 위해 `NoSQL`이 등장하게 된다.

# NoSQL이란?

`NoSQL(Not Only SQL)`은 관계형 데이터베이스와 다르게 유연한 스키마, 비정형 데이터 저장을 지원하는 데이터베이스다. 마이크로서비스에 적합하도록 설계된 NoSQL은 다음과 같은 특징을 가진다

- 실시간 응답 처리 (지연 시간 최소화)
- 수평적 확장성 (노드 추가로 성능 향상)
- 고가용성 (복제 및 장애 복구 지원)
- 클라우드 네이티브 (DBaaS 등과 연계 용이)
- 단순성 (개발자 사용 편의성)
- 유연성 (다양한 데이터 유형 저장 가능)

# NoSQL의 주요 유형

| 유형 | 설명 | 사용 사례 |
| --- | --- | --- |
| `그래프형` | 노드-엣지-속성 구조. 관계 중심의 데이터에 적합 | SNS, 추천 시스템 |
| `문서형` | JSON 등 문서 단위로 저장. 구조 유연함 | 블로그, CMS, 전자상거래 |
| `칼럼형` | 열 단위로 저장. 대규모 분석 작업에 효율적 | 로그 수집, BI 시스템 |
| `키-값형` | 단순한 Key-Value 쌍. 응답 속도 빠름 | 세션 저장, 캐시, 게임 서버 |

# 키-값형 데이터베이스와 Redis

`Redis`는 대표적인 키-값형 NoSQL로, Remote Dictionary Server의 약자다. `메모리 기반`으로 동작하며, 빠른 응답속도와 유연한 자료 구조로 많은 개발자에게 사랑받는다.

- 다양한 언어 클라이언트(Java, Python, Go 등) 지원
- Stack Overflow 5년 연속 인기 DB 1위(2017~2021)

# Redis의 특징

## 실시간 응답

Redis는 모든 데이터를 디스크가 아닌 메모리(RAM)에 저장하는 인메모리(In-memory) 방식으로 동작한다. 이 덕분에 데이터를 읽고 쓰는 속도가 디스크 기반 데이터베이스에 비해 압도적으로 빠르다.

보통의 디스크 기반 데이터베이스에서는 데이터가 하드디스크(HDD)나 SSD에 저장되고, 요청 시에는 해당 데이터를 디스크에서 읽어 메모리로 올리는 과정이 필요하다. 이때 디스크의 물리적인 읽기/쓰기 속도는 매우 느리며, 특히 HDD는 수천 배 이상 느린 속도로 동작한다. SSD도 빠르긴 하지만 RAM보다는 여전히 한참 느린 저장 장치다.

반면 Redis는 이러한 디스크 접근 과정을 생략하고, 모든 데이터를 RAM에서 즉시 읽고 쓸 수 있기 때문에 지연 시간이 매우 짧다. 사용자나 시스템이 요청을 보냈을 때, 디스크로 가는 대신 RAM에서 바로 처리되므로 수 밀리초(ms) 단위가 아닌 마이크로초(μs) 단위로 응답이 가능하다.

즉, Redis는 메모리를 기반으로 하는 구조 덕분에 극도로 짧은 응답 시간과 높은 처리량을 제공하며, 사용자 경험을 저해하지 않으면서 빠른 데이터 처리가 필요한 모든 서비스 환경에 적합하다.

## 다양한 자료 구조 지원

Redis는 단순 문자열뿐 아니라 다음과 같은 자료구조를 저장할 수 있다.

- `String`, `Hash`, `List`, `Set`, `Sorted Set`, `Hyperloglog`, Streams 등
- 프로그래밍 언어 자료구조와 유사하기 때문에 임피던스 불일치를 해소한다.

> 임피던스 불일치(Impedance Mismatch)는 프로그래밍 언어의 객체 모델과 관계형 데이터베이스의 테이블 모델 사이의 구조적 차이로 인해 발생하는 불일치 현상을 말한다
> 

## 싱글 스레드 기반

![image](https://github.com/user-attachments/assets/68dc23f8-2caa-44cf-bbe2-4695574cadfc)


Redis는 `메인 스레드` 하나에서 이벤트 루프 방식으로 작동한다. 이 구조 덕분에 Redis는 전체 아키텍처가 단순하고 효율적이며, 설치나 운영 측면에서 가볍다.

메인 스레드 하나만으로도 충분한 성능을 낼 수 있기 때문에 CPU가 적은 환경에서도 고성능 처리가 가능하다. 실제로 대부분의 명령어는 메모리 내에서 처리되므로 지연 시간이 거의 없고, 수천~수만 TPS(초당 처리량)를 무리 없이 소화할 수 있다.

다만 이 구조에는 단점도 존재한다. Redis는 요청을 하나씩 처리하기 때문에, 특정 클라이언트가 시간이 오래 걸리는 명령어를 실행하면, 그 명령이 끝날 때까지 다른 클라이언트 요청도 처리되지 못하고 대기하게 된다. 이런 이유로 `keys *`, `sort`, `save` 등 응답 시간이 긴 커맨드는 제한적으로 사용하는 것이 좋다.

## 고가용성: Sentinel

Redis는 고가용성을 위해 Sentinel(센티넬) 기능을 제공한다. Sentinel은 Redis 서버를 지속적으로 모니터링하고, 마스터 노드에 장애가 발생하면 자동으로 복구(failover)를 수행한다.

마스터 노드에 문제가 생기면 Sentinel은 슬레이브 노드 중 하나를 자동으로 마스터로 승격시키고, 나머지 슬레이브는 새 마스터를 기준으로 다시 복제 구조를 재정렬한다. 이 모든 과정은 자동으로 수행되며, 애플리케이션은 Sentinel을 통해 Redis에 연결하고 있기 때문에 마스터가 바뀌더라도 엔드포인트를 수정할 필요 없이 연결을 유지할 수 있다. 결과적으로 Sentinel은 서비스 중단 없이 Redis를 안정적으로 운영할 수 있게 도와주는 핵심 구성 요소다.

## 수평 확장: Redis Cluster

Redis는 단일 인스턴스 구조 외에도 클러스터 모드(Redis Cluster)를 통해 수평적 확장을 지원한다. 클러스터를 사용하면 데이터를 자동으로 샤딩(분산 저장)할 수 있어, 성능과 저장 용량 모두 확장 가능하다.

Redis Cluster에서는 전체 데이터를 여러 노드에 나눠 저장하며, 각 노드는 자신이 맡은 데이터 슬롯 범위만을 관리한다. 클러스터 내의 각 노드는 클러스터 버스(Cluster Bus)라는 내부 프로토콜을 통해 서로를 모니터링하고, 마스터 노드에 장애가 생기면 자동으로 슬레이브를 승격시켜 페일오버를 수행한다. 이러한 구조는 사용자 입장에서는 마치 하나의 Redis처럼 보이도록 해주며, 애플리케이션에서는 별다른 샤딩 처리 없이 Redis를 그대로 사용하는 방식으로 구현 가능하다.

## 클라우드 네이티브 / 멀티 클라우드

- 다양한 클라우드 서비스 제공한다.

| 플랫폼 | Redis 서비스 |
| --- | --- |
| AWS | Amazon ElastiCache for Redis |
| GCP | Cloud Memory Store for Redis |
| Azure | Azure Cache for Redis |
| NHN/NAVER Cloud | EasyCache / Cloud DB for Redis |
- 글로벌 서비스 배포, 낮은 지연 시간, 클라우드 간 이중화 지원

# Redis의 마이크로서비스 활용

## 데이터 저장소

마이크로서비스 아키텍처에서는 각 서비스가 독립적으로 실행되며, 이를 위해 자체 데이터 저장소를 가지는 것이 이상적이다. Redis는 이러한 구조에 적합한 경량 고성능 저장소로, 각 마이크로서비스에서 개별적인 데이터 저장소로 사용할 수 있다.

- 다양한 자료 구조(String, Hash, List, Set 등)를 지원해 서비스 특성에 맞는 데이터 구조 설계가 가능하며, 모든 데이터는 메모리에서 처리되기 때문에 응답 속도가 빠르고 처리량이 높다.
- Redis는 AOF(Append-Only File) 및 RDB(Redis Database Snapshot) 방식으로 데이터를 디스크에 저장할 수 있어, 메모리 기반 저장소임에도 불구하고 영속성을 확보할 수 있다.
- 설치와 운영이 간편하며, 복잡한 로드밸런서나 프록시 없이도 Sentinel 또는 클러스터 구성을 통해 고가용성(HA, High Availability)을 실현할 수 있다.

## 메시지 브로커

마이크로서비스 환경에서는 각 서비스가 독립적으로 배포되고 동작하기 때문에, 서비스 간 통신을 위한 비동기 메시징 시스템이 중요하다. Redis는 본래 데이터 저장소로 알려져 있지만, 메시지 브로커 역할도 탁월하게 수행할 수 있다.

- `Pub/Sub`, `List`, `Stream`

Redis Stream은 단순 메시지 전송을 넘어서 메시지의 상태를 저장하고, 여러 소비자가 순차적이거나 병렬적으로 메시지를 처리할 수 있도록 해주어, 카프카와 같은 고급 메시지 브로커의 역할을 일부 대체할 수 있다.

이처럼 Redis는 데이터 저장소뿐만 아니라, 서비스 간 비동기 통신을 위한 메시지 브로커로도 활용되며, 하나의 도구로 다양한 역할을 수행할 수 있다는 점에서 마이크로서비스 환경에 매우 유용하다.
