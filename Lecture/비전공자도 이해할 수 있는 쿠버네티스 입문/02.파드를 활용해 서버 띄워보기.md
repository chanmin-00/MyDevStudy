# 파드란?

도커에서는 하나의 프로그램을 실행하는 단위를 컨테이너(Container) 라고 부른다. 반면 쿠버네티스에서는 하나의 프로그램을 실행하는 단위를 파드(Pod) 라고 한다.

**즉, 파드는 쿠버네티스에서 프로그램을 실행하는 가장 작은 단위로 이해할 수 있다.**

- 쿠버네티스에서 관리되는 가장 작은 배포 단위
- 일반적으로 하나의 파드에는 하나의 컨테이너가 포함된다.
- 필요에 따라 하나의 파드에 여러 개의 컨테이너를 포함할 수도 있다.

<img width="661" height="435" alt="image" src="https://github.com/user-attachments/assets/c47aa2f4-14b2-4de8-8e68-c5320dbf3da7" />

쿠버네티스에서 파드(Pod)는 컨테이너를 감싸는 단위이다. 따라서 컨테이너가 실행되더라도, 쿠버네티스에서는 보통 컨테이너가 몇 개라고 말하지 않고, 파드가 몇 개라고 표현한다.

- 2개의 결제 서버가 띄워져 있다.
    
    → 2개의 결제 서버 파드가 띄워져 있다.
    
- 1개의 결제 서버가 죽었다.
    
    → 1개의 결제 서버 파드가 죽었다.
    
- 업로드 서버를 하나 띄운다.
    
    → 업로드 서버 하나를 파드로 띄운다.
    

### **파드 실행 원리**

쿠버네티스도 도커와 마찬가지로 **이미지(Image)를 기반으로 파드를 실행**한다.

<img width="635" height="367" alt="image" src="https://github.com/user-attachments/assets/cd0bf09b-329c-43a5-85f7-10ea655d9a54" />

동작 과정은 다음과 같다

1. 필요한 **이미지**를 내려받는다.
2. 해당 이미지를 기반으로 **컨테이너**를 띄운다.
3. 컨테이너를 감싸는 형태로 **파드**를 실행한다.

즉, **파드는 컨테이너를 포함하는 실행 단위**이며, 쿠버네티스는 컨테이너가 아닌 파드를 중심으로 리소스를 관리한다.

# 웹 서버(Nginx)를 파드(Pod)로 띄워보기

쿠버네티스에서 파드를 생성하는 방법은 크게 두 가지가 있다.

1. **CLI를 활용하는 방법**
2. **YAML 파일을 활용하는 방법**

실제 현업에서는 반복적인 작업을 줄이기 위해 **YAML 파일**을 작성해서 사용하는 경우가 훨씬 많다.

### Pod 정의

```yaml
apiVersion: v1
kind: Pod
```

- 쿠버네티스에는 다양한 리소스(Resource)가 존재한다.
- 그중에서 **Pod라는 리소스를 만들겠다**는 의미이다.
- apiVersion은 Pod를 작성할 때 항상 v1을 사용한다. (공식 문서에서도 명시)

공식문서에 나와있는 nginx-pod.yaml 예시이다.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
spec:
  containers:
  - name: nginx-container
    image: nginx:1.14.2
    ports:
    - containerPort: 80
```

```yaml
metadata:
	name: nginx-pod
```

- 파드의 기본 정보를 기재하는 영역
- name: nginx-pod → 파드의 이름을 nginx-pod로 지정

```yaml
spec:
	containers:
	- name: nginx-container
		image: nginx
		ports:
			- containerPort: 80
```

- 파드의 구체적인 동작 방식을 정의한다.
- 하나의 파드 안에 컨테이너가 들어가기 때문에, 컨테이너에 대한 설정을 적는다
- name: nginx-container → 컨테이너 이름
- image: nginx:1.14.2 → 사용할 도커 이미지 (태그명 붙일 수도 있음)
- containerPort: 80 → 컨테이너가 내부적으로 사용하는 포트 (실제로는 nginx가 기본적으로 80 포트에 뜨므로 값이 실행 동작에 영향을 주진 않음, 단지 문서화 목적)
    
    예를 들어 containerPort: 8080으로 적어도 nginx는 여전히 80 포트에서 실행된다.
    

### 파드 생성하기

위 YAML 파일을 저장한 뒤 다음 명령어로 적용한다

```bash
kubectl apply -f nginx-pod.yaml
```

- f : 파일을 지정한다는 의미
- apply : 해당 리소스를 생성/적용
- nginx-pod.yaml : 작성한 매니페스트 파일 이름

<img width="486" height="60" alt="image" src="https://github.com/user-attachments/assets/bdd69504-e5e8-4bc1-a7c6-90ac952a8bd7" />

이 명령어를 실행하면 YAML에 정의된 내용대로 **Pod가 생성**된다.

### 파드 확인하기

생성된 파드 상태는 다음 명령어로 확인할 수 있다.

```bash
kubectl get pods
```

<img width="467" height="88" alt="image" src="https://github.com/user-attachments/assets/ad1eaa0c-17a8-426c-9fa6-adc6e75c273e" />

- **READY** → 파드 내 컨테이너 개수 / 정상 실행 중인 컨테이너 개수
- **RESTARTS** → 컨테이너가 재시작된 횟수 (예: 장애 발생 시 자동 재시작)
- **STATUS** → 현재 상태 (Running, Pending, Error 등)

즉, 1/1 이라면 1개의 컨테이너가 정상적으로 실행 중이라는 의미이다.

### 접속 오류

파드가 정상적으로 실행되었더라도, **외부에서 바로 접속할 수 있는 상태는 아니다.** 파드는 기본적으로 **쿠버네티스 클러스터 내부 네트워크에서만 접근 가능**하다.

<img width="424" height="282" alt="image" src="https://github.com/user-attachments/assets/0fab6c1a-311e-4b39-9f4e-b36546f0771c" />

### cf) **매니페스트(Manifest) 파일**

쿠버네티스에서는 이렇게 리소스를 정의하는 YAML 파일을 **매니페스트 파일**이라고 부른다. 다양한 리소스(Pod, Service, Deployment 등)를 생성/관리할 때 사용한다.

도커의 Dockerfile처럼, 실행 환경을 정의하는 일종의 문서라고 이해하면 된다.

# 파드로 띄운 프로그램에 접속이 안 되는 이유

도커에서는 **컨테이너 내부와 외부의 네트워크가 서로 독립적으로 분리**되어 있다. 쿠버네티스도 마찬가지로 네트워크를 분리하지만, 구분하는 단위가 조금 다르다.

**쿠버네티스에서는 파드 내부와 외부가 네트워크적으로 분리**되어 있다.하지만 **파드 내부와 컨테이너 내부는 네트워크를 공유**한다. 즉, 파드 안의 컨테이너들은 같은 네트워크 공간을 함께 사용한다.

따라서 쿠버네티스를 로컬에 설치했다면, **파드 네트워크는 로컬 컴퓨터 네트워크와 분리**되어 있으므로 외부에서 바로 파드에 접근할 수 없다. 그래서 파드 안에서 실행 중인 Nginx 서버에 직접 요청을 보내도 응답이 없는 것이다.

<img width="452" height="248" alt="image" src="https://github.com/user-attachments/assets/2509eabf-3035-49e1-9bd0-56a5bbb708c2" />

Nginx 웹 페이지에 접근하려면 다음 두 가지 방법이 있다.

1. **파드 내부로 들어가 요청 보내기**
2. **포트 포워딩(Port Forwarding)을 이용해 외부와 연결하기**

### 1. 파드 내부로 들어가서 Nginx로 요청 보내기

파드 내부로 직접 접속해 Nginx가 잘 동작하는지 확인할 수 있다. nginx-pod 내부로 들어간다.

```bash
kubectl exec -it nginx-pod -- bash
```

<img width="489" height="65" alt="image" src="https://github.com/user-attachments/assets/dc67717d-bbf8-44f5-b1c2-5f12c1eb34df" />

이후 파드 내부에서 localhost:80으로 요청을 보낸다. 파드 내부는 네트워크가 분리되지 않기 때문에, 요청이 정상적으로 응답된다.

```bash
curl localhost:80 
```

<img width="540" height="382" alt="image" src="https://github.com/user-attachments/assets/8af681ce-4048-405c-8726-5ce465561477" />

### 2. 포트 포워딩을 활용해 Nginx로 요청보내기

파드를 외부에서 접근할 수 있도록 **내 로컬 포트와 파드 포트를 연결**한다.

<img width="609" height="342" alt="image" src="https://github.com/user-attachments/assets/9b72b46f-5381-46b8-9e74-d48d00ed5bd9" />

```bash
kubectl port-forward pod/nginx-pod 80:80
```

- 앞 80 : 내 로컬에서 노출되는 포트 번호 (예: localhost:80)
- 뒤 80 : 파드 내부에서 사용하는 포트 번호

<img width="498" height="160" alt="image" src="https://github.com/user-attachments/assets/6b85c35d-082b-41b2-bd51-3cc693512230" />

이때 kubectl port-forward는 내 로컬(127.0.0.1:80)에 리스너를 띄우고, 트래픽을 쿠버네티스 API 서버를 통해 원격 파드로 터널링한다. 따라서 클러스터가 원격(NCP 등)에 있어도 localhost:80으로 접속할 수 있다.

### 파드 삭제하기

```bash
kubectl delete pod nginx-pod
```

# 백엔드(Spring  Boot) 서버를 파드로 띄워보기

### Dockerfile 작성하기

스프링 부트 프로젝트는 빌드 결과물이 JAR 파일이다. 이 JAR 파일을 도커 이미지로 묶기 위해 Dockerfile을 작성한다.

```docker
FROM openjdk:17-jdk

COPY build/libs/*SNAPSHOT.jar app.jar

ENTRYPOINT ["java", "-jar", "/app.jar"]
```

- `FROM openjdk:17-jdk` : OpenJDK 17 환경을 기반으로 컨테이너 생성
- `COPY` : 로컬에서 빌드된 JAR 파일(build/libs/*SNAPSHOT.jar)을 컨테이너 내부로 복사해 app.jar로 저장
- `ENTRYPOINT` : 컨테이너 실행 시 java -jar /app.jar 실행 → 애플리케이션 자동 실행

스프링 부트 프로젝트에서 빌드된 JAR 파일을 기반으로 도커 이미지를 만든다.

### Jar 파일 빌드

나는 멀티 모듈 프로젝트이므로 필요한 모듈만 빌드할 수 있다.

```bash
./gradlew clean build
./gradlew :nlp-server:build
```

<img width="402" height="197" alt="image" src="https://github.com/user-attachments/assets/9dbb360c-6d58-4abb-86c9-3fd83f3dc337" />

### **도커 이미지 생성**

생성된 JAR 파일을 기반으로 도커 이미지를 만든다.

```docker
docker build -t spring-server .
```

- 현재 디렉토리의 Dockerfile을 이용해 spring-server라는 이름의 이미지를 생성한다.

<img width="537" height="237" alt="image" src="https://github.com/user-attachments/assets/726d1b17-c8c1-454b-8a20-a71f5ab835e1" />

이미지가 잘 생성되었는지 확인한다.

```docker
docker image ls
```

<img width="651" height="32" alt="image" src="https://github.com/user-attachments/assets/a791562c-a508-470f-9e71-162e57f1ac7f" />

- 위 명령어를 통해 해당 이미지가 잘 생성이 되었는지를 확인할 수 있다.

### **매니페스트 파일 작성 (chat-pod.yaml)**

이제 만든 이미지를 기반으로 파드를 생성한다.

```yaml
apiVersion: v1
kind: Pod

metadata:
  name: chat-pod

spec:
  containers:
    - name: chat-container
      image: spring-server
      ports:
        - containerPort: 8080
```

- image: spring-server → 방금 만든 이미지 사용
- ports.containerPort: 8080 → 애플리케이션 기본 포트

### 파드 생성

작성한 매니페스트 파일을 적용한다.

```yaml
kubectl apply -f chat-pod.yaml
```

<img width="544" height="164" alt="image" src="https://github.com/user-attachments/assets/8b67f058-d88b-4f6e-8abb-03eb46093b3f" />

생성된 파드를 확인했을 때, 상태가 ImagePullBackOff로 표시되었다. 에러가 발생한 것이다.

# 이미지가 없다고 에러가 뜨는 이유 (이미지 풀 정책)

스프링 프로젝트를 도커 이미지로 빌드한 뒤 파드로 실행했을 때, ImagePullBackOff 에러가 발생했다.

이 문제는 **이미지 풀 정책(Image Pull Policy)** 때문에 발생한 것이다.

### 이미지 풀 정책

쿠버네티스가 매니페스트(YAML) 파일을 읽고 파드를 생성할 때, 컨테이너 이미지를 어디서 가져올지에 대한 규칙을 **Image Pull Policy**라고 한다. 정책에 따라서 이미지를 받아오는 방법이 달라진다.

1. `Always`
    
    무조건 원격 레지스트리(도커 허브, ECR 등)에서 이미지를 가져온다. 로컬에 이미지가 있어도 사용하지 않는다. 개발 직후 빌드된 로컬 이미지에는 맞지 않다.
    
2. `IfNotPresent`
    
    로컬에서 먼저 이미지를 찾는다. 없을 경우에만 원격 레지스트리에서 가져온다.
    
3. `Never`
    
    무조건 로컬에 있는 이미지만 사용한다.
    

### 매니페스트 파일에 이미지 풀 정책설정하는 방법

```yaml
apiVersion: v1
kind: Pod

metadata:
  name: chat-pod

spec:
  containers:
    - name: chat-container
      image: spring-server
      ports:
        - containerPort: 8080
      imagePullPolicy: Always
```

이렇게 설정하면 쿠버네티스는 먼저 로컬에서 이미지를 찾는다.

### 기존 매니페스트 파일 다시 살펴보기

```yaml
apiVersion: v1
kind: Pod

metadata:
  name: chat-pod

spec:
  containers:
    - name: chat-container
      image: spring-server
      ports:
        - containerPort: 8080
```

기존 매니페스트 파일을 보면 imagePullPolicy를 명시하지 않았다. 이 경우 기본 동작은 다음과 같다

- 태그가 latest이거나 명시되지 않은 경우 → Always 적용
- 태그가 latest가 아닌 경우 → IfNotPresent 적용

즉, spring-server 이미지가 latest로 인식되어 Always가 적용되었고, 쿠버네티스는 원격 레지스트리에서 이미지를 가져오려 했지만 등록된 적이 없으니 에러가 발생한 것이다.

### **ImagePullPolicy 적용하기**

쿠버네티스에서 파드가 이미지를 가져오는 방식을 제어하려면 imagePullPolicy를 정의해야 한다.

```yaml
apiVersion: v1
kind: Pod

metadata:
  name: chat-pod

spec:
  containers:
    - name: chat-container
      image: spring-server
      ports:
        - containerPort: 8080
      imagePullPolicy: IfNotPresent
```

기존 파드를 삭제한 뒤 다시 적용한다.

```bash
kubectl delete pod chat-pod
kubectl apply -f chat-pod.yaml
```

### **원격 클러스터 사용 시 발생한 문제**

<img width="655" height="120" alt="image" src="https://github.com/user-attachments/assets/2fa47df0-ae7b-4a1e-90d1-2ecbbe1a134f" />

하지만 나는 원격 쿠버네티스 클러스터(NCP) 를 사용하고 있었기 때문에 문제가 다시 발생했다. 원격 클러스터에서는 내 로컬 도커 이미지에 접근할 수 없으므로, 이미지를 도커 허브(Docker Hub) 같은 원격 레지스트리에 올려야 한다.

```yaml
apiVersion: v1
kind: Pod

metadata:
  name: chat-pod

spec:
  containers:
    - name: chat-container
      image: docker.io/jeongchanmin/spring-server:latest
      ports:
        - containerPort: 8080
      imagePullPolicy: IfNotPresent
```

이렇게 이미지 경로를 **도커 허브에 푸시한 이미지로 변경**했다.

### **또 다른 문제: 아키텍처 차이**

도커 허브에 올린 이미지를 사용했는데도 오류가 발생했다. 그 이유는 **내 로컬 환경과 클라우드 클러스터 환경의 아키텍처가 달랐기 때문**이다.

- 로컬(Mac M2) → arm64
- NCP 클러스터 → amd64

따라서 클러스터 환경에 맞는 아키텍처(amd64)용 이미지를 새로 빌드해야 했다.

```bash
docker buildx build --platform linux/amd64 -t docker.io/jeongchanmin/spring-server:latest .
docker push docker.io/jeongchanmin/spring-server:latest
```

이렇게 멀티 아키텍처를 고려한 이미지를 빌드 후 푸시하면 클러스터에서 정상적으로 동작한다

<img width="527" height="114" alt="image" src="https://github.com/user-attachments/assets/0ff9c931-f1bd-4b6b-a712-34485b1107e4" />

### **파드 동작 확인**

정상적으로 실행된 파드 내부에 접속한다.

```yaml
kubectl exec -it chat-pod -- bash
```

<img width="663" height="46" alt="image" src="https://github.com/user-attachments/assets/6bd99932-6cd8-4905-8bd9-1cfeaf26ceb8" />


### 포트포워딩을 활용해서 확인해보기

파드 내부 애플리케이션이 잘 응답하는지 확인하기 위해 포트포워딩을 설정한다.

```yaml
kubectl port-forward pod/chat-pod 12345:8080
```

- 로컬 12345 포트와 파드의 8080 포트를 연결
- 브라우저에서 http://localhost:12345 접속 시 → 파드 내부 스프링 서버가 정상 응답

<img width="588" height="357" alt="image" src="https://github.com/user-attachments/assets/2cf4b697-a55c-4e33-a5ef-a95cc1eba62f" />

# 백엔드 서버 3개 띄워보기

실제 서비스를 운영하다 보면 트래픽이 증가해 서버가 버벅거리는 경우가 많다. 이럴 때는 서버의 성능을 키우는 수직적 확장(Scale-Up) 대신, 서버 개수를 늘리는 수평적 확장(Scale-Out) 방식을 활용할 수 있다.

### 파드 3개 생성하기

예를 들어 스프링 서버를 3대로 수평적 확장하려면 기존 매니페스트 파일을 다음과 같이 수정한다.

```yaml
apiVersion: v1
kind: Pod

metadata:
  name: chat-pod-1

spec:
  containers:
    - name: chat-container
      image: docker.io/jeongchanmin/spring-server:0.1.2
      ports:
        - containerPort: 8080
      imagePullPolicy: Always

---
apiVersion: v1
kind: Pod

metadata:
  name: chat-pod-2

spec:
  containers:
    - name: chat-container
      image: docker.io/jeongchanmin/spring-server:0.1.2
      ports:
        - containerPort: 8080
      imagePullPolicy: Always

---
apiVersion: v1
kind: Pod

metadata:
  name: chat-pod-3

spec:
  containers:
    - name: chat-container
      image: docker.io/jeongchanmin/spring-server:0.1.2
      ports:
        - containerPort: 8080
      imagePullPolicy: Always
```

위 매니페스트에는 **3개의 파드**가 정의되어 있다.

### 파드 생성 및 확인

파드를 생성한다.

```yaml
kubectl apply -f chat-pod.yaml
```

<img width="471" height="79" alt="image" src="https://github.com/user-attachments/assets/5140dded-1166-4555-bc7b-ef9c8c084c17" />

정상적으로 생성되었는지 확인한다.

```yaml
kubectl get pods
```

<img width="412" height="127" alt="image" src="https://github.com/user-attachments/assets/1d10c75d-3a87-4986-ad08-8efc19f648d3" />

결과를 보면, chat-pod-1, chat-pod-2, chat-pod-3 세 개의 파드가 실행 중인 것을 확인할 수 있다. 즉, **스프링 서버가 세 개 띄워진 것**이다.

### 문제점

하지만 실제 현업 환경에서는 수십 개, 수백 개의 파드를 운영하는 경우가 많다. 서버를 100개 띄워야 한다면, 매니페스트 파일을 100번 복사해서 작성해야 한다.

또한 트래픽은 항상 일정하지 않고 변하기 때문에, 수요에 따라 서버 개수를 늘렸다 줄였다 해야 한다. 그때마다 YAML 파일을 복사하거나 지우는 방식으로 관리하는 것은 매우 비효율적이다.

이러한 불편함을 해결하기 위해 **쿠버네티스는 디플로이먼트(Deployment)라는 리소스를 제공한다.**

# 파드 디버깅 하는 방법

개발이나 운영 과정에서 파드가 정상적으로 실행되지 않는 경우가 자주 발생한다. 이때 쿠버네티스는 다양한 **디버깅 명령어**를 제공한다.

nginx:1.26.4라는 존재하지 않는 버전의 이미지를 태그한 뒤 파드를 실행해보자.

```yaml
apiVersion: v1
kind: Pod

metadata:
  name: nginx-pod

spec:
  containers:
  - name: nginx-container
    image: nginx:1.26.4
    ports:
    - containerPort: 80
```

<img width="660" height="56" alt="image" src="https://github.com/user-attachments/assets/20534e17-2a72-4913-b455-b57fbe1bbb4a" />

확인해보면, 파드가 ErrImagePull 상태가 된다. 즉, 이미지를 가져오는 과정에서 에러가 발생했다는 의미이다.

### 파드 상태 상세 확인

겉으로는 ErrImagePull만 보이지만, 구체적인 원인을 확인하려면 describe 명령어를 사용한다

```bash
kubectl describe pod nginx-pod
```

파드가 생성되면서 발생한 **이벤트 로그**들이 자세히 출력된다. 예를 들어, “이미지를 찾을 수 없음” 같은 구체적인 에러 메시지를 확인할 수 있다

<img width="657" height="139" alt="image" src="https://github.com/user-attachments/assets/1be04c97-7c20-4d0c-8345-c1bba9ffdfb7" />

### 컨테이너 로그 확인

이미 파드가 실행되었으나 내부 애플리케이션에서 에러가 발생했다면, 로그를 확인하는 것이 가장 빠르다.

```bash
kubectl logs nginx-pod
```

컨테이너 내부에서 실행된 **애플리케이션 로그**를 볼 수 있다.

<img width="594" height="279" alt="image" src="https://github.com/user-attachments/assets/ece18ae0-ee92-47fe-86ee-d594969e5455" />

### **파드 내부 접속**

직접 파드 내부에 들어가서 상태를 확인할 수도 있다.

```bash
kubectl exec -it nginx-pod -- bash
```

- 여기서 bash는 파드 내부에 bash 쉘이 설치되어 있어야 동작한다.
- 만약 에러가 난다면 sh를 대신 사용한다.

```bash
kubectl exec -it nginx-pod -- sh
```

컨테이너 환경에 따라 기본 쉘이 다르므로, bash가 안 되면 sh로 접속 시도하면 된다.
