# 디플로이먼트란?

디플로이먼트는 **파드를 묶음 단위로 관리할 수 있게 해주는 쿠버네티스 리소스**이다. 단순히 개별 파드를 생성, 운영하는 대신, 디플로이먼트를 이용하면 파드들을 하나의 그룹처럼 다루면서 배포와 관리가 훨씬 편리해진다.

실무에서는 파드를 직접 수동으로 생성하기보다, 디플로이먼트를 통해 자동으로 파드를 배포하고 운영하는 것이 일반적이다.

### 디플로이먼트의 장점

1. **손쉬운 확장**
    
    원하는 파드 개수를 지정하면 디플로이먼트가 알아서 해당 수만큼 파드를 생성한다. 예를 들어 “100개”라고 입력하면 자동으로 100개의 파드가 준비된다.
    
2. **자동 복구**
    
    실행 중인 파드가 에러 등으로 종료되더라도, 디플로이먼트가 자동으로 새로운 파드를 생성해 설정된 파드 수를 유지한다. 즉, 항상 안정적인 서비스 상태를 보장한다.
    
3. **일괄 관리**
    
    동일한 구성을 가진 여러 파드를 한 번에 **일시 중지, 삭제, 업데이트**할 수 있다. 예를 들어 100개의 파드가 동시에 실행 중이라도, 디플로이먼트를 통해 한 번의 명령으로 손쉽게 제어 가능하다.
    

이 모든 것이 가능한 이유는 **파드를 묶음 단위로 관리하는 구조** 덕분이다.

### 디플로이먼트의 구조

<img width="518" height="347" alt="image" src="https://github.com/user-attachments/assets/108800b7-0fa4-4e59-9abe-0c65251db1e2" />

디플로이먼트는 직접 파드를 관리하지 않는다. 대신 **레플리카셋(ReplicaSet)** 이라는 중간 계층을 통해 파드를 제어한다.

- **디플로이먼트 → 레플리카셋 → 파드**
- *레플리카(replica)* : 복제본
- *레플리카셋(replica set)* : 동일한 파드 복제본을 묶어 관리하는 집합

즉, 디플로이먼트는 레플리카셋을 관리하고, 레플리카셋은 여러 파드를 관리하는 구조로 이루어져 있다.

# 디플로이먼트를 활용해 백엔드 서버 3개 띄워보기

트래픽이 많아지면 서버가 버벅거릴 수 있다. 이를 해결하는 대표적인 방식이 **수평적 확장(Scale Out)** 이다. 즉, 서버의 개수를 늘려 부하를 분산시키는 것이다.

이전에는 파드를 직접 정의해서 스프링 부트 서버를 3개 띄웠다면, 이제는 **디플로이먼트(Deployment)** 를 활용해 훨씬 간단하게 같은 효과를 얻을 수 있다.

### **1. 기존 파드 삭제**

우선, 기존에 직접 만든 파드들을 모두 삭제한다.

```bash
kubectl delete pod chat-pod-1
kubectl delete pod chat-pod-2
kubectl delete pod chat-pod-3
```

### **2. 디플로이먼트 매니페스트 작성**

```yaml
apiVersion: apps/v1
kind: Deployment
```

- Deployment 리소스는 반드시 apiVersion: apps/v1 을 사용한다.
- 이는 쿠버네티스 공식 문서에 정의된 형식이며, 디플로이먼트를 사용할 때의 기본 규칙이다.

```yaml
metadata:
  name: chat-deployment
```

- metadata는 디플로이먼트 자체의 이름을 정의하는 부분이다.
- 여기서는 디플로이먼트 이름을 chat-deployment로 지정했다.

```yaml
spec:
  replicas: 3
  selector:
    matchLabels:
      app: backend-app
  
  template:
    metadata:
      labels:
        app: backend-app
    spec:
      containers:
        - name: chat-container
          image: docker.io/jeongchanmin/spring-server:0.1.2
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
```

- **replicas**
    - 파드 복제본의 개수를 지정한다.
    - 3으로 설정했으므로 동일한 파드가 3개 생성된다.
- **selector**
    - 디플로이먼트가 관리할 파드를 선택하는 기준이다.
    - 여기서는 `app: backend-app` 레이블을 가진 파드를 디플로이먼트가 관리한다.
- **template**
    - **새로운 파드를 생성할 때 참고할 템플릿이다.**
    - metadata에 파드에 부여할 레이블을 정의하고,
    - spec에는 파드 안에서 실행될 컨테이너 정보를 정의한다.
- **containers**
    - 컨테이너 이름은 chat-container로 지정했다.
    - 도커 허브의 jeongchanmin/spring-server:0.1.2 이미지를 사용한다.
    - imagePullPolicy: IfNotPresent는 로컬에 이미지가 있으면 재사용하고, 없을 때만 원격에서 가져온다는 의미다.
    - ports에는 컨테이너 내부에서 오픈할 포트를 작성한다. (8080)

최종 매니페스트 (yaml)

```yaml
apiVersion: apps/v1
kind: Deployment

metadata:
  name: chat-deployment

spec:
  replicas: 3
  selector:
    matchLabels:
      app: chat-app

  template:
    metadata:
      labels:
        app: chat-app
    spec:
      containers:
        - name: chat-container
          image: docker.io/jeongchanmin/spring-server:0.1.2
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
```

### 3. 디플로이먼트 생성

작성한 매니페스트를 적용한다.

```bash
kubectl apply -f chat-deployment.yaml
```

- 적용이 완료되면, 디플로이먼트가 자동으로 레플리카셋을 만들고, 레플리카셋이 파드들을 관리한다.

<img width="583" height="59" alt="image" src="https://github.com/user-attachments/assets/32bec3c9-68c2-4dd3-b0f0-3e20563cb340" />

### 4. 생성 결과 확인

생성한 후에는 제대로 생성이 되었는지 확인해본다.

**디플로이먼트 상태 확인**

```bash
kubectl get deployment
```

- 3/3 이 표시되면, 3개의 파드가 모두 정상적으로 실행 중임을 의미한다.

<img width="520" height="100" alt="image" src="https://github.com/user-attachments/assets/3bcd7e9a-1393-4295-86f2-6aac966b5008" />

**레플리카셋 확인**

디플로이먼트가 생성한 레플리카셋이 확인된다. 이 레플리카셋이 실제 파드들을 제어한다.

```bash
kubectl get replicaset
```

<img width="535" height="81" alt="image" src="https://github.com/user-attachments/assets/ae44de53-e3e1-4825-8712-6c47470d665a" />

**파드 확인**

```bash
kubectl get pods
```

<img width="543" height="98" alt="image" src="https://github.com/user-attachments/assets/33a525b8-49e6-4808-bd53-7cdde8f7e5bc" />

동일한 파드가 3개 생성된 것을 확인할 수 있다. 즉, 파드를 하나씩 직접 만들지 않아도 디플로이먼트가 정의한 개수만큼 자동으로 생성해준다.

### 트래픽 분산의 필요성

이제 백엔드 서버 3개가 각각 파드로 실행되고 있다. 하지만 실제 요청을 보낼 때 사용자가 직접 파드 주소를 찾아서 요청을 보내는 것은 불가능하다.

예를 들어, A 사용자는 pod-1에, B 사용자는 pod-2에, C 사용자는 pod-3에 이런 식으로 균등하게 접속해야 하는데, 이를 사용자가 직접 처리할 수는 없다.

따라서 **파드 앞단에 요청을 받아서 여러 파드로 균등하게 분배해주는 역할**이 필요하다. 쿠버네티스에서는 이를 **서비스(Service)** 라는 리소스로 제공한다.

# 서비스란?

**서비스(Service)** 는 쿠버네티스에서 외부로부터 들어오는 트래픽을 받아 파드들에 **균등하게 분배**해주는 역할을 한다. 즉, 서비스는 일종의 **로드밸런서**로 동작한다.

실제 서비스 환경에서는 파드에 직접 접근하거나 포트 포워딩을 통해 요청을 보내지 않는다. 대신 서비스라는 리소스를 생성해 클라이언트 요청을 서비스로 보내고, 서비스가 알아서 파드들에게 분배하도록 설정하는 것이 일반적이다.

### 서비스의 구조

<img width="526" height="479" alt="image" src="https://github.com/user-attachments/assets/ae404097-5dc8-4ab3-819d-fb13a734d893" />

요청은 먼저 서비스로 들어오고, 서비스는 이를 내부적으로 연결된 파드들에 균등하게 나눠준다. 따라서 서비스는 단순히 트래픽 분배기 역할을 하는 것뿐만 아니라, 사용자의 요청을 받아주는 진입 지점이 되기도 한다.

정리하면, **컨테이너 내부의 애플리케이션에 접근하려면 서비스를 생성해야 한다**.

# 서비스를 활용해 백엔드 서버와 통신해보기

앞에서 디플로이먼트를 이용해 백엔드 서버 3개를 띄웠다. 이제는 이 파드들에 대한 요청이 균등하게 분배되도록 **서비스(Service)** 를 추가해야 한다.

### **1. 서비스 매니페스트 yaml 작성**

```yaml
apiVersion: v1
kind: Service
```

- 서비스는 apiVersion: v1을 사용한다.
- 리소스 종류는 Service이다.

```yaml
metadata:
  name: chat-service
```

- 서비스의 이름을 chat-service로 지정한다.

```yaml
spec:
  type: NodePort
```

- 서비스의 동작 방식을 정의한다.
- 여기서는 NodePort를 사용해 클러스터 외부에서도 접근 가능하도록 설정한다.

### 2. 서비스의 종류

쿠버네티스에서 서비스는 여러 방식으로 동작할 수 있다.

- **NodePort**
    - 노드의 특정 포트를 열어 외부에서 접근 가능하도록 한다.
    - 노드 퍼블릭 IP + NodePort 조합으로 접근한다.
- **ClusterIP**
    - 클러스터 내부 전용 IP를 할당한다.
    - 파드 간 내부 통신에는 사용 가능하지만, 외부에서는 접근 불가하다. 그래서 보안적으로는 좋기는 하다.
- **LoadBalancer**
    - 클라우드 벤더(AWS, GCP, NCP 등)의 로드밸런서를 연동한다.
    - 외부에서 직접 접근할 수 있도록 연결된다.

```yaml
spec:
  type: NodePort
  selector:
    app: chat-app
  ports:
    - protocol: TCP
      port: 8080 # 쿠버네티스 내부에서 Service에 접속하기 위한 포트 번호
      targetPort: 8080 # 매핑하기 위한 파드의 포트 번호
      nodePort: 30000 # 외부에서 사용자들이 접근하게 될 표트
```

- **selector**
    - 어떤 파드와 연결할지 결정한다.
    - app: chat-app 레이블을 가진 파드들(디플로이먼트에서 만든 파드들)에 트래픽을 전달한다.
- **ports**
    - port: 서비스가 클러스터 내부에서 열고 있는 포트 번호
    - targetPort: 연결 대상 파드 컨테이너의 포트 번호
    - nodePort: 외부에서 접근할 포트 번호 (30000~32767 범위에서 선택)

<img width="483" height="451" alt="image" src="https://github.com/user-attachments/assets/6a829d6b-2017-44f7-9365-b0b2665f79bf" />

즉, 외부 사용자가 **노드 퍼블릭 IP:30000** 으로 접근하면 서비스가 이를 받아서 내부의 8080 포트로 전달하고 다시 파드 컨테이너의 8080 포트로 트래픽이 흘러가게 된다.

### 3. 서비스 생성 및 확인

아래 명령어를 적용해 서비스 생성을 한다.

```yaml
kubectl apply -f chat-service.yaml
```

<img width="495" height="60" alt="image" src="https://github.com/user-attachments/assets/4e202821-f319-45ee-bbea-23cc1fbf48f1" />

잘 생성이 되었는지 확인본다.

```yaml
kubectl get service
```

<img width="491" height="70" alt="image" src="https://github.com/user-attachments/assets/7a829759-0ea8-4e76-a28b-3edb1a1ca7c7" />

- CLUSTER-IP : 클러스터 내부 전용 IP (외부에서는 접근 불가)
- EXTERNAL-IP : 클라우드 환경에서 로드밸런서 등을 사용하면 표시됨
- PORT(S) : 서비스가 열고 있는 포트와 외부 NodePort 매핑 정보

### 4. 외부 접속 설정

로컬 클러스터라면 노드IP:30000으로 바로 접속 가능하다. 하지만 원격 클러스터(예: 네이버 클라우드)를 사용한다면 추가 설정이 필요하다.

ACG(Access Control Group)에서 내 IP가 해당 NodePort(예: 30000)에 접근할 수 있도록 방화벽 규칙을 열어야 한다. 이후 노드 퍼블릭 IP:30000 으로 접속하면 정상적으로 애플리케이션에 접근 가능하다.

<img width="866" height="777" alt="image" src="https://github.com/user-attachments/assets/11dfff9d-eb71-411d-88e8-f0bcf00ecaa9" />

제대로 접속이 되는 것을 확인할 수 있다.

> 참고 : 쿠버네티스에서 CLUSTER-IP는 클러스터 내부 Pod 간 통신을 위한 가상 IP라 외부에서는 접근할 수 없고, 클러스터 엔드포인트는 쿠버네티스 API 제어용 주소라 애플리케이션 트래픽에는 쓰이지 않기 때문에, NodePort 서비스를 사용했을 때는 반드시 **노드의 퍼블릭 IP + NodePort** 조합으로 접속해야 하며, 운영 환경에서는 외부 접근을 단일화하기 위해 LoadBalancer나 Ingress를 활용하는 것이 일반적이다
> 

# 디플로이먼트를 활용한 서버 개수 조절 방법

서버의 개수를 조절한다는 것은 곧 **파드(Pod)의 개수를 조절한다는 것**을 의미한다. 즉, 서버를 더 많이 띄우고 싶다면 파드의 수를 늘리면 된다.

예를 들어, 트래픽이 많아져 기존의 3대 서버로는 감당하기 어려울 때 서버를 5대로 확장하려면 디플로이먼트 설정에서 **replicas** 값을 변경하면 된다.

### 1. replicas 수정하기

기존 디플로이먼트 매니페스트(chat-deployment.yaml)에서 replicas 값을 3에서 5로 변경한다.

```yaml
apiVersion: apps/v1
kind: Deployment

metadata:
  name: chat-deployment

spec:
  replicas: 5  # 파드 복제본 개수 (3 → 5)
  selector:
    matchLabels:
      app: chat-app

  template:
    metadata:
      labels:
        app: chat-app
    spec:
      containers:
        - name: chat-container
          image: docker.io/jeongchanmin/spring-server:0.1.2
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
```

### 2. 변경 내용 적용하기

replicas 값을 수정한 후, 아래 명령어로 변경 사항을 반영한다.

```bash
kubectl apply -f chat-deploytment.yaml
```

- apply 명령어는 새로운 리소스를 생성할 때뿐만 아니라, 이미 존재하는 리소스의 **변경 사항을 적용할 때도 사용**된다.
- 쿠버네티스는 수정된 부분만 자동으로 감지하여 업데이트한다.

<img width="499" height="53" alt="image" src="https://github.com/user-attachments/assets/95ba672b-bb12-49b0-b6b4-d53771ddc7b4" />

### 3. 파드 개수 확인하기

명령어를 실행한 뒤, 파드가 늘어났는지 확인한다.

```bash
kubectl get pods
```

<img width="480" height="138" alt="image" src="https://github.com/user-attachments/assets/75aaa1c0-7900-41b6-91da-4cd0ea3e0049" />

kubectl get pods 명령어 결과에서 파드가 5개로 늘어난 것을 확인할 수 있다. 디플로이먼트가 자동으로 새로운 파드를 생성해 지정된 수(5개)를 맞춰준다.

# 서버가 죽었을 때 자동으로 복구하는 기능 (Self-Healing)

쿠버네티스의 가장 강력한 기능 중 하나는 **자동 복구(Self-Healing)** 이다. 즉, 파드가 죽거나 비정상적으로 종료되더라도, **디플로이먼트**가 자동으로 이를 감지하고 새로운 파드를 생성해 시스템 상태를 복구한다.

### 파드와 컨테이너의 관계

하나의 파드 안에는 하나 이상의 컨테이너가 실행된다. 따라서 파드가 종료된다는 것은 내부 컨테이너가 중단되었다는 의미이다.

하지만 파드를 일부러 삭제해보더라도, 디플로이먼트가 관리 중이라면 파드 개수는 그대로 유지된다.

예를 들어, 5개의 파드가 실행 중일 때 다음 명령으로 파드 하나를 삭제한다고 해보자.

```bash
kubectl delete pod chat-deployment-xxxx
```

잠시 후 확인해보면 파드가 **다시 자동으로 생성되어 총 5개로 유지**된다. 

<img width="864" height="293" alt="image" src="https://github.com/user-attachments/assets/ab675d11-04de-454f-ba4c-da40f710c6b9" />

이처럼 디플로이먼트는 “정상적으로 유지해야 할 파드 개수(replicas)”를 기준으로 파드가 죽으면 새로 띄우고, 에러가 나면 다시 재시작시키는 기능을 갖는다. 이를 셀프 힐링(Self-Healing) 또는 자동 복구 기능이라고 부른다.

# 새로운 버전의 서버로 업데이트 시키기

### 1. 새 버전 빌드 및 푸시

먼저 애플리케이션을 다시 빌드하여 새 버전의 Docker 이미지를 만든다.

```yaml
./gradlew :nlp-server:build
```

새로 빌드된 파일을 기반으로 Docker 이미지를 생성한다.

```yaml
docker buildx build --platform linux/amd64 -t docker.io/jeongchanmin/spring-server:0.1.3 --load .
```

Docker Hub에 새로운 버전의 이미지를 푸시한다.

```yaml
docker push docker.io/jeongchanmin/spring-server:0.1.3
```

### 2. 디플로이먼트 매니페스트 수정

이제 디플로이먼트 매니페스트에서 컨테이너 이미지 버전을 업데이트한다.

```yaml
apiVersion: apps/v1
kind: Deployment

metadata:
  name: chat-deployment

spec:
  replicas: 5
  selector:
    matchLabels:
      app: chat-app

  template:
    metadata:
      labels:
        app: chat-app
    spec:
      containers:
        - name: chat-container
          image: docker.io/jeongchanmin/spring-server:0.1.3
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
```

이전 버전(0.1.2)에서 새로운 버전(0.1.3)으로 수정한다.

### 3. 변경 내용 적용

변경된 매니페스트를 다시 적용한다.

```yaml
kubectl apply -f chat-deployment.yaml
```

이 명령어를 실행하면, 쿠버네티스가 새로운 이미지를 감지하고 자동으로 롤링 업데이트(Rolling Update) 를 수행한다.

즉, 기존 파드들을 한꺼번에 중단하지 않고, 새로운 버전의 파드를 하나씩 생성하면서 이전 버전 파드를 순차적으로 교체한다. 이 덕분에 **서비스 중단 없이 안정적인 배포**가 가능하다.

<img width="447" height="186" alt="image" src="https://github.com/user-attachments/assets/6c39e161-be30-44fe-a591-73ab41c75fc9" />


# 요약

쿠버네티스에서는 서비스, 디플로이먼트, 파드와 같은 리소스를 보고 오브젝트라고 부른다. 또한 쿠버네티스에서는 위 개념 말고도 스테이트풀셋, 잡과 같은 다양한 개념이 존재한다.
