# 볼륨이란?

### 파드가 가진 문제점

쿠버네티스에서는 특정 프로그램을 **파드(Pod)** 형태로 실행한다. 프로그램이 업데이트되면, **쿠버네티스는 기존 파드를 수정하지 않고 새로운 파드를 생성하여 교체하는 방식**을 사용한다. 즉, **새로운 파드를 띄우고 이전 파드를 삭제하는 방식으로 통째로 교체**한다.

이 방식은 업데이트 시 효율적이지만, **기존 파드 내부의 데이터가 함께 삭제된다는 문제점**이 있다. 예를 들어 MySQL을 실행하는 파드라면, 파드가 교체될 때 MySQL에 저장된 데이터도 함께 사라진다.

**따라서 파드 내부 데이터가 유지되어야 하는 경우**, 쿠버네티스에서는 이를 해결하기 위해 **볼륨(Volume)** 개념을 사용한다.

### 쿠버네티스의 볼륨이란?

**볼륨(Volume)** 은 데이터를 **영속적으로 저장(Persistent Storage)** 하기 위한 방법이다. 쿠버네티스의 볼륨은 크게 두 가지로 나눌 수 있다.

**1. 로컬 볼륨**

**파드 내부의 저장공간 일부를 볼륨으로 활용**하는 방식이다. 파드가 삭제되면 데이터도 함께 삭제된다. 즉, **비영속적** 저장 방식이다. 파드 내부에 저장되므로 실제 운영 환경에서는 거의 사용되지 않는다.

<img width="587" height="318" alt="image" src="https://github.com/user-attachments/assets/d885c656-fee5-4b63-b571-ac77c1a56a47" />

**2. 퍼시스턴트 볼륨(Persistent Volume, PV)**

**파드 외부의 저장소 공간**을 사용하는 방식이다. 파드가 삭제되어도 데이터는 외부에 남아 있다. 따라서 **데이터를 영구적으로 보존 가능**하다. 

현업에서는 대부분 이 **퍼시스턴트 볼륨(PV)** 방식을 사용한다. 외부 스토리지를 활용해 쿠버네티스 외부에서도 데이터를 안전하게 관리할 수 있다.

예를 들어, 쿠버네티스 내부 스토리지(PV) / 외부 스토리지(AWS EBS, NFS, GCP Persistent Disk 등)를 사용할 수 있다

<img width="464" height="262" alt="image" src="https://github.com/user-attachments/assets/a7e51fa7-dc35-4699-91ce-ef99b4bdc713" />

### 퍼시스턴트 볼륨 클레임(Persistent Volume Claim, PVC)이란?

<img width="445" height="235" alt="image" src="https://github.com/user-attachments/assets/ac7480d3-6a6e-40d7-93b0-bc9796915281" />

파드는 **퍼시스턴트 볼륨(PV)** 에 직접 접근할 수 없다. 대신 **퍼시스턴트 볼륨 클레임(PVC)** 이라는 **중개자**를 통해 접근한다.

PVC는 파드가 필요한 **스토리지의 크기, 접근 방식(ReadWriteOnce 등)** 을 정의하고, 쿠버네티스는 이 요청에 맞는 PV를 자동으로 할당한다. 그래서 쿠버네티스 구조에서는 아래와 같은 구조로 퍼시스턴트 볼륨을 연결한다.

<img width="597" height="203" alt="image" src="https://github.com/user-attachments/assets/20765b6a-927f-4686-bbd6-22f98552a5ad" />

# 디플로이먼트를 활용해 MySQL 실행시키기

쿠버네티스에서 MySQL을 실행하기 위해서는 **디플로이먼트(Deployment)** 를 사용한다. 디플로이먼트는 파드를 관리하고, 장애 발생 시 자동으로 새 파드를 생성해주는 컨트롤러이다.

아래는 MySQL을 실행시키기 위한 기본 디플로이먼트 예시이다.

```yaml
apiVersion: apps/v1
kind: Deployment

metadata:
  name: mysql-deployment

spec:
  replicas: 1
  selector:
    matchLabels:
        app: mysql-db

  template:
    metadata:
      labels:
        app: mysql-db
    spec:
      containers:
        - name: mysql-container
          image: mysql
          ports:
            - containerPort: 3306
          env:
            - name: MYSQL_ROOT_PASSWORD
              value: password123
            - name: MYSQL_DATABASE
              value: chatdb
```

- env 환경 변수는 MySQL 컨테이너가 정상 동작하기 위해 반드시 필요하다.

MySQL 공식 이미지(Docker Hub)에 정의된 환경변수 목록을 보면, 컨테이너 실행 시 몇 가지 필수 환경 변수를 지정해야 한다.

<img width="672" height="60" alt="image" src="https://github.com/user-attachments/assets/e3057463-f88c-409e-a769-c00a2437e485" />

- MYSQL_DATABASE는 “컨테이너가 처음 시작될 때 자동으로 생성할 초기 데이터베이스”를 정의한다.

### **환경변수 분리: Secret & ConfigMap 사용**

직접 디플로이먼트 파일에 비밀번호를 작성하는 것은 보안상 좋지 않다. 따라서 민감한 값은 Secret, 노출되어도 되는 값은 ConfigMap 으로 분리한다.

mysql-secret.yaml

```yaml
apiVersion: v1
kind: Secret

metadata:
  name: mysql-secret

stringData:
    mysql-root-password: password123
```

디플로이먼트에서는 다음과 같이 시크릿 값을 참조한다.

```yaml
env:
  - name: MYSQL_ROOT_PASSWORD
    valueFrom:
      secretKeyRef:
        name: mysql-secret
        key: mysql-root-password
```

mysql-config.yaml

```yaml
apiVersion: v1
kind: ConfigMap

metadata:
  name: mysql-config

data:
  mysql-database: chatdb
```

디플로이먼트에서는 다음과 같이 컨피그맵을 참조한다.

```yaml
- name: MYSQL_DATABASE
  valueFrom:
    configMapKeyRef:
      name: mysql-config
      key: mysql-database
```

이렇게 하면 민감한 정보와 일반 설정값을 **명확히 분리**하여 관리할 수 있다.

### 외부 접근을 위한 Service 설정

파드 내부의 MySQL에 외부에서 접근하기 위해서는 **Service** 오브젝트가 필요하다.

mysql-service.yaml

```yaml
apiVersion: v1
kind: Service

metadata:
  name: mysql-service

spec:
  type: NodePort
  selector:
    app: mysql-db
  ports:
    - protocol: TCP
      nodePort: 30002
      port: 3306
      targetPort: 3306

```

- 외부에서 노드IP:30002 내부의 MySQL 3306 포트로 연결된다.

### 리소스 적용 및 확인

아래 명령어로 각 리소스를 적용한다.

```yaml
kubectl apply -f mysql-secret.yaml
kubectl apply -f mysql-config.yaml
kubectl apply -f mysql-deployment.yaml
kubectl apply -f mysql-service.yaml
```

리소스가 정상적으로 생성되었는지 확인한다.

```yaml
kubectl get configmap
kubectl get secret
kubectl get deployment
kubectl get service
```

### 접속 및 확인

DataGrip 등 외부 DB 클라이언트를 통해 <노드 IP>:30002 로 접속하면 MySQL 서버에 접근할 수 있다. 

초기 데이터베이스로 지정한 chatdb 가 자동으로 생성되어 있는 것을 확인할 수 있다.

<img width="591" height="464" alt="image" src="https://github.com/user-attachments/assets/875f700a-72ff-48c2-8a5b-f223c01396c2" />

### 파드 재시작 시 문제점

이제 스키마를 하나 생성해보자. 예를 들어 jeongchanmin 이라는 스키마를 만든 뒤, 파드를 재시작한다

<img width="593" height="144" alt="image" src="https://github.com/user-attachments/assets/68f50b81-50d6-4f04-b5c8-7a8b2bc2eb37" />

```yaml
 kubectl rollout restart deployment mysql-deployment
```

- 기존 파드는 삭제해버리고 새로운 파드를 만들어서 띄어버리는 형식이다

쿠버네티스는 기존 파드를 삭제하고 새로운 파드를 생성한다. 이때 저장공간에 있던 데이터는 모두 삭제된다. DataGrip으로 다시 접속하면, 앞서 생성했던 jeongchanmin 스키마가 사라진 것을 확인할 수 있다.

<img width="591" height="132" alt="image" src="https://github.com/user-attachments/assets/69d12e9c-3b80-4398-a689-546ab09f162d" />

# 볼륨을 활용해 MySQL 실행시키기

앞서 MySQL을 단순히 디플로이먼트로 실행했을 때, **파드가 재시작되면 데이터가 모두 삭제되는 문제**가 있었다.

이 문제를 해결하기 위해 사용하는 개념이 바로 퍼시스턴트 볼륨(PV)과 이를 파드에 연결하기 위한 퍼시스턴트 볼륨 클레임(PVC) 이다.

파드는 직접 PV에 접근하지 못하므로, 반드시 PVC를 통해서 PV에 연결해야 한다.

mysql-pv.yaml

```yaml
apiVersion: v1
kind: PersistentVolume

metadata:
  name: mysql-pv

spec:
  storageClassName: chat-storage
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: /mnt/data
```

- **storageClassName**
    
    PV와 PVC를 연결하기 위한 이름이다. pvc에서도 동일한 이름으로 지정해야 매핑이 가능하다. 즉, 두 리소스를 연결하기 위한 키워드 역할을 한다.
    
- **capacity.storage**
    
    퍼시스턴트 볼륨의 용량을 지정한다. 1Gi는 1GB의 저장공간을 의미한다. 즉, 하드디스크를 1기가짜리로 할당하겠다는 뜻이다
    
- **accessModes**
    
    볼륨의 접근 모드를 지정한다. ReadWriteOnce는 **하나의 노드에서 읽기/쓰기 가능**하다는 뜻이다.
    
- **hostPath**
    
    PV에는 여러 가지 타입이 있는데, 여기서는 **hostPath 타입**을 사용한다. hostPath는 쿠버네티스 내부의 공간을 활용하는 방식이다. 즉, 쿠버네티스 노드 내부에 실제 경로(/mnt/data)를 만들어 그 폴더를 볼륨으로 사용하겠다는 의미다.
    
    hostPath 타입을 사용할 때는 accessMode를 ReadWriteOnce로만 설정 가능하다. 쿠버네티스 내부 공간을 직접 활용하므로, 실제 운영 환경에서는 AWS EBS나 NFS 같은 외부 스토리지를 사용하는 것이 일반적이다.
    

퍼시스턴트 볼륨이 정의되었으면, 이제 PVC를 만들어야 한다. PVC는 파드가 실제로 사용할 수 있는 볼륨을 요청하는 역할을 한다.

mysql-pvc.yaml

```yaml
apiVersion: v1
kind: PersistentVolumeClaim

metadata:
  name: mysql-pvc

spec:
  storageClassName: chat-storage
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
```

- **storageClassName**
    
    mysql-pv.yaml에서 지정한 storageClassName 값과 반드시 동일해야 한다. PVC는 쿠버네티스 내부의 여러 PV 중에서 **이 이름이 일치하는 PV를 찾아 자동 연결**한다.
    
- **resources.requests.storage**
    
    PVC가 PV에 요청하는 스토리지의 양이다. 즉, “1Gi만큼의 볼륨을 사용할게요.” 라고 요청하는 것과 같다.
    
    PVC가 요청을 보내면, 쿠버네티스는 그 요청을 만족시킬 수 있는 PV를 찾아 매칭해준다. 이렇게 연결된 후에는 디플로이먼트에서 PVC를 사용하여 파드에 볼륨을 연결할 수 있다.
    

PVC가 요청을 보내면, 쿠버네티스는 그 요청을 만족시킬 수 있는 PV를 찾아 매칭해준다. 이렇게 연결된 후에는 디플로이먼트에서 PVC를 사용하여 파드에 볼륨을 연결할 수 있다.

### **디플로이먼트에 PVC 연결하기**

이제 디플로이먼트 파일에서 PVC를 연결해야 한다. 이를 위해 **volumeMounts** 와 **volumes** 항목을 추가한다.

1. **volumeMounts : 컨테이너 내부 경로 지정**
    
    ```yaml
              volumeMounts:
              - name: mysql-persistent-storage
                mountPath: /var/lib/mysql
    ```
    
    mountPath는 MySQL 컨테이너 내부에서 데이터가 실제로 저장되는 경로이다. /var/lib/mysql은 MySQL의 기본 데이터 저장 위치로, 여기서 생성되는 모든 데이터가 볼륨으로 저장된다.
    
    즉, 파드 내부 경로 대신 외부 스토리지를 사용하도록 설정하는 것이다.
    
2. **volumes : PVC와 연결 정의**
    
    ```yaml
          volumes:
            - name: mysql-persistent-storage
              persistentVolumeClaim:
                claimName: mysql-pvc
    ```
    
    volumes는 파드가 사용할 볼륨 자체를 정의한다. persistentVolumeClaim.claimName은 PVC 이름(mysql-pvc)을 지정한다.
    
    name은 위의 volumeMounts에 지정한 값(mysql-persistent-storage)과 동일해야 한다. 이렇게 하면 디플로이먼트가 PVC와 연결되고 PVC는 PV를 통해 실제 저장공간(/mnt/data)과 연결된다
    

즉, MySQL 데이터가 파드 내부가 아니라 /mnt/data 외부 경로에 저장되기 때문에 파드가 삭제되더라도 데이터는 그대로 유지된다.

### 매니페스트 적용 및 확인

새로운 매니페스트 파일을 적용한다.

```yaml
kubectl apply -f mysql-pv.yaml
kubectl apply -f mysql-pvc.yaml
kubectl apply -f mysql-deployment.yaml
```

정상적으로 생성되었는지 확인한다.

```yaml
kubectl get pv
kubectl get pvc
```

<img width="721" height="51" alt="image" src="https://github.com/user-attachments/assets/23654931-018d-43db-8995-dd9b7a6673ed" />

- STATUS가 Bound 로 표시되면 PVC와 PV가 정상적으로 연결된 것이다.

### 데이터 영속성 테스트

이제 MySQL로 접속해서 새로운 데이터베이스를 만들어본다. 예를 들어 jeongchanmin이라는 데이터베이스를 생성하고 저장한다.

<img width="635" height="152" alt="image" src="https://github.com/user-attachments/assets/29329b2d-bb2d-496d-a259-080601f76705" />

그 다음, 디플로이먼트를 재시작해보자.

```yaml
kubectl rollout restart deployment mysql-deployment
```

<img width="637" height="156" alt="image" src="https://github.com/user-attachments/assets/26b07d62-d87f-476b-845e-4ee3c5d55e9e" />

쿠버네티스는 기존 파드를 삭제하고 새로운 파드를 띄운다. 이전에는 볼륨을 사용하지 않았을 때 데이터가 모두 사라졌지만, 지금은 PVC를 통해 외부 공간(/mnt/data)에 저장했기 때문에 데이터베이스가 그대로 남아있다.

# 백엔드 서버와 MySQL 연동하기

### Gradle 의존성 추가

```yaml
dependencies {
	// 필요한 의존성 추가
    implementation project(':common')

    // Spring Data JPA
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

    // mysql connector
    runtimeOnly 'com.mysql:mysql-connector-j'
}
```

MySQL과 연결하기 위해 필요한 의존성을 추가한다.

### application.yaml 설정

```yaml
spring:
  datasource:
    url: jdbc:mysql://${DB_HOST}:${DB_PORT}/${DB_NAME}
```

데이터베이스 연결 정보를 하드코딩하지 않고, ${} 문법을 사용해 환경변수를 참조한다. 즉, DB 접속 정보를 코드에 직접 작성하지 않고 외부에서 주입받는 방식이다.

### JAR 빌드 및 Docker 이미지 생성

서버 이미지를 만들기 위해서는 JAR 파일이 필요하므로 먼저 빌드를 진행한다.

```bash
./gradlew :chat-server:build
```

이후 도커 이미지를 빌드하고 푸시한다.

```bash
docker buildx build --platform linux/amd64 -t docker.io/jeongchanmin/chat-server:latest --load .
docker push docker.io/jeongchanmin/chat-server:latest
```

### **Deployment 파일 수정**

스프링 서버를 쿠버네티스에 배포할 때, application.yml에서 정의한 환경변수를 env로 설정해야 한다.

```yaml
apiVersion: apps/v1
kind: Deployment

metadata:
  name: chat-deployment

spec:
  replicas: 5
  selector:
    matchLabels:
      app: chat-app

  template:
    metadata:
      labels:
        app: chat-app
    spec:
      containers:
        - name: chat-container
          image: docker.io/jeongchanmin/chat-server:latest
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 8080
          env:
            - name: DB_HOST
              value: mysql-service
            - name: DB_PORT
              value: "3306"
            - name: DB_NAME
              value: chatdb
            - name: DB_USER
              value: root
            - name: DB_PASSWORD
              value: password123
```

```yaml
env:
	- name: DB_HOST
    value: mysql-service
```

- DB_HOST의 값인 mysql-service는 기존에 mysql-service.yaml에서 정의한 서비스 이름이다. 노드 IP나 포트를 명시하지 않아도, 같은 클러스터 내에서는 서비스 이름만으로 통신할 수 있다.
- 즉, mysql-service는 쿠버네티스 내부 DNS를 통해 MySQL 파드로 자동 연결된다.

```yaml
	- name: DB_PORT
	  value: "3306"
```

- value에 숫자값을 지정할 때는 반드시 쌍따옴표(””)를 붙여야 한다. YAML 문법상 따옴표가 없으면 숫자로 인식되기 때문이다. 3306은 MySQL 서비스 포트 번호로, MySQL 파드 내부에서 사용하는 포트이다.

```yaml
	- name: DB_NAME
	  value: chatdb
	- name: DB_USER
	  value: root
```

- 초기 데이터베이스는 chatdb로 설정해 두었으며, 기존에 띄워둔 MySQL 파드의 접속 계정 정보를 그대로 반영한다.

### 배포 및 확인

작성한 매니페스트 파일을 기반으로 오브젝트를 생성한다.

```yaml
kubectl apply -f chat-deployment.yaml
kubectl apply -f chat-service.yaml
```

<img width="537" height="156" alt="image" src="https://github.com/user-attachments/assets/f05bad8c-543a-4df3-a270-72f83a86c66a" />

파드를 조회하면 파드가 정상적으로 생성이 되었음을 확인할 수 있다.

<img width="553" height="340" alt="image" src="https://github.com/user-attachments/assets/fb6467d3-7cec-4b6a-a29c-49f35fc52430" />

정상적으로 파드가 실행되면, 환경변수 설정이 반영된 스프링 서버가 쿠버네티스 내에서 실행된다.

<img width="702" height="327" alt="image" src="https://github.com/user-attachments/assets/f26e167e-1699-413d-9f77-c8bb6a90dacd" />

MySQL의 서비스로 접속할 때 GUI 툴에서는 노드포트(30002) 로 접속하지만, 스프링 서버는 mysql-service 로 접근하기 때문에 포트포워딩 없이 바로 내부 서비스(3306 포트)로 연결된다.

즉, 스프링 서버는 mysql-service:3306으로 직접 통신하고, 외부에서 접근할 때만 <노드 IP>:30002를 사용한다.

# 만약 MySQL과 연결이 제대로 되지 않았다면 어떻게 될까?

```yaml
- name: DB_PASSWORD
	value: wrong-password
```

비밀번호를 잘못 입력한 상태로 매니페스트 파일을 수정하고, 변경된 내용을 적용해보자.

```bash
kubectl apply -f chat-deployment.yaml
kubectl rollout restart deployment chat-deployment  
```

서버가 정상적으로 실행되지 않고 에러가 발생한다.

<img width="546" height="198" alt="image" src="https://github.com/user-attachments/assets/7db1be8e-dcb7-41c9-a1e0-19c95fd0e648" />

에러가 발생했을 때는 파드의 로그를 통해 원인을 확인할 수 있다.

```yaml
kubectl logs 파드명
```

```yaml
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'entityManagerFactory' defined in 
```

이 에러는 데이터베이스 연결에 실패했을 때 발생하는 대표적인 예외이다. 즉, 데이터베이스 연결 정보(DB 주소, 포트, 계정, 비밀번호 등)가 올바르지 않다는 뜻이다.

# 컨피그맵, 시크릿을 활용해 환경변수 분리하기

이전에는 디플로이먼트 파일에서 환경변수를 직접 하드코딩했다. 하지만 하드코딩된 환경변수는 유지보수에 불편하고, 특히 비밀번호처럼 민감한 값이 외부에 노출될 위험이 있다.

따라서 컨피그맵(ConfigMap)과 시크릿(Secret)을 활용해 환경변수를 분리한다.

### ConfigMap으로 일반 환경변수 관리

db_host, db_port, db_name처럼 노출되어도 괜찮은 값은 컨피그맵으로 관리한다.

```yaml
apiVersion: v1
kind: ConfigMap

metadata:
  name: chat-config

data:
  db-host: mysql-service
  db-port: "3306"
  db-name: chatdb 
```

이제 디플로이먼트 파일에서 해당 값을 valueFrom을 통해 참조하도록 수정한다.

```yaml
          env:
            - name: DB_HOST
              valueFrom:
                configMapKeyRef:
                  name: chat-config
                  key: db-host
            - name: DB_PORT
              valueFrom:
                configMapKeyRef:
                  name: chat-config
                  key: db-port
            - name: DB_NAME
              valueFrom:
                configMapKeyRef:
                  name: chat-config
                  key: db-name
```

### **Secret으로 민감한 정보 분리**

db_username, db_password처럼 외부에 유출되면 안 되는 값은 시크릿(Secret)으로 관리한다.

```yaml
apiVersion: v1
kind: Secret

metadata:
  name: chat-secret

stringData:
  db-username: root
  db-password: password123 
```

디플로이먼트 파일도 아래와 같이 수정한다.

```yaml
            - name: DB_USERNAME
              valueFrom:
                secretKeyRef:
                  name: chat-secret
                  key: db-username
            - name: DB_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: chat-secret
                  key: db-password
```

### **컨피그맵과 시크릿 적용**

작성한 설정 파일들을 쿠버네티스에 반영한다.

```bash
kubectl apply -f chat-deployment.yaml
kubectl apply -f chat-secret.yaml
kubectl apply -f chat-config.yaml
kubectl rollout restart deployment chat-deployment
```

정상적으로 배포되면 서버가 문제없이 실행되고, 환경변수가 올바르게 적용된 것을 확인할 수 있다.

# 보안을 위해 외부에서 MySQL 접근하지 못하도록 막기

<img width="627" height="287" alt="image" src="https://github.com/user-attachments/assets/b05ef47a-31bb-4bae-9f53-0b38c0a8a0bf" />

현재 구조에서 MySQL을 중심으로 보면 보안 취약점이 존재한다. 바로 30002번 포트로 외부에서 MySQL에 직접 접근이 가능하다는 점이다. 이는 Service의 NodePort 타입을 사용해 MySQL 포트를 외부에 오픈했기 때문이다.

즉, 누구나 해당 포트로 접근해 데이터베이스에 접속할 수 있는 상태가 된다. 스프링 부트 서버는 외부 요청을 받아도 큰 문제가 없지만, 데이터베이스는 외부에서 접근할 수 있도록 열려 있는 것은 매우 위험하다.

### Service 종류 복습

- `NodePort` : 쿠버네티스 내부에서 해당 서비스에 접속하기 위한 포트를 열고 외부에서 접속 가능하도록 한다.
- `ClusterIP` : **쿠버네티스 내부에서만 통신할 수 있는 IP 주소를 부여, 외부에서는 요청할 수 없다.**
- `LoadBalancer` : 외부의 로드밸런서(AWS의 로드밸러서 등)를 활용해 외부에서 접속할 수 있도록 연결한다.

### 보안적인 문제점 해결

보안 강화를 위해 NodePort 대신 ClusterIP를 사용해야 한다. 이렇게 하면 클러스터 내부 서버들만 MySQL에 접근할 수 있고, 결국 데이터베이스는 항상 백엔드 서버를 통해서만 접근하게 된다.

mysql-service.yaml 파일을 다음과 같이 수정한다.

```yaml
apiVersion: v1
kind: Service

metadata:
  name: mysql-service

spec:
  type: ClusterIP
  selector:
    app: mysql-db
  ports:
    - protocol: TCP
      port: 3306
      targetPort: 3306

```

### 적용 과정

기존의 mysql-service를 삭제한다.

```bash
kubectl delete service mysql-service
```

그 후 디플로이먼트를 재시작한다.

```bash
kubectl rollout restart deployment chat-deployment
```

서비스를 삭제했기 때문에 스프링 서버는 일시적으로 데이터베이스 연결에 실패하게 된다. 이제 ClusterIP 설정을 적용한 새로운 서비스를 다시 생성한다.

```yaml
kubectl apply -f mysql-service.yaml
```

스프링 서버도 함께 재시작한다.

<img width="491" height="290" alt="image" src="https://github.com/user-attachments/assets/e523effd-0965-4237-a922-01c165c6806f" />

스프링 서버는 정상적으로 MySQL과 연결되었다.  mysql-service의 타입이 ClusterIP임에도 정상적으로 통신이 가능한 이유는, 내부 네트워크에서 mysql-service로 직접 요청을 보냈기 때문이다

<img width="599" height="113" alt="image" src="https://github.com/user-attachments/assets/109edf87-0a1a-4e5c-8b9f-e352be3fd07f" />

### 외부 접근 차단 확인

<img width="543" height="330" alt="image" src="https://github.com/user-attachments/assets/43ab3c4a-5ace-47d0-9d44-5ebe89c76224" />

이제 GUI 툴을 통해 기존처럼 30002 포트로 접속을 시도해보면, 외부 접근이 차단된 것을 확인할 수 있다.

즉, 외부에서는 데이터베이스로 직접 접근이 불가능하지만, 스프링 서버는 내부 네트워크를 통해 정상적으로 MySQL과 통신할 수 있다. 클러스터 외부에서 통신이 어려워진 것을 확인할 수 가 있다.

<img width="586" height="278" alt="image" src="https://github.com/user-attachments/assets/f1bba91a-cc6c-4ff2-bfd0-a8a106f73980" />

### **외부에서 MySQL 접속이 필요한 경우**

보안을 유지하면서도 일시적으로 외부 접근이 필요할 경우, port-forward 명령어를 사용한다.

```bash
kubectl port-forward pod/[MySQL 파드명] 3307:3306
```

기존 3306 포트가 이미 사용 중이었기 때문에 3307로 변경해 연결했다. 정상적으로 접속이 가능한 것을 확인할 수 있다.  이 방식은 로컬 컴퓨터에서만 연결이 허용되므로 보안이 유지되면서도 데이터베이스 관리가 가능하다.

<img width="637" height="364" alt="image" src="https://github.com/user-attachments/assets/2d6dea7b-cb13-49e8-953e-76959a3dfdef" />
