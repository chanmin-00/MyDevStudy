대부분의 데이터베이스에서는 단순한 `SELECT` 쿼리를 실행할 때 락을 걸지 않는다.

예를 들어 세션1이 memberA를 수정 중이더라도, 세션2는 해당 데이터를 조회하는 데 제한이 없다.

- 조회는 가능하지만 수정은 불가능하다.
- 즉, 수정하려면 락이 필요하고, 락을 이미 누군가 보유 중이면 대기해야 한다.

# 조회하면서 락을 거는 경우 : SELECT FOR UPDATE

조회 시점에 락을 획득하고 싶다면 `SELECT FOR UPDATE` 구문을 사용한다. 이 구문은 다음 상황에서 유용하다

- 조회한 데이터를 기반으로 중요한 비즈니스 로직을 수행할 때
- 트랜잭션이 끝날 때까지 해당 데이터가 변경되지 않아야 할 때

즉, 조회 + 로직 처리 + 수정이 하나의 트랜잭션 안에 있을 경우, 중간에 다른 세션이 해당 데이터를 바꾸는 걸 막기 위해 사용한다.

## 세션1 : SELECT FOR UPDATE

```sql
set autocommit false;
select * from member where member_id = 'memberA' for update;
```

- 세션1은 memberA 데이터를 조회하면서 락을 획득한다.
- 이 락은 세션1이 트랜잭션을 커밋하거나 롤백할 때까지 유지된다.
- 다른 세션은 이 데이터를 수정하려고 하면 대기 상태에 들어간다.

## 세션2 : 같은 데이터 수정 시도

```sql
set autocommit false;
update member set money = 500 where member_id = 'memberA';
```

- 세션2는 memberA를 수정하려 하지만, 세션1이 락을 보유 중이기 때문에 락이 해제될 때까지 대기한다.
- 락 타임아웃이 설정되어 있다면, 제한 시간 안에 락을 획득하지 못하면 예외가 발생한다.

## 세션1 : 커밋 (락 해제)

```sql
commit;
```

- 세션1이 커밋하면 락이 반납되고, 세션2가 락을 획득하게 된다.

## 세션2 : update 실행 및 커밋

```sql
-- 세션2는 대기하다가 update 실행
commit;
```

- 세션2는 money를 500으로 변경하고 커밋.
- 트랜잭션 종료와 함께 락도 반납된다.
