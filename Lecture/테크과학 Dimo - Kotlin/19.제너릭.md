# 제네릭

상속 관계에 있는 여러 클래스를 **하나의 함수나 클래스에서 모두 처리**하고 싶을 때, 일반적으로는 **슈퍼클래스 타입을 파라미터로 받고, 하위 클래스는 캐스팅**하여 처리한다. 하지만 **캐스팅 연산은 런타임 시점에 추가적인 검사와 변환이 필요하므로 프로그램 속도를 저하시킬 수 있다.**

이를 해결하기 위해 **제네릭(Generic)**이 등장했다.

제네릭은 함수나 클래스 선언 시 고정된 자료형 대신 실제 자료형으로 대체되는 타입 파라미터(Type Parameter)를 사용하는 방식이다. 즉, 자료형을 변수처럼 다루는 방법이다.

타입 파라미터는 실제 자료형으로 컴파일 시점에 대체되며, 캐스팅 없이 타입 안정성과 성능을 동시에 확보할 수 있다.

```kotlin
fun <T> genericFunc(param: T): T
class GenericClass<T>(var pref: T)
```

- T : **타입 파라미터** → 실제 자료형이 컴파일 시점에 대체된다.
- T는 관례적으로 Type의 약자이며, 여러 개를 사용할 경우 <T, U, V>처럼 순차적으로 사용한다.

## 제네릭 동작 원리

타입 파라미터 T에 실제 자료형이 할당되면 제네릭을 사용하는 코드가 **그 자료형으로 치환되어 컴파일**된다.

```kotlin
fun <T> genericFunc(param: T): T

// Int로 치환되면 ↓
fun genericFunc(param: Int): Int
```

```kotlin
class GenericClass<T>(var pref: T)

// String으로 치환되면 ↓
class GenericClass(var pref: String)
```

따라서 별도의 캐스팅 연산 없이 안전하고 빠르게 자료형을 사용할 수 있다.

제네릭 타입을 아무 클래스나 받게 하면 위험할 수 있다. 특정 상위 클래스(혹은 인터페이스)를 상속받은 클래스만 허용하고 싶을 때는 **타입 제한**을 사용할 수 있다.

```kotlin
fun <T : SuperClass> genericFunc(param: T) { ... }
```

- T : SuperClass → SuperClass를 상속한 클래스만 T로 올 수 있음
- 이렇게 하면 제네릭 타입 T 내부에서 SuperClass의 기능을 안전하게 사용 가능하다.

## 제네릭 함수

```kotlin
fun <T> genericFunc(param: T) {
    println(param)
}

fun main() {
    genericFunc(1)          // Int 타입 추론
    genericFunc("Hello")    // String 타입 추론
    genericFunc(3.14)       // Double 타입 추론
}
```

제네릭 함수는 호출 시 **파라미터 타입을 통해 자동으로 추론** <Int> 같은 명시적 지정이 필요 없다.

```kotlin
fun <Int> genericFunc(var param:Int) {}
```

## 제네릭 클래스

```kotlin
class GenericClass<T>(var pref: T)

fun main() {
    val a = GenericClass<Int>(10)  // 명시적 지정
    val b = GenericClass("Hello")  // 타입 추론 가능
}
```

- 생성자의 파라미터를 통해 자료형이 유추 가능할 때는 타입 파라미터를 생략해도 자동으로 추론된다.

## 상속 관계

제네릭은 특히 **상속 관계에 있는 여러 클래스를 함께 처리할 때 유용**하다.

```kotlin
fun main() {
    UsingGeneric(A()).doShouting()
    UsingGeneric(B()).doShouting()
    UsingGeneric(C()).doShouting()

    doShouting(B())
}

// 제네릭 함수
fun <T : A> doShouting(t: T) {
    t.shout()
}

// 상속 구조
open class A {
    open fun shout() {
        println("A가 소리칩니다")
    }
}

class B : A() {
    override fun shout() {
        println("B가 소리칩니다")
    }
}

class C : A() {
    override fun shout() {
        println("C가 소리칩니다")
    }
}

// 제네릭 클래스
class UsingGeneric<T : A>(val t: T) {
    fun doShouting() {
        t.shout()
    }
}
```

```kotlin
A가 소리칩니다
B가 소리칩니다
C가 소리칩니다
B가 소리칩니다
```

1. <T : A>
    - 제네릭 타입 T는 반드시 A를 상속해야 한다는 제약.
    - 따라서 A, B, C 모두 제네릭에 사용할 수 있다.
2. UsingGeneric(A()), UsingGeneric(B()), UsingGeneric(C())
    - 각각의 인스턴스가 전달되어, 자신의 shout()이 호출된다.
3. doShouting(B())
    - 제네릭 함수가 호출되며, 인자로 전달된 객체의 타입(B)을 자동으로 추론한다.

제네릭을 사용하면 업캐스팅/다운캐스팅 없이 다양한 타입을 처리 가능하다. **컴파일 시점에 타입이 확정되므로 캐스팅 오버헤드가 없다.**