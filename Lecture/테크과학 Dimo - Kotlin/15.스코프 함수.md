# **람다 함수를 이용한 특별한 기능**

람다함수는 단순히 짧은 익명 함수를 표현하는 것뿐 아니라, **여러 줄의 구문, 매개변수 생략, 특별한 키워드(it) 사용** 등 다양한 기능을 제공한다.

## 1. 여러 구문 사용 가능

람다함수도 일반 함수처럼 여러 줄로 작성할 수 있다. 이때 마지막 구문의 결과값이 반환값이 된다.

```kotlin
val add: (Int, Int) -> Int = {
    val result = it + 10
    result * 2
}
```

- 여러 구문을 작성할 수 있고 가장 마지막 구문의 값이 자동으로 반환된다.

## 2. 매개변수가 없는 람다함수

매개변수가 없는 경우에는 단순히 **실행할 구문만 나열**하면 된다.

```kotlin
val a: () -> Unit = { println("패러미터가 없어요") }
```

- ()는 매개변수가 없음을 의미한다. Unit은 반환값이 없다는 뜻이다.

## 3. **매개변수가 하나일 때  it 사용**

매개변수가 하나뿐이라면 이름을 생략하고 특별한 키워드 it 을 통해 접근할 수 있다.

```kotlin
val c: (String) -> Unit = { println("$it 람다함수") }
```

- it은 자동으로 전달된 유일한 인자를 가리킨다. 불필요한 변수 선언을 줄이고 코드를 간결하게 만든다.

# 스코프 함수

스코프 함수는 **함수형 언어의 특징을 더 편리하게 사용할 수 있도록 코틀린에서 기본 제공하는 함수이다.** 클래스에서 생성한 인스턴스를 스코프 함수에 전달하면, 그 인스턴스의 속성과 함수를 깔끔하고 간결하게 다룰 수 있다.

코틀린에서 제공하는 대표적인 스코프 함수는 다음 다섯 가지이다.

> apply, run, with, also, let
> 

## 1. apply

**인스턴스를 생성한 직후 초기화 과정을 수행할 때** 자주 사용된다.

```kotlin
fun main() {
    var a = Book("디모의 코틀린", 10000).apply {
        name = "[초특가] " + name
        discount()
    }
}

class Book(var name: String, var price: Int) {
    fun discount() {
        price -= 2000
    }
}
```

- apply는 인스턴스를 생성하자마자 바로 속성과 함수를 조작할 수 있는 스코프를 제공한다.
- 참조 연산자(.) 없이 인스턴스의 프로퍼티나 메서드에 접근할 수 있다.
- apply는 **인스턴스 자신(this)** 을 반환하므로, 조작된 객체를 변수에 바로 담을 수 있다.

## 2. run

run은 apply와 유사하지만, **마지막 구문의 결과값을 반환**한다는 차이가 있다.

```kotlin
var b = a.run{
		println(a.price)
		a.name
}
```

또는 이미 생성된 인스턴스의 정보를 출력하거나 처리할 때 유용하다.

```kotlin
a.run {
    println("상품명: ${name}, 가격: ${price}원")
}
```

- 인스턴스의 속성과 함수를 스코프 내에서 참조 연산자 없이 사용 가능하다.
- 최종 구문의 결과값을 반환한다.

## 3. with

run과 기능적으로 동일하지만, **인스턴스를 참조 연산자가 아니라 인자로 전달받는 형태**이다.

```kotlin
a.run { ... }
with(a) { ... }
```

둘 다 동일하게 동작하며, 코드의 가독성을 높이는 선택적 표현 방식이다.

## 4. also/let

스코프 함수 중에서도 반환값 기준으로 다음과 같이 구분할 수 있다.

| **구분** | **반환값** |
| --- | --- |
| apply, also | 인스턴스 자체 반환 |
| run, let | 마지막 구문의 결과값 반환 |

apply와 run은 인스턴스의 프로퍼티를 참조 연산자 없이 직접 접근 가능하지만 also와 let은 **it을 통해 인스턴스를 참조**해야 한다. 이 이유는 **외부 스코프의 변수명과 혼동을 방지**하기 위해서다.

```kotlin
fun main() {

    var price = 5000

    var a = Book("디모의 코틀린", 10000).apply {
        name = "[초특가]" + name
        discount()
    }

    a.run {
        println("상품명: ${name}, 가격: ${price}원")
    }
}
```

이 코드를 실행하면 8000이 아니라 **5000이 출력**된다. 왜냐하면 run이 **인스턴스 내의 price보다 메인 함수 스코프의 price 변수**를 우선시하기 때문이다.

이럴 때는 run 대신 let을 사용하면 된다.

```kotlin
a.let {
    println("상품명: ${it.name}, 가격: ${it.price}원")
}
```

- it을 통해 명확히 인스턴스를 참조하기 때문에 외부 스코프 변수와의 혼동을 피할 수 있다. 동일한 이유로 apply의 경우에는 **also** 로 대체할 수 있다

스코프 함수는 **인스턴스의 속성과 함수를 깔끔하게 분리해 사용할 수 있게 해주는 도구**이다. 이를 통해 코드의 **가독성을 높이고**, **객체 초기화나 데이터 조작 로직을 더 직관적이고 선언적으로 표현**할 수 있다.