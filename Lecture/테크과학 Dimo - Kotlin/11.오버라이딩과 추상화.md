# **오버라이딩 (Overriding)**

상속 구조에서는 기본적으로 서브 클래스가 슈퍼 클래스와 동일한 함수 이름과 형태를 그대로 선언할 수 없다. 하지만 슈퍼 클래스가 허용(open)한다면, 서브 클래스에서 해당 함수를 재구현(override)할 수 있다.

이를 오버라이딩(Overriding)이라 한다.

```kotlin
open class Animal {
    fun eat() {
        println("음식을 먹습니다")
    }
}

class Tiger : Animal()

fun main() {
    val t = Tiger()
    t.eat()  // 출력: 음식을 먹습니다
}
```

- eat()은 이미 구현된 상태이므로 서브 클래스에서 재구현 불가

```kotlin
open class Animal {
    open fun eat() {
        println("음식을 먹습니다")
    }
}

class Tiger : Animal() {
    override fun eat() {
        println("고기를 먹습니다")
    }
}

fun main() {
    val t = Tiger()
    t.eat()  // 출력: 고기를 먹습니다
}
```

- open : 슈퍼 클래스에서 오버라이딩 가능하도록 허용
- override : 서브 클래스에서 재구현할 때 반드시 붙여야 함

# 추상화

추상화는 구체적인 구현은 없지만, 반드시 이 함수는 존재해야 한다라는 규약을 정의하는 것. 추상 클래스(abstract class)와 추상 함수(abstract fun)를 사용한다.

추상 클래스는 일부 함수가 비어 있는 **미완성 클래스**이므로 **단독으로 인스턴스 생성 불가**하다.

```kotlin
abstract class Animal {
    abstract fun eat()  // 반드시 구현해야 하는 추상 함수

    fun sniff() {       // 일반 함수도 가질 수 있음
        println("킁킁")
    }
}

class Rabbit : Animal() {
    override fun eat() {
        println("당근")
    }
}

fun main() {
    val r = Rabbit()
    r.eat()    // 출력: 당근
    r.sniff()  // 출력: 킁킁
}
```

- abstract fun eat() : 구현부 없기 때문에, 서브 클래스에서 반드시 구현 필요
- sniff() : 일반 함수여서 바로 상속 가능

# 인터페이스

코틀린 인터페이스는 **추상 함수, 일반 함수, 속성** 모두 가질 수 있다. 하지만 **생성자(constructor)는 가질 수 없다.**

인터페이스 안의 함수는 다음과 같이 간주된다

- 구현부가 있는 함수 : **open 함수**로 간주되어 오버라이딩 가능
- 구현부가 없는 함수 : **abstract 함수**로 간주되어 반드시 구현해야 함

인터페이스를 사용하면 여러 개의 인터페이스를 동시에 상속받을 수 있어 유연한 설계가 가능하다.

```kotlin
interface Runner {
    fun run()  // 추상 함수
}

interface Eater {
    fun eat() {   // 구현부 있음 → open 함수
        println("음식을 먹습니다")
    }
}

class Dog : Runner, Eater {
    override fun run() {
        println("우다다다 뜁니다")
    }

    override fun eat() {
        println("허겁지겁 먹습니다")
    }
}

fun main() {
    val d = Dog()
    d.run()  // 출력: 우다다다 뜁니다
    d.eat()  // 출력: 허겁지겁 먹습니다
}
```
