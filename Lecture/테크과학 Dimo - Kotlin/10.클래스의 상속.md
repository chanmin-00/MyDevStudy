코틀린의 클래스는 기본적으로 **상속이 금지**되어 있다. 다른 클래스가 상속받을 수 있도록 하려면 클래스 선언 앞에 **open** 키워드를 붙여야 한다.

```kotlin
// 상속 불가
class Animal(var name: String, var age: Int, var type: String) {
    fun introduce() {
        println("저는 ${type} ${name}이고, ${age}살입니다.")
    }
}

// 상속 가능
open class Animal(var name: String, var age: Int, var type: String) {
    fun introduce() {
        println("저는 ${type} ${name}이고, ${age}살입니다.")
    }
}
```

### 상속에 대한 두 가지 규칙

1. **서브 클래스는 슈퍼 클래스와 같은 이름의 속성을 가질 수 없다.**
2. **서브 클래스 생성 시 반드시 슈퍼 클래스의 생성자를 호출해야 한다.**

```kotlin
class Dog(name: String, age: Int) : Animal(name, age, "개")
```

- var, val을 붙이면 **서브 클래스의 속성**으로 선언되므로, 슈퍼 클래스의 속성과 중복될 수 있다.
- 따라서 여기서는 단순 매개변수(parameter)로 받고, Animal 클래스의 생성자에 그대로 넘겨준다.

### **인스턴스 생성**

```kotlin
fun main() {
    var a = Animal("별이", 5, "개")  // Animal 인스턴스
    var b = Dog("별이", 5)           // Dog 인스턴스
}
```

- Dog 인스턴스를 만들 때, 내부적으로 Animal의 생성자가 먼저 호출된다.

## 서브클래스 함수

서브 클래스는 자체 기능을 추가할 수 있다.

```kotlin
class Dog(name: String, age: Int) : Animal(name, age, "개") {
    fun bark() {
        println("멍멍")
    }
}
```

```kotlin
fun main() {
    val dog = Dog("초코", 3)
    dog.introduce()  // 슈퍼 클래스 기능
    dog.bark()       // 서브 클래스 전용 기능
}
```

- introduce() : Animal 클래스에서 상속받은 기능
- bark() : Dog 클래스에서만 사용할 수 있는 기능

상속은 재사용성을 높일 수 있지만, 지나치게 복잡한 상속 구조는 오히려 코드를 어렵게 만든다. 따라서 공통 기능은 상속으로 추출하되, 필요 이상의 상속 트리를 만드는 것은 피하는 것이 좋다.
