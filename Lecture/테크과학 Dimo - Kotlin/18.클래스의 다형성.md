# **업캐스팅(Upcasting)과 다운캐스팅(Downcasting)**

기본 클래스(Drink)를 상속받아 새로운 클래스(Cola)를 만들면, **Cola 인스턴스는 Drink의 속성과 기능을 그대로 가지면서 추가적인 속성과 기능을 확장**할 수 있다.



```kotlin
open class Drink {
    var name = "음료"

    open fun drink() {
        println("${name}를 마십니다")
    }
}

class Cola : Drink() {
    var type = "콜라"

    override fun drink() {
        println("${name} 중에 ${type}를 마십니다")
    }

    fun washDishes() {
        println("${type}로 설거지를 합시다")
    }
}
```

## **객체 생성과 참조**

```kotlin
var a: Drink = Cola()
```

- Cola 인스턴스를 생성했지만 Drink 타입의 변수에 담았다.
- 이 상태에서는 상위 클래스(Drink)의 기능만 접근 가능하다.
- 즉, drink()는 사용할 수 있지만 washDishes()는 사용할 수 없다.

```kotlin
var b: Cola = Cola()
```

- Cola 타입 변수로 선언했기 때문에 **상속받은 Drink의 기능 + Cola의 기능** 모두 사용 가능하다.

## 업캐스팅과 다운 캐스팅

| **구분** | **설명** | **특징** |
| --- | --- | --- |
| **업캐스팅**  | 하위 클래스의 인스턴스를 상위 클래스 타입에 저장 | 자동으로 수행됨 (연산자 불필요) |
| **다운캐스팅**  | 상위 클래스 타입의 변수를 하위 클래스 타입으로 변환 | 연산자(as, is) 필요 |

### **as : 명시적 캐스팅**

as는 **호환되는 자료형으로 강제 변환**하는 캐스팅 연산자이다.

```kotlin
var a: Drink = Cola()
a as Cola
```

- 이후로는 a가 Cola로 동작한다.
- as는 즉시 자료형을 변환하며, 변환된 자료형을 반환값으로도 사용 가능하다.

### **is : 타입 체크 후 캐스팅**

is는 **해당 변수가 특정 자료형인지 검사**한 뒤 **조건문 내부에서만 임시로 다운캐스팅**한다.

```kotlin
var a: Drink = Cola()

if (a is Cola) {
    // 이 블록 안에서만 a가 Cola로 인식됨
    a.washDishes()
}
```

- 주로 if 조건문 내에서 **타입 체크 후 안전하게 사용**할 때 유용하다.
- 블록을 벗어나면 다시 원래 타입(Drink)으로 돌아간다.

# 다형성

다형성이란 상속 관계에서 인스턴스가 여러 형태로 동작할 수 있는 성질을 말한다. 즉, 상위 클래스 타입으로 선언된 변수가 실제로는 하위 클래스의 동작을 수행할 수 있는 구조다.