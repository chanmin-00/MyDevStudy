일반적으로 클래스는 인스턴스 객체를 만들기 위한 설계도 역할을 한다. 따라서 클래스 내부의 속성이나 함수를 사용하려면 반드시 생성자를 통해 실체화된 객체를 만들어야 한다.

하지만 모든 경우에 여러 인스턴스가 필요한 것은 아니다. 단 하나의 객체만 존재하면서, 공통 속성과 함수를 공유해야 하는 경우, 굳이 클래스를 만들 필요 없이 `object` 키워드를 사용할 수 있다. Kotlin의 object는 싱글톤 패턴을 언어 차원에서 지원하는 문법이다.

```kotlin
fun main() {
    println(Counter.count)

    Counter.countUp()
    Counter.countUp()

    println(Counter.count)

    Counter.clear()

    println(Counter.count)
}

object Counter {
    var count = 0

    fun countUp() {
        count++
    }

    fun clear() {
        count = 0
    }
}
```

1. object Counter는 그 자체로 **하나의 객체**이다. 별도의 생성자를 사용하지 않는다.
2. 따라서 인스턴스를 생성하지 않고 **직접 접근 가능**하다. Counter.countUp() 처럼 **참조 연산자(.)** 를 바로 사용한다.
3. 오브젝트는 **최초 사용 시 자동으로 생성**되고, 이후에는 **프로그램 전체에서 공용으로 사용**된다.
4. 프로그램이 종료되기 전까지 동일한 인스턴스로 유지된다. 따라서 **공통적으로 사용되는 속성, 상수, 함수**를 묶어 관리할 때 유용하다.

# **클래스 내부의  object :  companion object**

Kotlin에서는 클래스 내부에도 object를 선언할 수 있다. 이를 **Companion Object** 라고 한다.

동반 객체는 클래스의 인스턴스 기능은 그대로 유지하면서, 인스턴스 간에 **공통으로 사용할 속성과 함수**를 따로 관리할 수 있게 한다. 이는 **다른 언어의 static 멤버**와 비슷한 개념이다.

```kotlin
fun main() {
    var a = FoodPoll("짜장")
    var b = FoodPoll("짬뽕")

    a.vote()
    a.vote()

    b.vote()
    b.vote()
    b.vote()

    println("${a.name} : ${a.count}")
    println("${b.name} : ${b.count}")
    println("총계 : ${FoodPoll.total}")
}

class FoodPoll(val name: String) {
    companion object {
        var total = 0
    }

    var count = 0

    fun vote() {
        total++
        count++
    }
}
```

```kotlin
짜장 : 2
짬뽕 : 3
총계 : 5
```

- FoodPoll 클래스의 인스턴스 a(짜장), b(짬뽕)는 각각 별도의 객체이다.
- 그러나 companion object 안의 total은 모든 인스턴스가 공유하는 공용 변수이다. 즉, a와 b가 vote()를 실행할 때마다 total이 함께 증가한다.
- 이렇게 하면 클래스 전체 차원에서의 누적 데이터 관리가 가능하다.