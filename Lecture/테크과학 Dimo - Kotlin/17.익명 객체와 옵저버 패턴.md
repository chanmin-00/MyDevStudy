# 옵저버

옵저버(Observer) 는 “이벤트를 감시하는 감시자”의 역할을 하는 객체를 말한다. 즉, 특정 이벤트가 발생했을 때 자동으로 감지하고 반응하도록 만드는 프로그래밍 패턴이다.

직접 함수를 호출하지 않아도, 시스템이나 루틴 내부에서 발생하는 이벤트(키 입력, 터치 등) 반응하도록 설계된 구조를 **옵저버 패턴(Observer Pattern)** 이라 한다.

**명시적으로 호출하지 않았지만 발생하는 이벤트**를 즉시 처리할 수 있도록 만드는 것이 **옵저버 패턴의 핵심 목적**이다.

## 옵저버 패턴 구성 요소

옵저버 패턴을 구현하기 위해서는 두 개의 클래스가 필요하다.

1. **이벤트를 수신하는 클래스** → 이벤트 발생 시 호출되어 동작을 수행한다.
2. **이벤트를 발생시키는 클래스** → 이벤트를 감지하고 옵저버에게 전달한다.

이벤트를 발생시키는 클래스는 직접적으로 누가 이벤트를 수신할지(어떤 객체인지) 알 수 없다. 이를 해결하기 위해 **인터페이스(interface)** 를 중간에 둔다.

이 인터페이스는 옵저버가 되어 이벤트를 수신하고, 이벤트가 전달되는 행위를 **콜백(callback)** 이라 한다. Kotlin에서는 이를 보통 **Listener** 라고 부른다.

```kotlin
fun main() {
    EventPrinter().start()
}

// 이벤트를 전달받는 인터페이스
interface EventListener {
    fun onEvent(count: Int)
}

// 이벤트를 발생시키는 클래스
class Counter(var listener: EventListener) {
    fun count() {
        for (i in 1..100) {
            if (i % 5 == 0) listener.onEvent(i)
        }
    }
}

// 이벤트를 처리하는 클래스
class EventPrinter : EventListener {

    override fun onEvent(count: Int) {
        print("${count}-")
    }

    fun start() {
        val counter = Counter(this)
        counter.count()
    }
}
```

1. **EventListener 인터페이스**
    - 이벤트를 전달받기 위한 함수(onEvent)를 정의한다.
    - 관례적으로 on(행위) 형태의 함수명을 사용한다.
2. **Counter 클래스**
    - EventListener 타입의 listener를 전달받는다.
    - 1부터 100까지 반복하면서, **5의 배수일 때 onEvent() 호출**.
3. **EventPrinter 클래스**
    - EventListener를 구현하여 이벤트 수신 후 출력 기능 수행한다.
    - Counter(this)를 통해 자신을 리스너로 등록하고 카운팅 시작한다.

실행하면 5의 배수마다 onEvent()가 호출되어 5-10-15-20-... 형태로 출력된다.

# 익명 객체

EventPrinter처럼 인터페이스를 상속받아 별도로 클래스를 만들지 않아도, **즉시 인터페이스를 구현한 객체를 생성해 전달할 수 있다.**

이런 형태를 **익명 객체(Anonymous Object)** 라고 한다.

```kotlin
fun main() {
    EventPrinter().start()
}

interface EventListener {
    fun onEvent(count: Int)
}

class Counter(var listener: EventListener) {
    fun count() {
        for (i in 1..100) {
            if (i % 5 == 0) listener.onEvent(i)
        }
    }
}

class EventPrinter {
    fun start() {
        val counter = Counter(object : EventListener {
            override fun onEvent(count: Int) {
                print("${count} - ")
            }
        })
        counter.count()
    }
}
```

- object : EventListener { ... } → EventListener를 **즉석에서 구현한 익명 객체**를 생성한다.
- 이 객체는 이름이 없고, 코드 중간에서 바로 생성되어 사용된다.
- 별도의 클래스를 정의할 필요 없이 즉시 인터페이스 구현 가능하다.
- 구조상 object 키워드와 유사하지만, **이름이 없는 것**이 가장 큰 차이점이다.