# Docker

도커는 **애플리케이션과 실행환경을 함께 묶어 컨테이너 단위로 관리, 운영할 수 있게 해주는 오픈 소스 가상화 플랫폼**이다.

즉, 단순히 컨테이너를 실행하는 것에 그치지 않고, 컨테이너를 **생성, 배포, 실행, 관리**하는 전 과정을 지원한다.

## 특징

도커는 컨테이너 기술을 기반으로 애플리케이션을 보다 효율적이고 안정적으로 실행, 배포할 수 있게 해주는 플랫폼이다. 여러 장점이 있는데, 이를 통해 개발과 운영 모두에서 생산성과 안정성을 높일 수 있다.

- **빠른 실행 속도**
    
    도커 컨테이너는 가상머신보다 훨씬 가볍게 동작하므로 애플리케이션을 빠르게 실행할 수 있다.
    
- **손쉬운 배포**
    
    애플리케이션과 실행 환경이 하나의 컨테이너 이미지로 묶여 있어, 어디서든 동일한 환경으로 손쉽게 배포 가능하다.
    
- **가벼운 용량**
    
    컨테이너는 필요한 파일과 라이브러리만 포함하므로 자원 소모가 적고, 하나의 서버에서 다수 실행이 가능하다.
    
- **애플리케이션의 독립성**
    
    각각의 컨테이너는 다른 컨테이너와 격리되어 동작하기 때문에 충돌 없이 독립적으로 실행된다.
    
- **높은 보안성 보장**
    
    컨테이너 간 격리와 권한 제어를 통해 보안을 강화할 수 있다.
    
- **낮은 오버헤드**
    
    하이퍼바이저를 거치지 않고 직접 OS 위에서 동작하기 때문에 성능 손실이 적다.
    
- **이미지 생성 및 공유**
    
    도커 허브(Docker Hub) 같은 저장소를 통해 컨테이너 이미지를 쉽게 생성하고 공유할 수 있어 협업이 용이하다.
    

## Dockerfile

도커에서 컨테이너를 만들기 위한 과정은 세 단계로 정리된다.

1. **Dockerfile**
    - **컨테이너를 어떻게 만들지를 정의해둔 설정 파일**이다.
    - 애플리케이션 실행에 필요한 환경, 의존성, 명령어 등이 정형화된 방식으로 작성된다.
    - 도커 이미지를 생성하기 위한 설정 파일이며, 다양한 도커 파일 명령어를 사용하여 작성한다.
2. **Docker Image (Build 단계)**
    - Dockerfile과 애플리케이션 파일(war, jar 등)을 묶어 **하나의 도커 이미지**로 빌드한다.
    - 이미지는 실행 가능한 패키지 형태로, 컨테이너 생성의 기반이 된다.
    - 도커 이미지는 컨테이너 실행에 필요한 파일과 설정 값 등을 포함하고 있으며 도커 파일을 빌드하여 생성한다.
3. **Docker Container (Run 단계)**
    - 빌드된 이미지를 실행하면 **컨테이너**가 만들어진다.
    - 컨테이너는 독립된 실행 환경으로, 실제 서비스가 동작하는 단위다.
    - 도커 컨테이너는 격리된 공간에서 애플리케이션을 동작시킨 상태이며 도커 이미지를 Run하여 도커 컨테이너를 실행한다.

## **Podman 정의**

Podman은 **리눅스 환경에서 컨테이너와 컨테이너 이미지를 실행, 관리, 배포**할 수 있도록 만들어진 **데몬리스(Daemonless) 컨테이너 엔진**이다.

### **주요 특징**

1. **Pod Manager Tool**
    - Podman은 *Pod Manager*의 약자로, 여러 컨테이너를 하나의 Pod 단위로 묶어 관리할 수 있다.
2. **Rootless 실행 지원**
    - 루트 권한 없이 컨테이너와 Pod를 실행할 수 있다.
    - 보안 리스크를 줄이고, 사용자 친화적인 접근 환경 제공.
3. **OCI(Open Container Initiative) 표준 준수**
    - Docker와 호환되는 CLI(Command Line Interface)를 제공하여, 명령어 사용이 거의 동일하다.
4. **RESTful API 제공**
    - 컨테이너를 효율적으로 관리할 수 있도록 REST API를 지원한다.

## **Podman 정의**

Podman은 리눅스 시스템에서 **컨테이너와 컨테이너 이미지를 실행, 관리, 배포**할 수 있도록 설계된 **데몬리스(Daemonless) 컨테이너 엔진**이다. 데몬 프로세스 없이도 동작한다는 점이 가장 큰 특징이다. Daemon은 서비스 요청에 대해 응답하기 위해 오랫동안 (long-running) 실행중인 백그라운드 프로세스를 의미한다.

- Podman이라는 이름은 **Pod Manager tool**의 약자이며, 이름 그대로 여러 컨테이너를 Pod 단위로 묶어 관리할 수 있다.
- Rootless 모드를 지원하기 때문에 루트 권한이 없는 상태에서도 컨테이너와 Pod를 실행하고 분리할 수 있으며, 이로 인해 접근성이 높아지고 동시에 보안 리스크를 줄일 수 있다.
- 또한 Podman은 **OCI(Open Container Initiative) 표준**을 준수한다. 이 덕분에 Docker와 거의 동일한 CLI(Command)를 사용할 수 있어, Docker 사용자라면 명령어 전환에 큰 어려움이 없다.
- 마지막으로, Podman은 컨테이너 관리 기능을 강화하기 위해 **RESTful API**를 제공한다. 이를 통해 CLI뿐 아니라 API 기반의 자동화된 컨테이너 관리도 가능하다.

## Docker와 Podman의 차이

<img width="517" height="212" alt="image" src="https://github.com/user-attachments/assets/a2bb180c-c84c-4e52-8cdb-ba60f7afd2df" />


Docker와 Podman은 모두 컨테이너 실행을 위한 도구이지만 구조적 차이로 인해 운영 방식이 다르다.

- **Docker**는 **데몬(Daemon) 프로그램**을 중심으로 동작한다. 사용자가 CLI 명령을 입력하면 실제 실행은 데몬이 처리하며, 데몬이 중단되면 컨테이너도 함께 멈춘다. 관리가 단순하다는 장점이 있지만 root 권한으로 동작하기 때문에 보안 강화를 위해 추가 설정이 필요하다.
- **Podman**은 데몬 없는 구조(daemonless)를 가진다. CLI가 직접 컨테이너를 제어하므로 데몬에 의존하지 않으며, rootless 모드를 지원해 보안성이 강화된다. 또한 Pod 단위를 지원하여 쿠버네티스와의 연동성이 높다.

두 도구 모두 동일한 레지스트리(Docker Hub, RedHat, Nginx, MongoDB 등)를 사용할 수 있고 명령어도 호환된다. 그러나 Docker는 **데몬 기반의 단순성**이 강점인 반면, Podman은 **보안성과 쿠버네티스 친화성**이 장점인 대안이다.

<img width="451" height="448" alt="image" src="https://github.com/user-attachments/assets/1fcfaeb9-c7a0-4a26-875d-13f25c88df72" />


## Dockerfile 작성

컨테이너를 만들기 위해서 Dockerfile 이라는 템플릿을 사용한다.

```docker
FROM tomcat:9-jre8-alpine
WORKDIR /usr/local/tomcat
COPY server.xml ./conf
RUN rm -rf ./webapps/*
ARG JAR_FILE=*.war
COPY ${JAR_FILE} ./webapps/edu-msa-board-1.0.0.war
EXPOSE 28082
```

1. **FROM**
    - 컨테이너 기반이 되는 **베이스 이미지**이다.
    - 컨테이너를 만들 때 어떤 이미지를 사용할지 지정한다.
2. **WORKDIR**
    - 명령을 실행할 **작업 디렉토리**를 설정하는 명령어이다.
3. **COPY**
    - 컨테이너 빌드 시, **호스트의 파일을 컨테이너 내부로 복사**하는 명령어이다.
    - 어떤 파일을 복사할 것인지와 복사할 경로를 명시한다.
4. **RUN**
    - 베이스 이미지에서 실행할 명령어이다.
    - 현재는 ./webapps 디렉토리 안에 있는 기본 애플리케이션들을 모두 삭제하는 역할을 한다.
5. **ARG**
    - 파일에서 사용할 변수 값을 설정하는 명령어이다.
    - 현재는 JAR_FILE이라는 변수를 *.war로 받아 빌드 시 적용하도록 하고 있다.
6. **EXPOSE**
    - 외부에 노출시킬 포트 번호를 지정하는 명령어이다.
    - 현재는 컨테이너가 **28082번 포트**를 사용하도록 설정되어 있다.
    - 만드는 서비스마다 명령어가 동일하지 않고, 보통 스프링에서는 EXPOSE를 사용하지 않는 경우도 있다 .개발 시 필요한 컨테이너 명령어를 적절하게 사용해서 컨테이너를 활용하면 된다.

```docker
FROM openjdk:8-jdk-alpine
ARG JAR_FILE=edu-msa-zuul-1.0.0.war
COPY ${JAR_FILE} edu-msa-zuul-1.0.0.war
COPY application.yml /application.yml
ENTRYPOINT ["java","-jar","-Dspring.config.location=application.yml","/edu-msa-zuul-1.0.0.war"]
```

1. **ENTRYPOINT**
    - 컨테이너 실행 시 수행되는 명령어를 지정한다.
    - 현재 설정은 java -jar 명령어로 edu-msa-zuul-1.0.0.war 파일을 실행하면서, application.yml을 스프링 설정 파일로 적용하도록 한다.
    - 즉, 컨테이너가 시작되면 자동으로 해당 애플리케이션이 구동되도록 만든 것이다.

## Docker CLI

Docker 명령은 Docker-CLI와 유사한 CLI를 사용한다. 대부분 추가 권한 없이 일반 사용자로 실행할 수 있다.

```bash
$ docker [options] command
```

- docker 명령어 뒤에 **옵션**과 **실행할 명령(command)**을 붙여 사용하는 구조이다.

1. **$ docker version**
    
    Docker 버전 정보를 표시한다.
    
    ```bash
    docker version [options]
    ```
    
    ```bash
    $ docker version
    Client: Docker Engine - Community
    Version: 26.1.3
    API version: 1.45
    Go version: go1.21.10
    Git commit: b72abbb
    Built: Thu May 16 08:33:29 2024
    OS/Arch: linux/amd64
    Context: default
    ```
    
2. **$ docker login (또는 logout)**
    
    컨테이너 레지스트리에 로그인/로그아웃한다. registry는 이미지를 저장할 레지스트리 주소이다.
    
    ```bash
    docker login [options] [registry]
    ```
    
    ```bash
    $ docker login docker.io
    Username: ubuntu
    Password: Login Succeeded!
    ```
    
    - docker.io는 도커 허브를 통칭한다.
3. **$ docker build**
    
    컨테이너 파일을 사용하여 컨테이너 이미지를 빌드한다.
    
    ```bash
    docker build [options] [context]
    ```
    
    ```bash
    $ docker build .
    $ docker build -f [Containerfile.simple] .
    $ docker build --tag [imageName]:latest .
    ```
    
    - war, jar, dockerfile을 묶어서 이미지로 만든다.
    - docker build는 Dockerfile(혹은 Containerfile)에 정의된 내용을 기반으로 애플리케이션 실행 환경을 하나의 이미지로 만든다. 예를 들어, --tag 옵션을 사용하면 이미지에 이름과 태그를 붙여 관리하기가 편해진다.
4. **$ docker tag**
    
    로컬 이미지에 새로운 이름을 추가한다. docker tag는 이미 만들어진 이미지에 별칭을 붙이는 명령어이다. 주로 **이미지를 도커 허브나 개인 레지스트리에 업로드하기 전에 저장소 주소와 버전을 지정**할 때 사용한다.
    
    ```bash
    docker tag image[:tag] [target-name[:tag]] [options]
    ```
    
    ```bash
    $ docker tag 0e3bbc2 fedora:latest
    $ docker tag httpd myregistryhost:5000/fedora/httpd:v2
    $ docker tag edu-msa-board ${도커허브 ID}/edu-msa-board
    ```
    
5. **$ docker pull**
    
    레지스트리에서 이미지를 가져온다. docker pull은 원격 저장소(예: Docker Hub, Quay.io 등)에 있는 이미지를 다운로드해서 로컬 환경에 저장한다. 애플리케이션을 실행하기 전에 필요한 이미지를 미리 받아올 때 사용된다.
    
    ```bash
    docker pull [options] source [source...]
    ```
    
    ```bash
    $ docker pull quay.io/username/myimage
    $ docker pull fedora
    ```
    
6. **$ docker push**
    
    이미지, 매니페스트 목록 또는 이미지 인덱스를 local 스토리지에서 다른 레지스트리로 보낸다.
    
    docker push는 로컬에서 만든 이미지를 원격 저장소로 업로드할 때 사용된다. 개발자가 만든 애플리케이션 이미지를 팀원들과 공유하거나 배포 환경에서 사용할 수 있도록 레지스트리에 올리는 과정이다.
    
    ```bash
    docker push [options] image [destination]
    ```
    
    ```bash
    $ docker push quay.io/docker/stable
    $ docker push docker://quay.io/docker/stable
    $ docker push ${도커허브 ID}/edu-msa-board
    ```
    
7. **$ docker run**
    
    컨테이너 이미지로 새 컨테이너를 실행한다. docker run은 이미지로부터 새로운 컨테이너를 만드는 가장 기본적인 명령이다. 옵션에 따라 컨테이너를 인터랙티브 모드로 실행하거나, 특정 명령을 바로 실행할 수도 있다.
    
    ```bash
    docker run [options] image [command [arg...]]
    ```
    
    ```bash
    $ docker run --read-only -i -t fedora /bin/bash
    $ docker run -a stdin -a stdout -i -t fedora /bin/bash
    $ docker run -it --ipc=host shm ipcs -m
    ```
    
8. **$ docker exec**
    
    실행 중인 컨테이너 안에서 명령을 실행한다. docker exec은 이미 실행 중인 컨테이너 안으로 들어가 추가 명령을 실행할 때 사용된다. 주로 컨테이너 내부에서 디버깅이나 설정 확인을 할 때 많이 활용된다.
    
    ```bash
    docker exec [options] container [command [arg...]]
    ```
    
    ```bash
    $ docker exec -it [컨테이너 이름] bash
    $ docker exec -it ctrID ls
    $ docker exec -it -w /tmp myCtr pwd
    $ docker exec --user root ctrID ls
    ```
    
9. **$ docker stop**
    
    실행 중인 컨테이너를 중지한다. docker stop은 컨테이너에 정상 종료 신호(SIGTERM)를 보내서 안전하게 종료시키는 명령이다. 내부 프로세스가 정리될 시간을 주고 멈추기 때문에 데이터 손실을 최소화할 수 있다.
    
    ```bash
    docker stop [options] container ...
    ```
    
    ```bash
    $ docker stop [컨테이너 이름 / 컨테이너 ID]
    $ docker stop --cidfile [파일 경로]
    $ docker stop -a
    $ docker stop --latest
    ```
    
10. **$ docker kill**
    
    실행 중인 컨테이너를 즉시 종료한다. docker kill은 컨테이너에 강제 종료 신호(SIGKILL)를 보내서 바로 멈추게 한다. 정리 과정 없이 즉시 중단되므로 급하게 멈춰야 할 때는 유용하지만, 데이터 손실 위험이 있다.
    
    ```bash
    docker kill [options] [container ...]
    ```
    
    ```bash
    $ docker kill [컨테이너 이름 / 컨테이너 ID]
    $ docker kill --cidfile [파일 경로]
    $ docker kill --signal KILL -a
    ```
    
11. **$ docker ps**
    
    컨테이너에 대한 정보를 출력한다. docker ps는 현재 실행 중이거나 정지된 컨테이너 목록을 확인할 때 사용된다. 옵션에 따라 상태, 리소스 사용량 등 더 많은 정보를 볼 수 있다.
    
    ```bash
    docker ps [options]
    ```
    
    ```bash
    $ docker ps -a
    $ docker ps -a -s
    $ docker ps --ns -a
    ```
    
12. **$ docker rm**
    
    컨테이너를 삭제한다. docker rm은 필요하지 않은 컨테이너를 지울 때 사용한다. -f 옵션을 붙이면 실행 중인 컨테이너도 강제로 삭제할 수 있다.
    
    ```bash
    docker rm [options] container
    ```
    
    ```bash
    $ docker rm [컨테이너 이름]
    $ docker rm -f [컨테이너 ID]
    $ docker rm -f -a
    $ docker rm -f --latest
    ```
